package kubernetes_test

import (
	"fmt"
	"testing"

	"k8s.io/apimachinery/pkg/api/equality"

	kubermaticv1lister "github.com/kubermatic/kubermatic/api/pkg/crd/client/listers/kubermatic/v1"
	kubermaticv1 "github.com/kubermatic/kubermatic/api/pkg/crd/kubermatic/v1"
	"github.com/kubermatic/kubermatic/api/pkg/provider"
	"github.com/kubermatic/kubermatic/api/pkg/provider/kubernetes"

	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime"
)

func TestCreateServiceAccount(t *testing.T) {
	// test data
	testcases := []struct {
		name                      string
		existingKubermaticObjects []runtime.Object
		project                   *kubermaticv1.Project
		userInfo                  *provider.UserInfo
		saName                    string
		saGroup                   string
		expectedSA                *kubermaticv1.User
		expectedSAName            string
	}{
		{
			name:     "scenario 1, create service account `test` for editors group",
			userInfo: &provider.UserInfo{Email: "john@acme.com", Group: "owners-abcd"},
			project:  createProject("abcd"),
			saName:   "test",
			saGroup:  "editors-abcd",
			existingKubermaticObjects: []runtime.Object{
				createAuthenitactedUser(),
				createProject("abcd"),
			},
			expectedSA:     createSA("test", "abcd", "editors", "1"),
			expectedSAName: "serviceaccount-1",
		},
	}
	for _, tc := range testcases {
		t.Run(tc.name, func(t *testing.T) {

			impersonationClient, _, indexer, err := createFakeClients(tc.existingKubermaticObjects)
			if err != nil {
				t.Fatalf("unable to create fake clients, err = %v", err)
			}

			saLister := kubermaticv1lister.NewUserLister(indexer)

			// act
			target := kubernetes.NewServiceAccountProvider(impersonationClient.CreateFakeImpersonatedClientSet, saLister, "localhost")
			if err != nil {
				t.Fatal(err)
			}

			sa, err := target.CreateServiceAccount(tc.userInfo, tc.project, tc.saName, tc.saGroup)

			// validate
			if err != nil {
				t.Fatal(err)
			}

			//remove autogenerated fields
			sa.Name = tc.expectedSAName
			sa.Spec.Email = ""
			sa.Spec.ID = ""

			if !equality.Semantic.DeepEqual(sa, tc.expectedSA) {
				t.Fatalf("expected %v got %v", tc.expectedSA, sa)
			}
		})
	}
}

func TestGetServiceAccountByNameForProject(t *testing.T) {
	// test data
	testcases := []struct {
		name                      string
		existingKubermaticObjects []runtime.Object
		projectName               string
		saName                    string
		userInfo                  *provider.UserInfo
		expectedSA                *kubermaticv1.User
		expectedError             string
	}{
		{
			name:        "scenario 1, get existing service account",
			userInfo:    &provider.UserInfo{Email: "john@acme.com", Group: "owners-abcd"},
			projectName: "abcd",
			saName:      "test",
			existingKubermaticObjects: []runtime.Object{
				createAuthenitactedUser(),
				createSA("test", "abcd", "editors", "1"),
			},
			expectedSA: createSA("test", "abcd", "editors", "1"),
		},
		{
			name:        "scenario 2, service account not found",
			userInfo:    &provider.UserInfo{Email: "john@acme.com", Group: "owners-abcd"},
			projectName: "abcd",
			saName:      "test",
			existingKubermaticObjects: []runtime.Object{
				createAuthenitactedUser(),
				createSA("test-1", "bbbb", "editors", "1"),
			},
			expectedError: `ServiceAccount "test" not found`,
		},
	}
	for _, tc := range testcases {
		t.Run(tc.name, func(t *testing.T) {

			impersonationClient, _, indexer, err := createFakeClients(tc.existingKubermaticObjects)
			if err != nil {
				t.Fatalf("unable to create fake clients, err = %v", err)
			}
			saLister := kubermaticv1lister.NewUserLister(indexer)
			// act
			target := kubernetes.NewServiceAccountProvider(impersonationClient.CreateFakeImpersonatedClientSet, saLister, "localhost")
			if err != nil {
				t.Fatal(err)
			}

			sa, err := target.GetServiceAccountByNameForProject(tc.userInfo, tc.saName, tc.projectName)
			if len(tc.expectedError) > 0 {
				//validate
				if err == nil {
					t.Fatalf("expected error with message %s", tc.expectedError)
				}
				if err.Error() != tc.expectedError {
					t.Fatalf("expected error %s got %s", tc.expectedError, err.Error())
				}

			} else {
				// validate
				if err != nil {
					t.Fatal(err)
				}
				if !equality.Semantic.DeepEqual(sa, tc.expectedSA) {
					t.Fatalf("expected %v got %v", tc.expectedSA, sa)
				}
			}
		})
	}
}

func TestList(t *testing.T) {
	// test data
	testcases := []struct {
		name                      string
		existingKubermaticObjects []runtime.Object
		projectName               string
		userInfo                  *provider.UserInfo
		expectedSA                []*kubermaticv1.User
		expectedError             string
	}{
		{
			name:        "scenario 1, get existing service account list",
			userInfo:    &provider.UserInfo{Email: "john@acme.com", Group: "owners-abcd"},
			projectName: "abcd",
			existingKubermaticObjects: []runtime.Object{
				createAuthenitactedUser(),
				createSA("test-1", "abcd", "editors", "1"),
				createSA("test-2", "abcd", "viewers", "2"),
				createSA("test-3", "abcd", "editors", "3"),
				createSA("test-1", "aaaa", "editors", "4"),
				createSA("test-1", "bbbb", "editors", "5"),
			},
			expectedSA: []*kubermaticv1.User{
				createSA("test-1", "abcd", "editors", "1"),
				createSA("test-2", "abcd", "viewers", "2"),
				createSA("test-3", "abcd", "editors", "3"),
			},
		},
		{
			name:          "scenario 2, check parameters validation, empty project",
			userInfo:      &provider.UserInfo{Email: "john@acme.com", Group: "owners-abcd"},
			projectName:   "",
			expectedError: "project name cannot be empty",
		},
		{
			name:          "scenario 2, check parameters validation, userInfo is nil",
			userInfo:      nil,
			projectName:   "abcd",
			expectedError: "userInfo cannot be nil",
		},
	}
	for _, tc := range testcases {
		t.Run(tc.name, func(t *testing.T) {

			impersonationClient, _, indexer, err := createFakeClients(tc.existingKubermaticObjects)
			if err != nil {
				t.Fatalf("unable to create fake clients, err = %v", err)
			}
			saLister := kubermaticv1lister.NewUserLister(indexer)
			// act
			target := kubernetes.NewServiceAccountProvider(impersonationClient.CreateFakeImpersonatedClientSet, saLister, "localhost")
			if err != nil {
				t.Fatal(err)
			}

			saList, err := target.List(tc.userInfo, tc.projectName)
			if len(tc.expectedError) > 0 {
				//validate
				if err == nil {
					t.Fatalf("expected error with message %s", tc.expectedError)
				}
				if err.Error() != tc.expectedError {
					t.Fatalf("expected error %s got %s", tc.expectedError, err.Error())
				}

			} else {
				// validate
				if err != nil {
					t.Fatal(err)
				}
				if len(tc.expectedSA) != len(saList) {
					t.Fatalf("expected to get %d service accounts, but got %d", len(tc.expectedSA), len(saList))
				}
				objects := convertPointerList(saList)
				expectedObjects := convertPointerList(tc.expectedSA)

				if !equality.Semantic.DeepEqual(objects, expectedObjects) {
					t.Fatalf("expected %v got %v", expectedObjects, objects)
				}
			}
		})
	}
}

func convertPointerList(items []*kubermaticv1.User) []kubermaticv1.User {
	resultList := make([]kubermaticv1.User, 0)
	for _, item := range items {
		resultList = append(resultList, *item)
	}
	return resultList
}

func createSA(name, projectName, group, id string) *kubermaticv1.User {
	sa := &kubermaticv1.User{}
	sa.OwnerReferences = []metav1.OwnerReference{
		{
			APIVersion: kubermaticv1.SchemeGroupVersion.String(),
			Kind:       kubermaticv1.ProjectKindName,
			UID:        "",
			Name:       projectName,
		},
	}
	sa.Name = fmt.Sprintf("serviceaccount-%s", id)
	sa.Spec.Name = name

	sa.Labels = map[string]string{kubernetes.ServiceAccountLabelGroup: fmt.Sprintf("%s-%s", group, projectName)}
	return sa
}
