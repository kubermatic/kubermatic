package kubernetes_test

import (
	"fmt"
	"testing"

	"k8s.io/apimachinery/pkg/api/equality"

	kubermaticv1lister "github.com/kubermatic/kubermatic/api/pkg/crd/client/listers/kubermatic/v1"
	kubermaticv1 "github.com/kubermatic/kubermatic/api/pkg/crd/kubermatic/v1"
	"github.com/kubermatic/kubermatic/api/pkg/provider"
	"github.com/kubermatic/kubermatic/api/pkg/provider/kubernetes"

	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime"
)

func TestCreateServiceAccount(t *testing.T) {
	// test data
	testcases := []struct {
		name                      string
		existingKubermaticObjects []runtime.Object
		project                   *kubermaticv1.Project
		userInfo                  *provider.UserInfo
		saName                    string
		saGroup                   string
		expectedSA                *kubermaticv1.User
	}{
		{
			name:     "scenario 1, create service account `test` for editors group",
			userInfo: &provider.UserInfo{Email: "john@acme.com", Group: "owners-abcd"},
			project:  createProject("abcd"),
			saName:   "test",
			saGroup:  "editors-abcd",
			existingKubermaticObjects: []runtime.Object{
				createAuthenitactedUser(),
				createProject("abcd"),
			},
			expectedSA: createSA("test", "abcd", "editors"),
		},
	}
	for _, tc := range testcases {
		t.Run(tc.name, func(t *testing.T) {

			impersonationClient, _, indexer, err := createFakeClients(tc.existingKubermaticObjects)
			if err != nil {
				t.Fatalf("unable to create fake clients, err = %v", err)
			}

			saLister := kubermaticv1lister.NewUserLister(indexer)

			// act
			target := kubernetes.NewServiceAccountProvider(impersonationClient.CreateFakeImpersonatedClientSet, saLister, "localhost")
			if err != nil {
				t.Fatal(err)
			}

			sa, err := target.CreateServiceAccount(tc.userInfo, tc.project, tc.saName, tc.saGroup)

			// validate
			if err != nil {
				t.Fatal(err)
			}

			//remove autogenerated fields
			sa.Name = "serviceaccount-test"
			sa.Spec.Email = ""
			sa.Spec.ID = ""

			if !equality.Semantic.DeepEqual(sa, tc.expectedSA) {
				t.Fatalf("expected %v got %v", tc.expectedSA, sa)
			}
		})
	}
}

func TestGetServiceAccountByNameForProject(t *testing.T) {
	// test data
	testcases := []struct {
		name                      string
		existingKubermaticObjects []runtime.Object
		projectName               string
		saName                    string
		userInfo                  *provider.UserInfo
		expectedSA                *kubermaticv1.User
		expectedError             string
	}{
		{
			name:        "scenario 2, get existing service account",
			userInfo:    &provider.UserInfo{Email: "john@acme.com", Group: "owners-abcd"},
			projectName: "abcd",
			saName:      "test",
			existingKubermaticObjects: []runtime.Object{
				createAuthenitactedUser(),
				createSA("test", "abcd", "editors"),
			},
			expectedSA: createSA("test", "abcd", "editors"),
		},
		{
			name:        "scenario 2, service account not found",
			userInfo:    &provider.UserInfo{Email: "john@acme.com", Group: "owners-abcd"},
			projectName: "abcd",
			saName:      "test",
			existingKubermaticObjects: []runtime.Object{
				createAuthenitactedUser(),
				createSA("test-1", "bbbb", "editors"),
			},
			expectedError: `ServiceAccount "test" not found`,
		},
	}
	for _, tc := range testcases {
		t.Run(tc.name, func(t *testing.T) {

			impersonationClient, _, indexer, err := createFakeClients(tc.existingKubermaticObjects)
			if err != nil {
				t.Fatalf("unable to create fake clients, err = %v", err)
			}
			saLister := kubermaticv1lister.NewUserLister(indexer)
			// act
			target := kubernetes.NewServiceAccountProvider(impersonationClient.CreateFakeImpersonatedClientSet, saLister, "localhost")
			if err != nil {
				t.Fatal(err)
			}

			sa, err := target.GetServiceAccountByNameForProject(tc.userInfo, tc.saName, tc.projectName)
			if len(tc.expectedError) > 0 {
				//validate
				if err == nil {
					t.Fatalf("expected error with message %s", tc.expectedError)
				}
				if err.Error() != tc.expectedError {
					t.Fatalf("expected error %s got %s", tc.expectedError, err.Error())
				}

			} else {
				// validate
				if err != nil {
					t.Fatal(err)
				}
				if !equality.Semantic.DeepEqual(sa, tc.expectedSA) {
					t.Fatalf("expected %v got %v", tc.expectedSA, sa)
				}
			}
		})
	}
}

func createSA(name, projectName, group string) *kubermaticv1.User {
	sa := &kubermaticv1.User{}
	sa.OwnerReferences = []metav1.OwnerReference{
		{
			APIVersion: kubermaticv1.SchemeGroupVersion.String(),
			Kind:       kubermaticv1.ProjectKindName,
			UID:        "",
			Name:       projectName,
		},
	}
	sa.Name = "serviceaccount-test"
	sa.Spec.Name = name

	sa.Labels = map[string]string{kubernetes.ServiceAccountLabelGroup: fmt.Sprintf("%s-%s", group, projectName)}
	return sa
}
