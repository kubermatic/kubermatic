# This file has been generated, DO NOT EDIT.
---

{
  "metadata": {
    "name": "alertmanagers.monitoring.coreos.com"
  },
  "apiVersion": "apiextensions.k8s.io/v1beta1",
  "kind": "CustomResourceDefinition",
  "spec": {
    "conversion": {
      "strategy": "None"
    },
    "group": "monitoring.coreos.com",
    "names": {
      "kind": "Alertmanager",
      "listKind": "AlertmanagerList",
      "plural": "alertmanagers",
      "singular": "alertmanager"
    },
    "scope": "Namespaced",
    "validation": {
      "openAPIV3Schema": {
        "properties": {
          "apiVersion": {
            "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#resources",
            "type": "string"
          },
          "kind": {
            "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#types-kinds",
            "type": "string"
          },
          "spec": {
            "description": "AlertmanagerSpec is a specification of the desired behavior of the Alertmanager cluster. More info: https://github.com/kubernetes/community/blob/master/contributors/devel/api-conventions.md#spec-and-status",
            "properties": {
              "additionalPeers": {
                "description": "AdditionalPeers allows injecting a set of additional Alertmanagers to peer with to form a highly available cluster.",
                "items": {
                  "type": "string"
                },
                "type": "array"
              },
              "affinity": {
                "description": "Affinity is a group of affinity scheduling rules.",
                "properties": {
                  "nodeAffinity": {
                    "description": "Node affinity is a group of node affinity scheduling rules.",
                    "properties": {
                      "preferredDuringSchedulingIgnoredDuringExecution": {
                        "description": "The scheduler will prefer to schedule pods to nodes that satisfy the affinity expressions specified by this field, but it may choose a node that violates one or more of the expressions. The node that is most preferred is the one with the greatest sum of weights, i.e. for each node that meets all of the scheduling requirements (resource request, requiredDuringScheduling affinity expressions, etc.), compute a sum by iterating through the elements of this field and adding \"weight\" to the sum if the node matches the corresponding matchExpressions; the node(s) with the highest sum are the most preferred.",
                        "items": {
                          "description": "An empty preferred scheduling term matches all objects with implicit weight 0 (i.e. it's a no-op). A null preferred scheduling term matches no objects (i.e. is also a no-op).",
                          "properties": {
                            "preference": {
                              "description": "A null or empty node selector term matches no objects. The requirements of them are ANDed. The TopologySelectorTerm type implements a subset of the NodeSelectorTerm.",
                              "properties": {
                                "matchExpressions": {
                                  "description": "A list of node selector requirements by node's labels.",
                                  "items": {
                                    "description": "A node selector requirement is a selector that contains values, a key, and an operator that relates the key and values.",
                                    "properties": {
                                      "key": {
                                        "description": "The label key that the selector applies to.",
                                        "type": "string"
                                      },
                                      "operator": {
                                        "description": "Represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.",
                                        "type": "string"
                                      },
                                      "values": {
                                        "description": "An array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. If the operator is Gt or Lt, the values array must have a single element, which will be interpreted as an integer. This array is replaced during a strategic merge patch.",
                                        "items": {
                                          "type": "string"
                                        },
                                        "type": "array"
                                      }
                                    },
                                    "required": [
                                      "key",
                                      "operator"
                                    ]
                                  },
                                  "type": "array"
                                },
                                "matchFields": {
                                  "description": "A list of node selector requirements by node's fields.",
                                  "items": {
                                    "description": "A node selector requirement is a selector that contains values, a key, and an operator that relates the key and values.",
                                    "properties": {
                                      "key": {
                                        "description": "The label key that the selector applies to.",
                                        "type": "string"
                                      },
                                      "operator": {
                                        "description": "Represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.",
                                        "type": "string"
                                      },
                                      "values": {
                                        "description": "An array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. If the operator is Gt or Lt, the values array must have a single element, which will be interpreted as an integer. This array is replaced during a strategic merge patch.",
                                        "items": {
                                          "type": "string"
                                        },
                                        "type": "array"
                                      }
                                    },
                                    "required": [
                                      "key",
                                      "operator"
                                    ]
                                  },
                                  "type": "array"
                                }
                              }
                            },
                            "weight": {
                              "description": "Weight associated with matching the corresponding nodeSelectorTerm, in the range 1-100.",
                              "format": "int32",
                              "type": "integer"
                            }
                          },
                          "required": [
                            "weight",
                            "preference"
                          ]
                        },
                        "type": "array"
                      },
                      "requiredDuringSchedulingIgnoredDuringExecution": {
                        "description": "A node selector represents the union of the results of one or more label queries over a set of nodes; that is, it represents the OR of the selectors represented by the node selector terms.",
                        "properties": {
                          "nodeSelectorTerms": {
                            "description": "Required. A list of node selector terms. The terms are ORed.",
                            "items": {
                              "description": "A null or empty node selector term matches no objects. The requirements of them are ANDed. The TopologySelectorTerm type implements a subset of the NodeSelectorTerm.",
                              "properties": {
                                "matchExpressions": {
                                  "description": "A list of node selector requirements by node's labels.",
                                  "items": {
                                    "description": "A node selector requirement is a selector that contains values, a key, and an operator that relates the key and values.",
                                    "properties": {
                                      "key": {
                                        "description": "The label key that the selector applies to.",
                                        "type": "string"
                                      },
                                      "operator": {
                                        "description": "Represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.",
                                        "type": "string"
                                      },
                                      "values": {
                                        "description": "An array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. If the operator is Gt or Lt, the values array must have a single element, which will be interpreted as an integer. This array is replaced during a strategic merge patch.",
                                        "items": {
                                          "type": "string"
                                        },
                                        "type": "array"
                                      }
                                    },
                                    "required": [
                                      "key",
                                      "operator"
                                    ]
                                  },
                                  "type": "array"
                                },
                                "matchFields": {
                                  "description": "A list of node selector requirements by node's fields.",
                                  "items": {
                                    "description": "A node selector requirement is a selector that contains values, a key, and an operator that relates the key and values.",
                                    "properties": {
                                      "key": {
                                        "description": "The label key that the selector applies to.",
                                        "type": "string"
                                      },
                                      "operator": {
                                        "description": "Represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.",
                                        "type": "string"
                                      },
                                      "values": {
                                        "description": "An array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. If the operator is Gt or Lt, the values array must have a single element, which will be interpreted as an integer. This array is replaced during a strategic merge patch.",
                                        "items": {
                                          "type": "string"
                                        },
                                        "type": "array"
                                      }
                                    },
                                    "required": [
                                      "key",
                                      "operator"
                                    ]
                                  },
                                  "type": "array"
                                }
                              }
                            },
                            "type": "array"
                          }
                        },
                        "required": [
                          "nodeSelectorTerms"
                        ]
                      }
                    }
                  },
                  "podAffinity": {
                    "description": "Pod affinity is a group of inter pod affinity scheduling rules.",
                    "properties": {
                      "preferredDuringSchedulingIgnoredDuringExecution": {
                        "description": "The scheduler will prefer to schedule pods to nodes that satisfy the affinity expressions specified by this field, but it may choose a node that violates one or more of the expressions. The node that is most preferred is the one with the greatest sum of weights, i.e. for each node that meets all of the scheduling requirements (resource request, requiredDuringScheduling affinity expressions, etc.), compute a sum by iterating through the elements of this field and adding \"weight\" to the sum if the node has pods which matches the corresponding podAffinityTerm; the node(s) with the highest sum are the most preferred.",
                        "items": {
                          "description": "The weights of all of the matched WeightedPodAffinityTerm fields are added per-node to find the most preferred node(s)",
                          "properties": {
                            "podAffinityTerm": {
                              "description": "Defines a set of pods (namely those matching the labelSelector relative to the given namespace(s)) that this pod should be co-located (affinity) or not co-located (anti-affinity) with, where co-located is defined as running on a node whose value of the label with key <topologyKey> matches that of any node on which a pod of the set of pods is running",
                              "properties": {
                                "labelSelector": {
                                  "description": "A label selector is a label query over a set of resources. The result of matchLabels and matchExpressions are ANDed. An empty label selector matches all objects. A null label selector matches no objects.",
                                  "properties": {
                                    "matchExpressions": {
                                      "description": "matchExpressions is a list of label selector requirements. The requirements are ANDed.",
                                      "items": {
                                        "description": "A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.",
                                        "properties": {
                                          "key": {
                                            "description": "key is the label key that the selector applies to.",
                                            "type": "string"
                                          },
                                          "operator": {
                                            "description": "operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.",
                                            "type": "string"
                                          },
                                          "values": {
                                            "description": "values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.",
                                            "items": {
                                              "type": "string"
                                            },
                                            "type": "array"
                                          }
                                        },
                                        "required": [
                                          "key",
                                          "operator"
                                        ]
                                      },
                                      "type": "array"
                                    },
                                    "matchLabels": {
                                      "description": "matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is \"key\", the operator is \"In\", and the values array contains only \"value\". The requirements are ANDed.",
                                      "type": "object"
                                    }
                                  }
                                },
                                "namespaces": {
                                  "description": "namespaces specifies which namespaces the labelSelector applies to (matches against); null or empty list means \"this pod's namespace\"",
                                  "items": {
                                    "type": "string"
                                  },
                                  "type": "array"
                                },
                                "topologyKey": {
                                  "description": "This pod should be co-located (affinity) or not co-located (anti-affinity) with the pods matching the labelSelector in the specified namespaces, where co-located is defined as running on a node whose value of the label with key topologyKey matches that of any node on which any of the selected pods is running. Empty topologyKey is not allowed.",
                                  "type": "string"
                                }
                              },
                              "required": [
                                "topologyKey"
                              ]
                            },
                            "weight": {
                              "description": "weight associated with matching the corresponding podAffinityTerm, in the range 1-100.",
                              "format": "int32",
                              "type": "integer"
                            }
                          },
                          "required": [
                            "weight",
                            "podAffinityTerm"
                          ]
                        },
                        "type": "array"
                      },
                      "requiredDuringSchedulingIgnoredDuringExecution": {
                        "description": "If the affinity requirements specified by this field are not met at scheduling time, the pod will not be scheduled onto the node. If the affinity requirements specified by this field cease to be met at some point during pod execution (e.g. due to a pod label update), the system may or may not try to eventually evict the pod from its node. When there are multiple elements, the lists of nodes corresponding to each podAffinityTerm are intersected, i.e. all terms must be satisfied.",
                        "items": {
                          "description": "Defines a set of pods (namely those matching the labelSelector relative to the given namespace(s)) that this pod should be co-located (affinity) or not co-located (anti-affinity) with, where co-located is defined as running on a node whose value of the label with key <topologyKey> matches that of any node on which a pod of the set of pods is running",
                          "properties": {
                            "labelSelector": {
                              "description": "A label selector is a label query over a set of resources. The result of matchLabels and matchExpressions are ANDed. An empty label selector matches all objects. A null label selector matches no objects.",
                              "properties": {
                                "matchExpressions": {
                                  "description": "matchExpressions is a list of label selector requirements. The requirements are ANDed.",
                                  "items": {
                                    "description": "A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.",
                                    "properties": {
                                      "key": {
                                        "description": "key is the label key that the selector applies to.",
                                        "type": "string"
                                      },
                                      "operator": {
                                        "description": "operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.",
                                        "type": "string"
                                      },
                                      "values": {
                                        "description": "values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.",
                                        "items": {
                                          "type": "string"
                                        },
                                        "type": "array"
                                      }
                                    },
                                    "required": [
                                      "key",
                                      "operator"
                                    ]
                                  },
                                  "type": "array"
                                },
                                "matchLabels": {
                                  "description": "matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is \"key\", the operator is \"In\", and the values array contains only \"value\". The requirements are ANDed.",
                                  "type": "object"
                                }
                              }
                            },
                            "namespaces": {
                              "description": "namespaces specifies which namespaces the labelSelector applies to (matches against); null or empty list means \"this pod's namespace\"",
                              "items": {
                                "type": "string"
                              },
                              "type": "array"
                            },
                            "topologyKey": {
                              "description": "This pod should be co-located (affinity) or not co-located (anti-affinity) with the pods matching the labelSelector in the specified namespaces, where co-located is defined as running on a node whose value of the label with key topologyKey matches that of any node on which any of the selected pods is running. Empty topologyKey is not allowed.",
                              "type": "string"
                            }
                          },
                          "required": [
                            "topologyKey"
                          ]
                        },
                        "type": "array"
                      }
                    }
                  },
                  "podAntiAffinity": {
                    "description": "Pod anti affinity is a group of inter pod anti affinity scheduling rules.",
                    "properties": {
                      "preferredDuringSchedulingIgnoredDuringExecution": {
                        "description": "The scheduler will prefer to schedule pods to nodes that satisfy the anti-affinity expressions specified by this field, but it may choose a node that violates one or more of the expressions. The node that is most preferred is the one with the greatest sum of weights, i.e. for each node that meets all of the scheduling requirements (resource request, requiredDuringScheduling anti-affinity expressions, etc.), compute a sum by iterating through the elements of this field and adding \"weight\" to the sum if the node has pods which matches the corresponding podAffinityTerm; the node(s) with the highest sum are the most preferred.",
                        "items": {
                          "description": "The weights of all of the matched WeightedPodAffinityTerm fields are added per-node to find the most preferred node(s)",
                          "properties": {
                            "podAffinityTerm": {
                              "description": "Defines a set of pods (namely those matching the labelSelector relative to the given namespace(s)) that this pod should be co-located (affinity) or not co-located (anti-affinity) with, where co-located is defined as running on a node whose value of the label with key <topologyKey> matches that of any node on which a pod of the set of pods is running",
                              "properties": {
                                "labelSelector": {
                                  "description": "A label selector is a label query over a set of resources. The result of matchLabels and matchExpressions are ANDed. An empty label selector matches all objects. A null label selector matches no objects.",
                                  "properties": {
                                    "matchExpressions": {
                                      "description": "matchExpressions is a list of label selector requirements. The requirements are ANDed.",
                                      "items": {
                                        "description": "A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.",
                                        "properties": {
                                          "key": {
                                            "description": "key is the label key that the selector applies to.",
                                            "type": "string"
                                          },
                                          "operator": {
                                            "description": "operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.",
                                            "type": "string"
                                          },
                                          "values": {
                                            "description": "values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.",
                                            "items": {
                                              "type": "string"
                                            },
                                            "type": "array"
                                          }
                                        },
                                        "required": [
                                          "key",
                                          "operator"
                                        ]
                                      },
                                      "type": "array"
                                    },
                                    "matchLabels": {
                                      "description": "matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is \"key\", the operator is \"In\", and the values array contains only \"value\". The requirements are ANDed.",
                                      "type": "object"
                                    }
                                  }
                                },
                                "namespaces": {
                                  "description": "namespaces specifies which namespaces the labelSelector applies to (matches against); null or empty list means \"this pod's namespace\"",
                                  "items": {
                                    "type": "string"
                                  },
                                  "type": "array"
                                },
                                "topologyKey": {
                                  "description": "This pod should be co-located (affinity) or not co-located (anti-affinity) with the pods matching the labelSelector in the specified namespaces, where co-located is defined as running on a node whose value of the label with key topologyKey matches that of any node on which any of the selected pods is running. Empty topologyKey is not allowed.",
                                  "type": "string"
                                }
                              },
                              "required": [
                                "topologyKey"
                              ]
                            },
                            "weight": {
                              "description": "weight associated with matching the corresponding podAffinityTerm, in the range 1-100.",
                              "format": "int32",
                              "type": "integer"
                            }
                          },
                          "required": [
                            "weight",
                            "podAffinityTerm"
                          ]
                        },
                        "type": "array"
                      },
                      "requiredDuringSchedulingIgnoredDuringExecution": {
                        "description": "If the anti-affinity requirements specified by this field are not met at scheduling time, the pod will not be scheduled onto the node. If the anti-affinity requirements specified by this field cease to be met at some point during pod execution (e.g. due to a pod label update), the system may or may not try to eventually evict the pod from its node. When there are multiple elements, the lists of nodes corresponding to each podAffinityTerm are intersected, i.e. all terms must be satisfied.",
                        "items": {
                          "description": "Defines a set of pods (namely those matching the labelSelector relative to the given namespace(s)) that this pod should be co-located (affinity) or not co-located (anti-affinity) with, where co-located is defined as running on a node whose value of the label with key <topologyKey> matches that of any node on which a pod of the set of pods is running",
                          "properties": {
                            "labelSelector": {
                              "description": "A label selector is a label query over a set of resources. The result of matchLabels and matchExpressions are ANDed. An empty label selector matches all objects. A null label selector matches no objects.",
                              "properties": {
                                "matchExpressions": {
                                  "description": "matchExpressions is a list of label selector requirements. The requirements are ANDed.",
                                  "items": {
                                    "description": "A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.",
                                    "properties": {
                                      "key": {
                                        "description": "key is the label key that the selector applies to.",
                                        "type": "string"
                                      },
                                      "operator": {
                                        "description": "operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.",
                                        "type": "string"
                                      },
                                      "values": {
                                        "description": "values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.",
                                        "items": {
                                          "type": "string"
                                        },
                                        "type": "array"
                                      }
                                    },
                                    "required": [
                                      "key",
                                      "operator"
                                    ]
                                  },
                                  "type": "array"
                                },
                                "matchLabels": {
                                  "description": "matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is \"key\", the operator is \"In\", and the values array contains only \"value\". The requirements are ANDed.",
                                  "type": "object"
                                }
                              }
                            },
                            "namespaces": {
                              "description": "namespaces specifies which namespaces the labelSelector applies to (matches against); null or empty list means \"this pod's namespace\"",
                              "items": {
                                "type": "string"
                              },
                              "type": "array"
                            },
                            "topologyKey": {
                              "description": "This pod should be co-located (affinity) or not co-located (anti-affinity) with the pods matching the labelSelector in the specified namespaces, where co-located is defined as running on a node whose value of the label with key topologyKey matches that of any node on which any of the selected pods is running. Empty topologyKey is not allowed.",
                              "type": "string"
                            }
                          },
                          "required": [
                            "topologyKey"
                          ]
                        },
                        "type": "array"
                      }
                    }
                  }
                }
              },
              "baseImage": {
                "description": "Base image that is used to deploy pods, without tag.",
                "type": "string"
              },
              "configMaps": {
                "description": "ConfigMaps is a list of ConfigMaps in the same namespace as the Alertmanager object, which shall be mounted into the Alertmanager Pods. The ConfigMaps are mounted into /etc/alertmanager/configmaps/<configmap-name>.",
                "items": {
                  "type": "string"
                },
                "type": "array"
              },
              "containers": {
                "description": "Containers allows injecting additional containers. This is meant to allow adding an authentication proxy to an Alertmanager pod.",
                "items": {
                  "description": "A single application container that you want to run within a pod.",
                  "properties": {
                    "args": {
                      "description": "Arguments to the entrypoint. The docker image's CMD is used if this is not provided. Variable references $(VAR_NAME) are expanded using the container's environment. If a variable cannot be resolved, the reference in the input string will be unchanged. The $(VAR_NAME) syntax can be escaped with a double $$, ie: $$(VAR_NAME). Escaped references will never be expanded, regardless of whether the variable exists or not. Cannot be updated. More info: https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell",
                      "items": {
                        "type": "string"
                      },
                      "type": "array"
                    },
                    "command": {
                      "description": "Entrypoint array. Not executed within a shell. The docker image's ENTRYPOINT is used if this is not provided. Variable references $(VAR_NAME) are expanded using the container's environment. If a variable cannot be resolved, the reference in the input string will be unchanged. The $(VAR_NAME) syntax can be escaped with a double $$, ie: $$(VAR_NAME). Escaped references will never be expanded, regardless of whether the variable exists or not. Cannot be updated. More info: https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell",
                      "items": {
                        "type": "string"
                      },
                      "type": "array"
                    },
                    "env": {
                      "description": "List of environment variables to set in the container. Cannot be updated.",
                      "items": {
                        "description": "EnvVar represents an environment variable present in a Container.",
                        "properties": {
                          "name": {
                            "description": "Name of the environment variable. Must be a C_IDENTIFIER.",
                            "type": "string"
                          },
                          "value": {
                            "description": "Variable references $(VAR_NAME) are expanded using the previous defined environment variables in the container and any service environment variables. If a variable cannot be resolved, the reference in the input string will be unchanged. The $(VAR_NAME) syntax can be escaped with a double $$, ie: $$(VAR_NAME). Escaped references will never be expanded, regardless of whether the variable exists or not. Defaults to \"\".",
                            "type": "string"
                          },
                          "valueFrom": {
                            "description": "EnvVarSource represents a source for the value of an EnvVar.",
                            "properties": {
                              "configMapKeyRef": {
                                "description": "Selects a key from a ConfigMap.",
                                "properties": {
                                  "key": {
                                    "description": "The key to select.",
                                    "type": "string"
                                  },
                                  "name": {
                                    "description": "Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names",
                                    "type": "string"
                                  },
                                  "optional": {
                                    "description": "Specify whether the ConfigMap or it's key must be defined",
                                    "type": "boolean"
                                  }
                                },
                                "required": [
                                  "key"
                                ]
                              },
                              "fieldRef": {
                                "description": "ObjectFieldSelector selects an APIVersioned field of an object.",
                                "properties": {
                                  "apiVersion": {
                                    "description": "Version of the schema the FieldPath is written in terms of, defaults to \"v1\".",
                                    "type": "string"
                                  },
                                  "fieldPath": {
                                    "description": "Path of the field to select in the specified API version.",
                                    "type": "string"
                                  }
                                },
                                "required": [
                                  "fieldPath"
                                ]
                              },
                              "resourceFieldRef": {
                                "description": "ResourceFieldSelector represents container resources (cpu, memory) and their output format",
                                "properties": {
                                  "containerName": {
                                    "description": "Container name: required for volumes, optional for env vars",
                                    "type": "string"
                                  },
                                  "divisor": {},
                                  "resource": {
                                    "description": "Required: resource to select",
                                    "type": "string"
                                  }
                                },
                                "required": [
                                  "resource"
                                ]
                              },
                              "secretKeyRef": {
                                "description": "SecretKeySelector selects a key of a Secret.",
                                "properties": {
                                  "key": {
                                    "description": "The key of the secret to select from.  Must be a valid secret key.",
                                    "type": "string"
                                  },
                                  "name": {
                                    "description": "Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names",
                                    "type": "string"
                                  },
                                  "optional": {
                                    "description": "Specify whether the Secret or it's key must be defined",
                                    "type": "boolean"
                                  }
                                },
                                "required": [
                                  "key"
                                ]
                              }
                            }
                          }
                        },
                        "required": [
                          "name"
                        ]
                      },
                      "type": "array"
                    },
                    "envFrom": {
                      "description": "List of sources to populate environment variables in the container. The keys defined within a source must be a C_IDENTIFIER. All invalid keys will be reported as an event when the container is starting. When a key exists in multiple sources, the value associated with the last source will take precedence. Values defined by an Env with a duplicate key will take precedence. Cannot be updated.",
                      "items": {
                        "description": "EnvFromSource represents the source of a set of ConfigMaps",
                        "properties": {
                          "configMapRef": {
                            "description": "ConfigMapEnvSource selects a ConfigMap to populate the environment variables with.\n\nThe contents of the target ConfigMap's Data field will represent the key-value pairs as environment variables.",
                            "properties": {
                              "name": {
                                "description": "Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names",
                                "type": "string"
                              },
                              "optional": {
                                "description": "Specify whether the ConfigMap must be defined",
                                "type": "boolean"
                              }
                            }
                          },
                          "prefix": {
                            "description": "An optional identifier to prepend to each key in the ConfigMap. Must be a C_IDENTIFIER.",
                            "type": "string"
                          },
                          "secretRef": {
                            "description": "SecretEnvSource selects a Secret to populate the environment variables with.\n\nThe contents of the target Secret's Data field will represent the key-value pairs as environment variables.",
                            "properties": {
                              "name": {
                                "description": "Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names",
                                "type": "string"
                              },
                              "optional": {
                                "description": "Specify whether the Secret must be defined",
                                "type": "boolean"
                              }
                            }
                          }
                        }
                      },
                      "type": "array"
                    },
                    "image": {
                      "description": "Docker image name. More info: https://kubernetes.io/docs/concepts/containers/images This field is optional to allow higher level config management to default or override container images in workload controllers like Deployments and StatefulSets.",
                      "type": "string"
                    },
                    "imagePullPolicy": {
                      "description": "Image pull policy. One of Always, Never, IfNotPresent. Defaults to Always if :latest tag is specified, or IfNotPresent otherwise. Cannot be updated. More info: https://kubernetes.io/docs/concepts/containers/images#updating-images",
                      "type": "string"
                    },
                    "lifecycle": {
                      "description": "Lifecycle describes actions that the management system should take in response to container lifecycle events. For the PostStart and PreStop lifecycle handlers, management of the container blocks until the action is complete, unless the container process fails, in which case the handler is aborted.",
                      "properties": {
                        "postStart": {
                          "description": "Handler defines a specific action that should be taken",
                          "properties": {
                            "exec": {
                              "description": "ExecAction describes a \"run in container\" action.",
                              "properties": {
                                "command": {
                                  "description": "Command is the command line to execute inside the container, the working directory for the command  is root ('/') in the container's filesystem. The command is simply exec'd, it is not run inside a shell, so traditional shell instructions ('|', etc) won't work. To use a shell, you need to explicitly call out to that shell. Exit status of 0 is treated as live/healthy and non-zero is unhealthy.",
                                  "items": {
                                    "type": "string"
                                  },
                                  "type": "array"
                                }
                              }
                            },
                            "httpGet": {
                              "description": "HTTPGetAction describes an action based on HTTP Get requests.",
                              "properties": {
                                "host": {
                                  "description": "Host name to connect to, defaults to the pod IP. You probably want to set \"Host\" in httpHeaders instead.",
                                  "type": "string"
                                },
                                "httpHeaders": {
                                  "description": "Custom headers to set in the request. HTTP allows repeated headers.",
                                  "items": {
                                    "description": "HTTPHeader describes a custom header to be used in HTTP probes",
                                    "properties": {
                                      "name": {
                                        "description": "The header field name",
                                        "type": "string"
                                      },
                                      "value": {
                                        "description": "The header field value",
                                        "type": "string"
                                      }
                                    },
                                    "required": [
                                      "name",
                                      "value"
                                    ]
                                  },
                                  "type": "array"
                                },
                                "path": {
                                  "description": "Path to access on the HTTP server.",
                                  "type": "string"
                                },
                                "port": {
                                  "anyOf": [
                                    {
                                      "type": "string"
                                    },
                                    {
                                      "type": "integer"
                                    }
                                  ]
                                },
                                "scheme": {
                                  "description": "Scheme to use for connecting to the host. Defaults to HTTP.",
                                  "type": "string"
                                }
                              },
                              "required": [
                                "port"
                              ]
                            },
                            "tcpSocket": {
                              "description": "TCPSocketAction describes an action based on opening a socket",
                              "properties": {
                                "host": {
                                  "description": "Optional: Host name to connect to, defaults to the pod IP.",
                                  "type": "string"
                                },
                                "port": {
                                  "anyOf": [
                                    {
                                      "type": "string"
                                    },
                                    {
                                      "type": "integer"
                                    }
                                  ]
                                }
                              },
                              "required": [
                                "port"
                              ]
                            }
                          }
                        },
                        "preStop": {
                          "description": "Handler defines a specific action that should be taken",
                          "properties": {
                            "exec": {
                              "description": "ExecAction describes a \"run in container\" action.",
                              "properties": {
                                "command": {
                                  "description": "Command is the command line to execute inside the container, the working directory for the command  is root ('/') in the container's filesystem. The command is simply exec'd, it is not run inside a shell, so traditional shell instructions ('|', etc) won't work. To use a shell, you need to explicitly call out to that shell. Exit status of 0 is treated as live/healthy and non-zero is unhealthy.",
                                  "items": {
                                    "type": "string"
                                  },
                                  "type": "array"
                                }
                              }
                            },
                            "httpGet": {
                              "description": "HTTPGetAction describes an action based on HTTP Get requests.",
                              "properties": {
                                "host": {
                                  "description": "Host name to connect to, defaults to the pod IP. You probably want to set \"Host\" in httpHeaders instead.",
                                  "type": "string"
                                },
                                "httpHeaders": {
                                  "description": "Custom headers to set in the request. HTTP allows repeated headers.",
                                  "items": {
                                    "description": "HTTPHeader describes a custom header to be used in HTTP probes",
                                    "properties": {
                                      "name": {
                                        "description": "The header field name",
                                        "type": "string"
                                      },
                                      "value": {
                                        "description": "The header field value",
                                        "type": "string"
                                      }
                                    },
                                    "required": [
                                      "name",
                                      "value"
                                    ]
                                  },
                                  "type": "array"
                                },
                                "path": {
                                  "description": "Path to access on the HTTP server.",
                                  "type": "string"
                                },
                                "port": {
                                  "anyOf": [
                                    {
                                      "type": "string"
                                    },
                                    {
                                      "type": "integer"
                                    }
                                  ]
                                },
                                "scheme": {
                                  "description": "Scheme to use for connecting to the host. Defaults to HTTP.",
                                  "type": "string"
                                }
                              },
                              "required": [
                                "port"
                              ]
                            },
                            "tcpSocket": {
                              "description": "TCPSocketAction describes an action based on opening a socket",
                              "properties": {
                                "host": {
                                  "description": "Optional: Host name to connect to, defaults to the pod IP.",
                                  "type": "string"
                                },
                                "port": {
                                  "anyOf": [
                                    {
                                      "type": "string"
                                    },
                                    {
                                      "type": "integer"
                                    }
                                  ]
                                }
                              },
                              "required": [
                                "port"
                              ]
                            }
                          }
                        }
                      }
                    },
                    "livenessProbe": {
                      "description": "Probe describes a health check to be performed against a container to determine whether it is alive or ready to receive traffic.",
                      "properties": {
                        "exec": {
                          "description": "ExecAction describes a \"run in container\" action.",
                          "properties": {
                            "command": {
                              "description": "Command is the command line to execute inside the container, the working directory for the command  is root ('/') in the container's filesystem. The command is simply exec'd, it is not run inside a shell, so traditional shell instructions ('|', etc) won't work. To use a shell, you need to explicitly call out to that shell. Exit status of 0 is treated as live/healthy and non-zero is unhealthy.",
                              "items": {
                                "type": "string"
                              },
                              "type": "array"
                            }
                          }
                        },
                        "failureThreshold": {
                          "description": "Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1.",
                          "format": "int32",
                          "type": "integer"
                        },
                        "httpGet": {
                          "description": "HTTPGetAction describes an action based on HTTP Get requests.",
                          "properties": {
                            "host": {
                              "description": "Host name to connect to, defaults to the pod IP. You probably want to set \"Host\" in httpHeaders instead.",
                              "type": "string"
                            },
                            "httpHeaders": {
                              "description": "Custom headers to set in the request. HTTP allows repeated headers.",
                              "items": {
                                "description": "HTTPHeader describes a custom header to be used in HTTP probes",
                                "properties": {
                                  "name": {
                                    "description": "The header field name",
                                    "type": "string"
                                  },
                                  "value": {
                                    "description": "The header field value",
                                    "type": "string"
                                  }
                                },
                                "required": [
                                  "name",
                                  "value"
                                ]
                              },
                              "type": "array"
                            },
                            "path": {
                              "description": "Path to access on the HTTP server.",
                              "type": "string"
                            },
                            "port": {
                              "anyOf": [
                                {
                                  "type": "string"
                                },
                                {
                                  "type": "integer"
                                }
                              ]
                            },
                            "scheme": {
                              "description": "Scheme to use for connecting to the host. Defaults to HTTP.",
                              "type": "string"
                            }
                          },
                          "required": [
                            "port"
                          ]
                        },
                        "initialDelaySeconds": {
                          "description": "Number of seconds after the container has started before liveness probes are initiated. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes",
                          "format": "int32",
                          "type": "integer"
                        },
                        "periodSeconds": {
                          "description": "How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1.",
                          "format": "int32",
                          "type": "integer"
                        },
                        "successThreshold": {
                          "description": "Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness. Minimum value is 1.",
                          "format": "int32",
                          "type": "integer"
                        },
                        "tcpSocket": {
                          "description": "TCPSocketAction describes an action based on opening a socket",
                          "properties": {
                            "host": {
                              "description": "Optional: Host name to connect to, defaults to the pod IP.",
                              "type": "string"
                            },
                            "port": {
                              "anyOf": [
                                {
                                  "type": "string"
                                },
                                {
                                  "type": "integer"
                                }
                              ]
                            }
                          },
                          "required": [
                            "port"
                          ]
                        },
                        "timeoutSeconds": {
                          "description": "Number of seconds after which the probe times out. Defaults to 1 second. Minimum value is 1. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes",
                          "format": "int32",
                          "type": "integer"
                        }
                      }
                    },
                    "name": {
                      "description": "Name of the container specified as a DNS_LABEL. Each container in a pod must have a unique name (DNS_LABEL). Cannot be updated.",
                      "type": "string"
                    },
                    "ports": {
                      "description": "List of ports to expose from the container. Exposing a port here gives the system additional information about the network connections a container uses, but is primarily informational. Not specifying a port here DOES NOT prevent that port from being exposed. Any port which is listening on the default \"0.0.0.0\" address inside a container will be accessible from the network. Cannot be updated.",
                      "items": {
                        "description": "ContainerPort represents a network port in a single container.",
                        "properties": {
                          "containerPort": {
                            "description": "Number of port to expose on the pod's IP address. This must be a valid port number, 0 < x < 65536.",
                            "format": "int32",
                            "type": "integer"
                          },
                          "hostIP": {
                            "description": "What host IP to bind the external port to.",
                            "type": "string"
                          },
                          "hostPort": {
                            "description": "Number of port to expose on the host. If specified, this must be a valid port number, 0 < x < 65536. If HostNetwork is specified, this must match ContainerPort. Most containers do not need this.",
                            "format": "int32",
                            "type": "integer"
                          },
                          "name": {
                            "description": "If specified, this must be an IANA_SVC_NAME and unique within the pod. Each named port in a pod must have a unique name. Name for the port that can be referred to by services.",
                            "type": "string"
                          },
                          "protocol": {
                            "description": "Protocol for port. Must be UDP, TCP, or SCTP. Defaults to \"TCP\".",
                            "type": "string"
                          }
                        },
                        "required": [
                          "containerPort"
                        ]
                      },
                      "type": "array"
                    },
                    "readinessProbe": {
                      "description": "Probe describes a health check to be performed against a container to determine whether it is alive or ready to receive traffic.",
                      "properties": {
                        "exec": {
                          "description": "ExecAction describes a \"run in container\" action.",
                          "properties": {
                            "command": {
                              "description": "Command is the command line to execute inside the container, the working directory for the command  is root ('/') in the container's filesystem. The command is simply exec'd, it is not run inside a shell, so traditional shell instructions ('|', etc) won't work. To use a shell, you need to explicitly call out to that shell. Exit status of 0 is treated as live/healthy and non-zero is unhealthy.",
                              "items": {
                                "type": "string"
                              },
                              "type": "array"
                            }
                          }
                        },
                        "failureThreshold": {
                          "description": "Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1.",
                          "format": "int32",
                          "type": "integer"
                        },
                        "httpGet": {
                          "description": "HTTPGetAction describes an action based on HTTP Get requests.",
                          "properties": {
                            "host": {
                              "description": "Host name to connect to, defaults to the pod IP. You probably want to set \"Host\" in httpHeaders instead.",
                              "type": "string"
                            },
                            "httpHeaders": {
                              "description": "Custom headers to set in the request. HTTP allows repeated headers.",
                              "items": {
                                "description": "HTTPHeader describes a custom header to be used in HTTP probes",
                                "properties": {
                                  "name": {
                                    "description": "The header field name",
                                    "type": "string"
                                  },
                                  "value": {
                                    "description": "The header field value",
                                    "type": "string"
                                  }
                                },
                                "required": [
                                  "name",
                                  "value"
                                ]
                              },
                              "type": "array"
                            },
                            "path": {
                              "description": "Path to access on the HTTP server.",
                              "type": "string"
                            },
                            "port": {
                              "anyOf": [
                                {
                                  "type": "string"
                                },
                                {
                                  "type": "integer"
                                }
                              ]
                            },
                            "scheme": {
                              "description": "Scheme to use for connecting to the host. Defaults to HTTP.",
                              "type": "string"
                            }
                          },
                          "required": [
                            "port"
                          ]
                        },
                        "initialDelaySeconds": {
                          "description": "Number of seconds after the container has started before liveness probes are initiated. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes",
                          "format": "int32",
                          "type": "integer"
                        },
                        "periodSeconds": {
                          "description": "How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1.",
                          "format": "int32",
                          "type": "integer"
                        },
                        "successThreshold": {
                          "description": "Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness. Minimum value is 1.",
                          "format": "int32",
                          "type": "integer"
                        },
                        "tcpSocket": {
                          "description": "TCPSocketAction describes an action based on opening a socket",
                          "properties": {
                            "host": {
                              "description": "Optional: Host name to connect to, defaults to the pod IP.",
                              "type": "string"
                            },
                            "port": {
                              "anyOf": [
                                {
                                  "type": "string"
                                },
                                {
                                  "type": "integer"
                                }
                              ]
                            }
                          },
                          "required": [
                            "port"
                          ]
                        },
                        "timeoutSeconds": {
                          "description": "Number of seconds after which the probe times out. Defaults to 1 second. Minimum value is 1. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes",
                          "format": "int32",
                          "type": "integer"
                        }
                      }
                    },
                    "resources": {
                      "description": "ResourceRequirements describes the compute resource requirements.",
                      "properties": {
                        "limits": {
                          "description": "Limits describes the maximum amount of compute resources allowed. More info: https://kubernetes.io/docs/concepts/configuration/manage-compute-resources-container/",
                          "type": "object"
                        },
                        "requests": {
                          "description": "Requests describes the minimum amount of compute resources required. If Requests is omitted for a container, it defaults to Limits if that is explicitly specified, otherwise to an implementation-defined value. More info: https://kubernetes.io/docs/concepts/configuration/manage-compute-resources-container/",
                          "type": "object"
                        }
                      }
                    },
                    "securityContext": {
                      "description": "SecurityContext holds security configuration that will be applied to a container. Some fields are present in both SecurityContext and PodSecurityContext.  When both are set, the values in SecurityContext take precedence.",
                      "properties": {
                        "allowPrivilegeEscalation": {
                          "description": "AllowPrivilegeEscalation controls whether a process can gain more privileges than its parent process. This bool directly controls if the no_new_privs flag will be set on the container process. AllowPrivilegeEscalation is true always when the container is: 1) run as Privileged 2) has CAP_SYS_ADMIN",
                          "type": "boolean"
                        },
                        "capabilities": {
                          "description": "Adds and removes POSIX capabilities from running containers.",
                          "properties": {
                            "add": {
                              "description": "Added capabilities",
                              "items": {
                                "type": "string"
                              },
                              "type": "array"
                            },
                            "drop": {
                              "description": "Removed capabilities",
                              "items": {
                                "type": "string"
                              },
                              "type": "array"
                            }
                          }
                        },
                        "privileged": {
                          "description": "Run container in privileged mode. Processes in privileged containers are essentially equivalent to root on the host. Defaults to false.",
                          "type": "boolean"
                        },
                        "procMount": {
                          "description": "procMount denotes the type of proc mount to use for the containers. The default is DefaultProcMount which uses the container runtime defaults for readonly paths and masked paths. This requires the ProcMountType feature flag to be enabled.",
                          "type": "string"
                        },
                        "readOnlyRootFilesystem": {
                          "description": "Whether this container has a read-only root filesystem. Default is false.",
                          "type": "boolean"
                        },
                        "runAsGroup": {
                          "description": "The GID to run the entrypoint of the container process. Uses runtime default if unset. May also be set in PodSecurityContext.  If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.",
                          "format": "int64",
                          "type": "integer"
                        },
                        "runAsNonRoot": {
                          "description": "Indicates that the container must run as a non-root user. If true, the Kubelet will validate the image at runtime to ensure that it does not run as UID 0 (root) and fail to start the container if it does. If unset or false, no such validation will be performed. May also be set in PodSecurityContext.  If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.",
                          "type": "boolean"
                        },
                        "runAsUser": {
                          "description": "The UID to run the entrypoint of the container process. Defaults to user specified in image metadata if unspecified. May also be set in PodSecurityContext.  If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.",
                          "format": "int64",
                          "type": "integer"
                        },
                        "seLinuxOptions": {
                          "description": "SELinuxOptions are the labels to be applied to the container",
                          "properties": {
                            "level": {
                              "description": "Level is SELinux level label that applies to the container.",
                              "type": "string"
                            },
                            "role": {
                              "description": "Role is a SELinux role label that applies to the container.",
                              "type": "string"
                            },
                            "type": {
                              "description": "Type is a SELinux type label that applies to the container.",
                              "type": "string"
                            },
                            "user": {
                              "description": "User is a SELinux user label that applies to the container.",
                              "type": "string"
                            }
                          }
                        }
                      }
                    },
                    "stdin": {
                      "description": "Whether this container should allocate a buffer for stdin in the container runtime. If this is not set, reads from stdin in the container will always result in EOF. Default is false.",
                      "type": "boolean"
                    },
                    "stdinOnce": {
                      "description": "Whether the container runtime should close the stdin channel after it has been opened by a single attach. When stdin is true the stdin stream will remain open across multiple attach sessions. If stdinOnce is set to true, stdin is opened on container start, is empty until the first client attaches to stdin, and then remains open and accepts data until the client disconnects, at which time stdin is closed and remains closed until the container is restarted. If this flag is false, a container processes that reads from stdin will never receive an EOF. Default is false",
                      "type": "boolean"
                    },
                    "terminationMessagePath": {
                      "description": "Optional: Path at which the file to which the container's termination message will be written is mounted into the container's filesystem. Message written is intended to be brief final status, such as an assertion failure message. Will be truncated by the node if greater than 4096 bytes. The total message length across all containers will be limited to 12kb. Defaults to /dev/termination-log. Cannot be updated.",
                      "type": "string"
                    },
                    "terminationMessagePolicy": {
                      "description": "Indicate how the termination message should be populated. File will use the contents of terminationMessagePath to populate the container status message on both success and failure. FallbackToLogsOnError will use the last chunk of container log output if the termination message file is empty and the container exited with an error. The log output is limited to 2048 bytes or 80 lines, whichever is smaller. Defaults to File. Cannot be updated.",
                      "type": "string"
                    },
                    "tty": {
                      "description": "Whether this container should allocate a TTY for itself, also requires 'stdin' to be true. Default is false.",
                      "type": "boolean"
                    },
                    "volumeDevices": {
                      "description": "volumeDevices is the list of block devices to be used by the container. This is an alpha feature and may change in the future.",
                      "items": {
                        "description": "volumeDevice describes a mapping of a raw block device within a container.",
                        "properties": {
                          "devicePath": {
                            "description": "devicePath is the path inside of the container that the device will be mapped to.",
                            "type": "string"
                          },
                          "name": {
                            "description": "name must match the name of a persistentVolumeClaim in the pod",
                            "type": "string"
                          }
                        },
                        "required": [
                          "name",
                          "devicePath"
                        ]
                      },
                      "type": "array"
                    },
                    "volumeMounts": {
                      "description": "Pod volumes to mount into the container's filesystem. Cannot be updated.",
                      "items": {
                        "description": "VolumeMount describes a mounting of a Volume within a container.",
                        "properties": {
                          "mountPath": {
                            "description": "Path within the container at which the volume should be mounted.  Must not contain ':'.",
                            "type": "string"
                          },
                          "mountPropagation": {
                            "description": "mountPropagation determines how mounts are propagated from the host to container and the other way around. When not set, MountPropagationNone is used. This field is beta in 1.10.",
                            "type": "string"
                          },
                          "name": {
                            "description": "This must match the Name of a Volume.",
                            "type": "string"
                          },
                          "readOnly": {
                            "description": "Mounted read-only if true, read-write otherwise (false or unspecified). Defaults to false.",
                            "type": "boolean"
                          },
                          "subPath": {
                            "description": "Path within the volume from which the container's volume should be mounted. Defaults to \"\" (volume's root).",
                            "type": "string"
                          }
                        },
                        "required": [
                          "name",
                          "mountPath"
                        ]
                      },
                      "type": "array"
                    },
                    "workingDir": {
                      "description": "Container's working directory. If not specified, the container runtime's default will be used, which might be configured in the container image. Cannot be updated.",
                      "type": "string"
                    }
                  },
                  "required": [
                    "name"
                  ]
                },
                "type": "array"
              },
              "externalUrl": {
                "description": "The external URL the Alertmanager instances will be available under. This is necessary to generate correct URLs. This is necessary if Alertmanager is not served from root of a DNS name.",
                "type": "string"
              },
              "image": {
                "description": "Image if specified has precedence over baseImage, tag and sha combinations. Specifying the version is still necessary to ensure the Prometheus Operator knows what version of Alertmanager is being configured.",
                "type": "string"
              },
              "imagePullSecrets": {
                "description": "An optional list of references to secrets in the same namespace to use for pulling prometheus and alertmanager images from registries see http://kubernetes.io/docs/user-guide/images#specifying-imagepullsecrets-on-a-pod",
                "items": {
                  "description": "LocalObjectReference contains enough information to let you locate the referenced object inside the same namespace.",
                  "properties": {
                    "name": {
                      "description": "Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names",
                      "type": "string"
                    }
                  }
                },
                "type": "array"
              },
              "listenLocal": {
                "description": "ListenLocal makes the Alertmanager server listen on loopback, so that it does not bind against the Pod IP. Note this is only for the Alertmanager UI, not the gossip communication.",
                "type": "boolean"
              },
              "logLevel": {
                "description": "Log level for Alertmanager to be configured with.",
                "type": "string"
              },
              "nodeSelector": {
                "description": "Define which Nodes the Pods are scheduled on.",
                "type": "object"
              },
              "paused": {
                "description": "If set to true all actions on the underlying managed objects are not goint to be performed, except for delete actions.",
                "type": "boolean"
              },
              "podMetadata": {
                "description": "ObjectMeta is metadata that all persisted resources must have, which includes all objects users must create.",
                "properties": {
                  "annotations": {
                    "description": "Annotations is an unstructured key value map stored with a resource that may be set by external tools to store and retrieve arbitrary metadata. They are not queryable and should be preserved when modifying objects. More info: http://kubernetes.io/docs/user-guide/annotations",
                    "type": "object"
                  },
                  "clusterName": {
                    "description": "The name of the cluster which the object belongs to. This is used to distinguish resources with same name and namespace in different clusters. This field is not set anywhere right now and apiserver is going to ignore it if set in create or update request.",
                    "type": "string"
                  },
                  "creationTimestamp": {
                    "description": "Time is a wrapper around time.Time which supports correct marshaling to YAML and JSON.  Wrappers are provided for many of the factory methods that the time package offers.",
                    "format": "date-time",
                    "type": "string"
                  },
                  "deletionGracePeriodSeconds": {
                    "description": "Number of seconds allowed for this object to gracefully terminate before it will be removed from the system. Only set when deletionTimestamp is also set. May only be shortened. Read-only.",
                    "format": "int64",
                    "type": "integer"
                  },
                  "deletionTimestamp": {
                    "description": "Time is a wrapper around time.Time which supports correct marshaling to YAML and JSON.  Wrappers are provided for many of the factory methods that the time package offers.",
                    "format": "date-time",
                    "type": "string"
                  },
                  "finalizers": {
                    "description": "Must be empty before the object is deleted from the registry. Each entry is an identifier for the responsible component that will remove the entry from the list. If the deletionTimestamp of the object is non-nil, entries in this list can only be removed.",
                    "items": {
                      "type": "string"
                    },
                    "type": "array"
                  },
                  "generateName": {
                    "description": "GenerateName is an optional prefix, used by the server, to generate a unique name ONLY IF the Name field has not been provided. If this field is used, the name returned to the client will be different than the name passed. This value will also be combined with a unique suffix. The provided value has the same validation rules as the Name field, and may be truncated by the length of the suffix required to make the value unique on the server.\n\nIf this field is specified and the generated name exists, the server will NOT return a 409 - instead, it will either return 201 Created or 500 with Reason ServerTimeout indicating a unique name could not be found in the time allotted, and the client should retry (optionally after the time indicated in the Retry-After header).\n\nApplied only if Name is not specified. More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#idempotency",
                    "type": "string"
                  },
                  "generation": {
                    "description": "A sequence number representing a specific generation of the desired state. Populated by the system. Read-only.",
                    "format": "int64",
                    "type": "integer"
                  },
                  "initializers": {
                    "description": "Initializers tracks the progress of initialization.",
                    "properties": {
                      "pending": {
                        "description": "Pending is a list of initializers that must execute in order before this object is visible. When the last pending initializer is removed, and no failing result is set, the initializers struct will be set to nil and the object is considered as initialized and visible to all clients.",
                        "items": {
                          "description": "Initializer is information about an initializer that has not yet completed.",
                          "properties": {
                            "name": {
                              "description": "name of the process that is responsible for initializing this object.",
                              "type": "string"
                            }
                          },
                          "required": [
                            "name"
                          ]
                        },
                        "type": "array"
                      },
                      "result": {
                        "description": "Status is a return value for calls that don't return other objects.",
                        "properties": {
                          "apiVersion": {
                            "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#resources",
                            "type": "string"
                          },
                          "code": {
                            "description": "Suggested HTTP return code for this status, 0 if not set.",
                            "format": "int32",
                            "type": "integer"
                          },
                          "details": {
                            "description": "StatusDetails is a set of additional properties that MAY be set by the server to provide additional information about a response. The Reason field of a Status object defines what attributes will be set. Clients must ignore fields that do not match the defined type of each attribute, and should assume that any attribute may be empty, invalid, or under defined.",
                            "properties": {
                              "causes": {
                                "description": "The Causes array includes more details associated with the StatusReason failure. Not all StatusReasons may provide detailed causes.",
                                "items": {
                                  "description": "StatusCause provides more information about an api.Status failure, including cases when multiple errors are encountered.",
                                  "properties": {
                                    "field": {
                                      "description": "The field of the resource that has caused this error, as named by its JSON serialization. May include dot and postfix notation for nested attributes. Arrays are zero-indexed.  Fields may appear more than once in an array of causes due to fields having multiple errors. Optional.\n\nExamples:\n  \"name\" - the field \"name\" on the current resource\n  \"items[0].name\" - the field \"name\" on the first array entry in \"items\"",
                                      "type": "string"
                                    },
                                    "message": {
                                      "description": "A human-readable description of the cause of the error.  This field may be presented as-is to a reader.",
                                      "type": "string"
                                    },
                                    "reason": {
                                      "description": "A machine-readable description of the cause of the error. If this value is empty there is no information available.",
                                      "type": "string"
                                    }
                                  }
                                },
                                "type": "array"
                              },
                              "group": {
                                "description": "The group attribute of the resource associated with the status StatusReason.",
                                "type": "string"
                              },
                              "kind": {
                                "description": "The kind attribute of the resource associated with the status StatusReason. On some operations may differ from the requested resource Kind. More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#types-kinds",
                                "type": "string"
                              },
                              "name": {
                                "description": "The name attribute of the resource associated with the status StatusReason (when there is a single name which can be described).",
                                "type": "string"
                              },
                              "retryAfterSeconds": {
                                "description": "If specified, the time in seconds before the operation should be retried. Some errors may indicate the client must take an alternate action - for those errors this field may indicate how long to wait before taking the alternate action.",
                                "format": "int32",
                                "type": "integer"
                              },
                              "uid": {
                                "description": "UID of the resource. (when there is a single resource which can be described). More info: http://kubernetes.io/docs/user-guide/identifiers#uids",
                                "type": "string"
                              }
                            }
                          },
                          "kind": {
                            "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#types-kinds",
                            "type": "string"
                          },
                          "message": {
                            "description": "A human-readable description of the status of this operation.",
                            "type": "string"
                          },
                          "metadata": {
                            "description": "ListMeta describes metadata that synthetic resources must have, including lists and various status objects. A resource may have only one of {ObjectMeta, ListMeta}.",
                            "properties": {
                              "continue": {
                                "description": "continue may be set if the user set a limit on the number of items returned, and indicates that the server has more data available. The value is opaque and may be used to issue another request to the endpoint that served this list to retrieve the next set of available objects. Continuing a consistent list may not be possible if the server configuration has changed or more than a few minutes have passed. The resourceVersion field returned when using this continue value will be identical to the value in the first response, unless you have received this token from an error message.",
                                "type": "string"
                              },
                              "resourceVersion": {
                                "description": "String that identifies the server's internal version of this object that can be used by clients to determine when objects have changed. Value must be treated as opaque by clients and passed unmodified back to the server. Populated by the system. Read-only. More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#concurrency-control-and-consistency",
                                "type": "string"
                              },
                              "selfLink": {
                                "description": "selfLink is a URL representing this object. Populated by the system. Read-only.",
                                "type": "string"
                              }
                            }
                          },
                          "reason": {
                            "description": "A machine-readable description of why this operation is in the \"Failure\" status. If this value is empty there is no information available. A Reason clarifies an HTTP status code but does not override it.",
                            "type": "string"
                          },
                          "status": {
                            "description": "Status of the operation. One of: \"Success\" or \"Failure\". More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#spec-and-status",
                            "type": "string"
                          }
                        }
                      }
                    },
                    "required": [
                      "pending"
                    ]
                  },
                  "labels": {
                    "description": "Map of string keys and values that can be used to organize and categorize (scope and select) objects. May match selectors of replication controllers and services. More info: http://kubernetes.io/docs/user-guide/labels",
                    "type": "object"
                  },
                  "name": {
                    "description": "Name must be unique within a namespace. Is required when creating resources, although some resources may allow a client to request the generation of an appropriate name automatically. Name is primarily intended for creation idempotence and configuration definition. Cannot be updated. More info: http://kubernetes.io/docs/user-guide/identifiers#names",
                    "type": "string"
                  },
                  "namespace": {
                    "description": "Namespace defines the space within each name must be unique. An empty namespace is equivalent to the \"default\" namespace, but \"default\" is the canonical representation. Not all objects are required to be scoped to a namespace - the value of this field for those objects will be empty.\n\nMust be a DNS_LABEL. Cannot be updated. More info: http://kubernetes.io/docs/user-guide/namespaces",
                    "type": "string"
                  },
                  "ownerReferences": {
                    "description": "List of objects depended by this object. If ALL objects in the list have been deleted, this object will be garbage collected. If this object is managed by a controller, then an entry in this list will point to this controller, with the controller field set to true. There cannot be more than one managing controller.",
                    "items": {
                      "description": "OwnerReference contains enough information to let you identify an owning object. Currently, an owning object must be in the same namespace, so there is no namespace field.",
                      "properties": {
                        "apiVersion": {
                          "description": "API version of the referent.",
                          "type": "string"
                        },
                        "blockOwnerDeletion": {
                          "description": "If true, AND if the owner has the \"foregroundDeletion\" finalizer, then the owner cannot be deleted from the key-value store until this reference is removed. Defaults to false. To set this field, a user needs \"delete\" permission of the owner, otherwise 422 (Unprocessable Entity) will be returned.",
                          "type": "boolean"
                        },
                        "controller": {
                          "description": "If true, this reference points to the managing controller.",
                          "type": "boolean"
                        },
                        "kind": {
                          "description": "Kind of the referent. More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#types-kinds",
                          "type": "string"
                        },
                        "name": {
                          "description": "Name of the referent. More info: http://kubernetes.io/docs/user-guide/identifiers#names",
                          "type": "string"
                        },
                        "uid": {
                          "description": "UID of the referent. More info: http://kubernetes.io/docs/user-guide/identifiers#uids",
                          "type": "string"
                        }
                      },
                      "required": [
                        "apiVersion",
                        "kind",
                        "name",
                        "uid"
                      ]
                    },
                    "type": "array"
                  },
                  "resourceVersion": {
                    "description": "An opaque value that represents the internal version of this object that can be used by clients to determine when objects have changed. May be used for optimistic concurrency, change detection, and the watch operation on a resource or set of resources. Clients must treat these values as opaque and passed unmodified back to the server. They may only be valid for a particular resource or set of resources.\n\nPopulated by the system. Read-only. Value must be treated as opaque by clients and . More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#concurrency-control-and-consistency",
                    "type": "string"
                  },
                  "selfLink": {
                    "description": "SelfLink is a URL representing this object. Populated by the system. Read-only.",
                    "type": "string"
                  },
                  "uid": {
                    "description": "UID is the unique in time and space value for this object. It is typically generated by the server on successful creation of a resource and is not allowed to change on PUT operations.\n\nPopulated by the system. Read-only. More info: http://kubernetes.io/docs/user-guide/identifiers#uids",
                    "type": "string"
                  }
                }
              },
              "priorityClassName": {
                "description": "Priority class assigned to the Pods",
                "type": "string"
              },
              "replicas": {
                "description": "Size is the expected size of the alertmanager cluster. The controller will eventually make the size of the running cluster equal to the expected size.",
                "format": "int32",
                "type": "integer"
              },
              "resources": {
                "description": "ResourceRequirements describes the compute resource requirements.",
                "properties": {
                  "limits": {
                    "description": "Limits describes the maximum amount of compute resources allowed. More info: https://kubernetes.io/docs/concepts/configuration/manage-compute-resources-container/",
                    "type": "object"
                  },
                  "requests": {
                    "description": "Requests describes the minimum amount of compute resources required. If Requests is omitted for a container, it defaults to Limits if that is explicitly specified, otherwise to an implementation-defined value. More info: https://kubernetes.io/docs/concepts/configuration/manage-compute-resources-container/",
                    "type": "object"
                  }
                }
              },
              "retention": {
                "description": "Time duration Alertmanager shall retain data for. Default is '120h', and must match the regular expression `[0-9]+(ms|s|m|h)` (milliseconds seconds minutes hours).",
                "type": "string"
              },
              "routePrefix": {
                "description": "The route prefix Alertmanager registers HTTP handlers for. This is useful, if using ExternalURL and a proxy is rewriting HTTP routes of a request, and the actual ExternalURL is still true, but the server serves requests under a different route prefix. For example for use with `kubectl proxy`.",
                "type": "string"
              },
              "secrets": {
                "description": "Secrets is a list of Secrets in the same namespace as the Alertmanager object, which shall be mounted into the Alertmanager Pods. The Secrets are mounted into /etc/alertmanager/secrets/<secret-name>.",
                "items": {
                  "type": "string"
                },
                "type": "array"
              },
              "securityContext": {
                "description": "PodSecurityContext holds pod-level security attributes and common container settings. Some fields are also present in container.securityContext.  Field values of container.securityContext take precedence over field values of PodSecurityContext.",
                "properties": {
                  "fsGroup": {
                    "description": "A special supplemental group that applies to all containers in a pod. Some volume types allow the Kubelet to change the ownership of that volume to be owned by the pod:\n\n1. The owning GID will be the FSGroup 2. The setgid bit is set (new files created in the volume will be owned by FSGroup) 3. The permission bits are OR'd with rw-rw----\n\nIf unset, the Kubelet will not modify the ownership and permissions of any volume.",
                    "format": "int64",
                    "type": "integer"
                  },
                  "runAsGroup": {
                    "description": "The GID to run the entrypoint of the container process. Uses runtime default if unset. May also be set in SecurityContext.  If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence for that container.",
                    "format": "int64",
                    "type": "integer"
                  },
                  "runAsNonRoot": {
                    "description": "Indicates that the container must run as a non-root user. If true, the Kubelet will validate the image at runtime to ensure that it does not run as UID 0 (root) and fail to start the container if it does. If unset or false, no such validation will be performed. May also be set in SecurityContext.  If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.",
                    "type": "boolean"
                  },
                  "runAsUser": {
                    "description": "The UID to run the entrypoint of the container process. Defaults to user specified in image metadata if unspecified. May also be set in SecurityContext.  If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence for that container.",
                    "format": "int64",
                    "type": "integer"
                  },
                  "seLinuxOptions": {
                    "description": "SELinuxOptions are the labels to be applied to the container",
                    "properties": {
                      "level": {
                        "description": "Level is SELinux level label that applies to the container.",
                        "type": "string"
                      },
                      "role": {
                        "description": "Role is a SELinux role label that applies to the container.",
                        "type": "string"
                      },
                      "type": {
                        "description": "Type is a SELinux type label that applies to the container.",
                        "type": "string"
                      },
                      "user": {
                        "description": "User is a SELinux user label that applies to the container.",
                        "type": "string"
                      }
                    }
                  },
                  "supplementalGroups": {
                    "description": "A list of groups applied to the first process run in each container, in addition to the container's primary GID.  If unspecified, no groups will be added to any container.",
                    "items": {
                      "format": "int64",
                      "type": "integer"
                    },
                    "type": "array"
                  },
                  "sysctls": {
                    "description": "Sysctls hold a list of namespaced sysctls used for the pod. Pods with unsupported sysctls (by the container runtime) might fail to launch.",
                    "items": {
                      "description": "Sysctl defines a kernel parameter to be set",
                      "properties": {
                        "name": {
                          "description": "Name of a property to set",
                          "type": "string"
                        },
                        "value": {
                          "description": "Value of a property to set",
                          "type": "string"
                        }
                      },
                      "required": [
                        "name",
                        "value"
                      ]
                    },
                    "type": "array"
                  }
                }
              },
              "serviceAccountName": {
                "description": "ServiceAccountName is the name of the ServiceAccount to use to run the Prometheus Pods.",
                "type": "string"
              },
              "sha": {
                "description": "SHA of Alertmanager container image to be deployed. Defaults to the value of `version`. Similar to a tag, but the SHA explicitly deploys an immutable container image. Version and Tag are ignored if SHA is set.",
                "type": "string"
              },
              "storage": {
                "description": "StorageSpec defines the configured storage for a group Prometheus servers. If neither `emptyDir` nor `volumeClaimTemplate` is specified, then by default an [EmptyDir](https://kubernetes.io/docs/concepts/storage/volumes/#emptydir) will be used.",
                "properties": {
                  "emptyDir": {
                    "description": "Represents an empty directory for a pod. Empty directory volumes support ownership management and SELinux relabeling.",
                    "properties": {
                      "medium": {
                        "description": "What type of storage medium should back this directory. The default is \"\" which means to use the node's default medium. Must be an empty string (default) or Memory. More info: https://kubernetes.io/docs/concepts/storage/volumes#emptydir",
                        "type": "string"
                      },
                      "sizeLimit": {}
                    }
                  },
                  "volumeClaimTemplate": {
                    "description": "PersistentVolumeClaim is a user's request for and claim to a persistent volume",
                    "properties": {
                      "apiVersion": {
                        "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#resources",
                        "type": "string"
                      },
                      "kind": {
                        "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#types-kinds",
                        "type": "string"
                      },
                      "metadata": {
                        "description": "ObjectMeta is metadata that all persisted resources must have, which includes all objects users must create.",
                        "properties": {
                          "annotations": {
                            "description": "Annotations is an unstructured key value map stored with a resource that may be set by external tools to store and retrieve arbitrary metadata. They are not queryable and should be preserved when modifying objects. More info: http://kubernetes.io/docs/user-guide/annotations",
                            "type": "object"
                          },
                          "clusterName": {
                            "description": "The name of the cluster which the object belongs to. This is used to distinguish resources with same name and namespace in different clusters. This field is not set anywhere right now and apiserver is going to ignore it if set in create or update request.",
                            "type": "string"
                          },
                          "creationTimestamp": {
                            "description": "Time is a wrapper around time.Time which supports correct marshaling to YAML and JSON.  Wrappers are provided for many of the factory methods that the time package offers.",
                            "format": "date-time",
                            "type": "string"
                          },
                          "deletionGracePeriodSeconds": {
                            "description": "Number of seconds allowed for this object to gracefully terminate before it will be removed from the system. Only set when deletionTimestamp is also set. May only be shortened. Read-only.",
                            "format": "int64",
                            "type": "integer"
                          },
                          "deletionTimestamp": {
                            "description": "Time is a wrapper around time.Time which supports correct marshaling to YAML and JSON.  Wrappers are provided for many of the factory methods that the time package offers.",
                            "format": "date-time",
                            "type": "string"
                          },
                          "finalizers": {
                            "description": "Must be empty before the object is deleted from the registry. Each entry is an identifier for the responsible component that will remove the entry from the list. If the deletionTimestamp of the object is non-nil, entries in this list can only be removed.",
                            "items": {
                              "type": "string"
                            },
                            "type": "array"
                          },
                          "generateName": {
                            "description": "GenerateName is an optional prefix, used by the server, to generate a unique name ONLY IF the Name field has not been provided. If this field is used, the name returned to the client will be different than the name passed. This value will also be combined with a unique suffix. The provided value has the same validation rules as the Name field, and may be truncated by the length of the suffix required to make the value unique on the server.\n\nIf this field is specified and the generated name exists, the server will NOT return a 409 - instead, it will either return 201 Created or 500 with Reason ServerTimeout indicating a unique name could not be found in the time allotted, and the client should retry (optionally after the time indicated in the Retry-After header).\n\nApplied only if Name is not specified. More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#idempotency",
                            "type": "string"
                          },
                          "generation": {
                            "description": "A sequence number representing a specific generation of the desired state. Populated by the system. Read-only.",
                            "format": "int64",
                            "type": "integer"
                          },
                          "initializers": {
                            "description": "Initializers tracks the progress of initialization.",
                            "properties": {
                              "pending": {
                                "description": "Pending is a list of initializers that must execute in order before this object is visible. When the last pending initializer is removed, and no failing result is set, the initializers struct will be set to nil and the object is considered as initialized and visible to all clients.",
                                "items": {
                                  "description": "Initializer is information about an initializer that has not yet completed.",
                                  "properties": {
                                    "name": {
                                      "description": "name of the process that is responsible for initializing this object.",
                                      "type": "string"
                                    }
                                  },
                                  "required": [
                                    "name"
                                  ]
                                },
                                "type": "array"
                              },
                              "result": {
                                "description": "Status is a return value for calls that don't return other objects.",
                                "properties": {
                                  "apiVersion": {
                                    "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#resources",
                                    "type": "string"
                                  },
                                  "code": {
                                    "description": "Suggested HTTP return code for this status, 0 if not set.",
                                    "format": "int32",
                                    "type": "integer"
                                  },
                                  "details": {
                                    "description": "StatusDetails is a set of additional properties that MAY be set by the server to provide additional information about a response. The Reason field of a Status object defines what attributes will be set. Clients must ignore fields that do not match the defined type of each attribute, and should assume that any attribute may be empty, invalid, or under defined.",
                                    "properties": {
                                      "causes": {
                                        "description": "The Causes array includes more details associated with the StatusReason failure. Not all StatusReasons may provide detailed causes.",
                                        "items": {
                                          "description": "StatusCause provides more information about an api.Status failure, including cases when multiple errors are encountered.",
                                          "properties": {
                                            "field": {
                                              "description": "The field of the resource that has caused this error, as named by its JSON serialization. May include dot and postfix notation for nested attributes. Arrays are zero-indexed.  Fields may appear more than once in an array of causes due to fields having multiple errors. Optional.\n\nExamples:\n  \"name\" - the field \"name\" on the current resource\n  \"items[0].name\" - the field \"name\" on the first array entry in \"items\"",
                                              "type": "string"
                                            },
                                            "message": {
                                              "description": "A human-readable description of the cause of the error.  This field may be presented as-is to a reader.",
                                              "type": "string"
                                            },
                                            "reason": {
                                              "description": "A machine-readable description of the cause of the error. If this value is empty there is no information available.",
                                              "type": "string"
                                            }
                                          }
                                        },
                                        "type": "array"
                                      },
                                      "group": {
                                        "description": "The group attribute of the resource associated with the status StatusReason.",
                                        "type": "string"
                                      },
                                      "kind": {
                                        "description": "The kind attribute of the resource associated with the status StatusReason. On some operations may differ from the requested resource Kind. More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#types-kinds",
                                        "type": "string"
                                      },
                                      "name": {
                                        "description": "The name attribute of the resource associated with the status StatusReason (when there is a single name which can be described).",
                                        "type": "string"
                                      },
                                      "retryAfterSeconds": {
                                        "description": "If specified, the time in seconds before the operation should be retried. Some errors may indicate the client must take an alternate action - for those errors this field may indicate how long to wait before taking the alternate action.",
                                        "format": "int32",
                                        "type": "integer"
                                      },
                                      "uid": {
                                        "description": "UID of the resource. (when there is a single resource which can be described). More info: http://kubernetes.io/docs/user-guide/identifiers#uids",
                                        "type": "string"
                                      }
                                    }
                                  },
                                  "kind": {
                                    "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#types-kinds",
                                    "type": "string"
                                  },
                                  "message": {
                                    "description": "A human-readable description of the status of this operation.",
                                    "type": "string"
                                  },
                                  "metadata": {
                                    "description": "ListMeta describes metadata that synthetic resources must have, including lists and various status objects. A resource may have only one of {ObjectMeta, ListMeta}.",
                                    "properties": {
                                      "continue": {
                                        "description": "continue may be set if the user set a limit on the number of items returned, and indicates that the server has more data available. The value is opaque and may be used to issue another request to the endpoint that served this list to retrieve the next set of available objects. Continuing a consistent list may not be possible if the server configuration has changed or more than a few minutes have passed. The resourceVersion field returned when using this continue value will be identical to the value in the first response, unless you have received this token from an error message.",
                                        "type": "string"
                                      },
                                      "resourceVersion": {
                                        "description": "String that identifies the server's internal version of this object that can be used by clients to determine when objects have changed. Value must be treated as opaque by clients and passed unmodified back to the server. Populated by the system. Read-only. More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#concurrency-control-and-consistency",
                                        "type": "string"
                                      },
                                      "selfLink": {
                                        "description": "selfLink is a URL representing this object. Populated by the system. Read-only.",
                                        "type": "string"
                                      }
                                    }
                                  },
                                  "reason": {
                                    "description": "A machine-readable description of why this operation is in the \"Failure\" status. If this value is empty there is no information available. A Reason clarifies an HTTP status code but does not override it.",
                                    "type": "string"
                                  },
                                  "status": {
                                    "description": "Status of the operation. One of: \"Success\" or \"Failure\". More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#spec-and-status",
                                    "type": "string"
                                  }
                                }
                              }
                            },
                            "required": [
                              "pending"
                            ]
                          },
                          "labels": {
                            "description": "Map of string keys and values that can be used to organize and categorize (scope and select) objects. May match selectors of replication controllers and services. More info: http://kubernetes.io/docs/user-guide/labels",
                            "type": "object"
                          },
                          "name": {
                            "description": "Name must be unique within a namespace. Is required when creating resources, although some resources may allow a client to request the generation of an appropriate name automatically. Name is primarily intended for creation idempotence and configuration definition. Cannot be updated. More info: http://kubernetes.io/docs/user-guide/identifiers#names",
                            "type": "string"
                          },
                          "namespace": {
                            "description": "Namespace defines the space within each name must be unique. An empty namespace is equivalent to the \"default\" namespace, but \"default\" is the canonical representation. Not all objects are required to be scoped to a namespace - the value of this field for those objects will be empty.\n\nMust be a DNS_LABEL. Cannot be updated. More info: http://kubernetes.io/docs/user-guide/namespaces",
                            "type": "string"
                          },
                          "ownerReferences": {
                            "description": "List of objects depended by this object. If ALL objects in the list have been deleted, this object will be garbage collected. If this object is managed by a controller, then an entry in this list will point to this controller, with the controller field set to true. There cannot be more than one managing controller.",
                            "items": {
                              "description": "OwnerReference contains enough information to let you identify an owning object. Currently, an owning object must be in the same namespace, so there is no namespace field.",
                              "properties": {
                                "apiVersion": {
                                  "description": "API version of the referent.",
                                  "type": "string"
                                },
                                "blockOwnerDeletion": {
                                  "description": "If true, AND if the owner has the \"foregroundDeletion\" finalizer, then the owner cannot be deleted from the key-value store until this reference is removed. Defaults to false. To set this field, a user needs \"delete\" permission of the owner, otherwise 422 (Unprocessable Entity) will be returned.",
                                  "type": "boolean"
                                },
                                "controller": {
                                  "description": "If true, this reference points to the managing controller.",
                                  "type": "boolean"
                                },
                                "kind": {
                                  "description": "Kind of the referent. More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#types-kinds",
                                  "type": "string"
                                },
                                "name": {
                                  "description": "Name of the referent. More info: http://kubernetes.io/docs/user-guide/identifiers#names",
                                  "type": "string"
                                },
                                "uid": {
                                  "description": "UID of the referent. More info: http://kubernetes.io/docs/user-guide/identifiers#uids",
                                  "type": "string"
                                }
                              },
                              "required": [
                                "apiVersion",
                                "kind",
                                "name",
                                "uid"
                              ]
                            },
                            "type": "array"
                          },
                          "resourceVersion": {
                            "description": "An opaque value that represents the internal version of this object that can be used by clients to determine when objects have changed. May be used for optimistic concurrency, change detection, and the watch operation on a resource or set of resources. Clients must treat these values as opaque and passed unmodified back to the server. They may only be valid for a particular resource or set of resources.\n\nPopulated by the system. Read-only. Value must be treated as opaque by clients and . More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#concurrency-control-and-consistency",
                            "type": "string"
                          },
                          "selfLink": {
                            "description": "SelfLink is a URL representing this object. Populated by the system. Read-only.",
                            "type": "string"
                          },
                          "uid": {
                            "description": "UID is the unique in time and space value for this object. It is typically generated by the server on successful creation of a resource and is not allowed to change on PUT operations.\n\nPopulated by the system. Read-only. More info: http://kubernetes.io/docs/user-guide/identifiers#uids",
                            "type": "string"
                          }
                        }
                      },
                      "spec": {
                        "description": "PersistentVolumeClaimSpec describes the common attributes of storage devices and allows a Source for provider-specific attributes",
                        "properties": {
                          "accessModes": {
                            "description": "AccessModes contains the desired access modes the volume should have. More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#access-modes-1",
                            "items": {
                              "type": "string"
                            },
                            "type": "array"
                          },
                          "dataSource": {
                            "description": "TypedLocalObjectReference contains enough information to let you locate the typed referenced object inside the same namespace.",
                            "properties": {
                              "apiGroup": {
                                "description": "APIGroup is the group for the resource being referenced. If APIGroup is not specified, the specified Kind must be in the core API group. For any other third-party types, APIGroup is required.",
                                "type": "string"
                              },
                              "kind": {
                                "description": "Kind is the type of resource being referenced",
                                "type": "string"
                              },
                              "name": {
                                "description": "Name is the name of resource being referenced",
                                "type": "string"
                              }
                            },
                            "required": [
                              "kind",
                              "name"
                            ]
                          },
                          "resources": {
                            "description": "ResourceRequirements describes the compute resource requirements.",
                            "properties": {
                              "limits": {
                                "description": "Limits describes the maximum amount of compute resources allowed. More info: https://kubernetes.io/docs/concepts/configuration/manage-compute-resources-container/",
                                "type": "object"
                              },
                              "requests": {
                                "description": "Requests describes the minimum amount of compute resources required. If Requests is omitted for a container, it defaults to Limits if that is explicitly specified, otherwise to an implementation-defined value. More info: https://kubernetes.io/docs/concepts/configuration/manage-compute-resources-container/",
                                "type": "object"
                              }
                            }
                          },
                          "selector": {
                            "description": "A label selector is a label query over a set of resources. The result of matchLabels and matchExpressions are ANDed. An empty label selector matches all objects. A null label selector matches no objects.",
                            "properties": {
                              "matchExpressions": {
                                "description": "matchExpressions is a list of label selector requirements. The requirements are ANDed.",
                                "items": {
                                  "description": "A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.",
                                  "properties": {
                                    "key": {
                                      "description": "key is the label key that the selector applies to.",
                                      "type": "string"
                                    },
                                    "operator": {
                                      "description": "operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.",
                                      "type": "string"
                                    },
                                    "values": {
                                      "description": "values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.",
                                      "items": {
                                        "type": "string"
                                      },
                                      "type": "array"
                                    }
                                  },
                                  "required": [
                                    "key",
                                    "operator"
                                  ]
                                },
                                "type": "array"
                              },
                              "matchLabels": {
                                "description": "matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is \"key\", the operator is \"In\", and the values array contains only \"value\". The requirements are ANDed.",
                                "type": "object"
                              }
                            }
                          },
                          "storageClassName": {
                            "description": "Name of the StorageClass required by the claim. More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#class-1",
                            "type": "string"
                          },
                          "volumeMode": {
                            "description": "volumeMode defines what type of volume is required by the claim. Value of Filesystem is implied when not included in claim spec. This is an alpha feature and may change in the future.",
                            "type": "string"
                          },
                          "volumeName": {
                            "description": "VolumeName is the binding reference to the PersistentVolume backing this claim.",
                            "type": "string"
                          }
                        }
                      },
                      "status": {
                        "description": "PersistentVolumeClaimStatus is the current status of a persistent volume claim.",
                        "properties": {
                          "accessModes": {
                            "description": "AccessModes contains the actual access modes the volume backing the PVC has. More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#access-modes-1",
                            "items": {
                              "type": "string"
                            },
                            "type": "array"
                          },
                          "capacity": {
                            "description": "Represents the actual resources of the underlying volume.",
                            "type": "object"
                          },
                          "conditions": {
                            "description": "Current Condition of persistent volume claim. If underlying persistent volume is being resized then the Condition will be set to 'ResizeStarted'.",
                            "items": {
                              "description": "PersistentVolumeClaimCondition contails details about state of pvc",
                              "properties": {
                                "lastProbeTime": {
                                  "description": "Time is a wrapper around time.Time which supports correct marshaling to YAML and JSON.  Wrappers are provided for many of the factory methods that the time package offers.",
                                  "format": "date-time",
                                  "type": "string"
                                },
                                "lastTransitionTime": {
                                  "description": "Time is a wrapper around time.Time which supports correct marshaling to YAML and JSON.  Wrappers are provided for many of the factory methods that the time package offers.",
                                  "format": "date-time",
                                  "type": "string"
                                },
                                "message": {
                                  "description": "Human-readable message indicating details about last transition.",
                                  "type": "string"
                                },
                                "reason": {
                                  "description": "Unique, this should be a short, machine understandable string that gives the reason for condition's last transition. If it reports \"ResizeStarted\" that means the underlying persistent volume is being resized.",
                                  "type": "string"
                                },
                                "status": {
                                  "type": "string"
                                },
                                "type": {
                                  "type": "string"
                                }
                              },
                              "required": [
                                "type",
                                "status"
                              ]
                            },
                            "type": "array"
                          },
                          "phase": {
                            "description": "Phase represents the current phase of PersistentVolumeClaim.",
                            "type": "string"
                          }
                        }
                      }
                    }
                  }
                }
              },
              "tag": {
                "description": "Tag of Alertmanager container image to be deployed. Defaults to the value of `version`. Version is ignored if Tag is set.",
                "type": "string"
              },
              "tolerations": {
                "description": "If specified, the pod's tolerations.",
                "items": {
                  "description": "The pod this Toleration is attached to tolerates any taint that matches the triple <key,value,effect> using the matching operator <operator>.",
                  "properties": {
                    "effect": {
                      "description": "Effect indicates the taint effect to match. Empty means match all taint effects. When specified, allowed values are NoSchedule, PreferNoSchedule and NoExecute.",
                      "type": "string"
                    },
                    "key": {
                      "description": "Key is the taint key that the toleration applies to. Empty means match all taint keys. If the key is empty, operator must be Exists; this combination means to match all values and all keys.",
                      "type": "string"
                    },
                    "operator": {
                      "description": "Operator represents a key's relationship to the value. Valid operators are Exists and Equal. Defaults to Equal. Exists is equivalent to wildcard for value, so that a pod can tolerate all taints of a particular category.",
                      "type": "string"
                    },
                    "tolerationSeconds": {
                      "description": "TolerationSeconds represents the period of time the toleration (which must be of effect NoExecute, otherwise this field is ignored) tolerates the taint. By default, it is not set, which means tolerate the taint forever (do not evict). Zero and negative values will be treated as 0 (evict immediately) by the system.",
                      "format": "int64",
                      "type": "integer"
                    },
                    "value": {
                      "description": "Value is the taint value the toleration matches to. If the operator is Exists, the value should be empty, otherwise just a regular string.",
                      "type": "string"
                    }
                  }
                },
                "type": "array"
              },
              "version": {
                "description": "Version the cluster should be on.",
                "type": "string"
              }
            }
          },
          "status": {
            "description": "AlertmanagerStatus is the most recent observed status of the Alertmanager cluster. Read-only. Not included when requesting from the apiserver, only from the Prometheus Operator API itself. More info: https://github.com/kubernetes/community/blob/master/contributors/devel/api-conventions.md#spec-and-status",
            "properties": {
              "availableReplicas": {
                "description": "Total number of available pods (ready for at least minReadySeconds) targeted by this Alertmanager cluster.",
                "format": "int32",
                "type": "integer"
              },
              "paused": {
                "description": "Represents whether any actions on the underlying managed objects are being performed. Only delete actions will be performed.",
                "type": "boolean"
              },
              "replicas": {
                "description": "Total number of non-terminated pods targeted by this Alertmanager cluster (their labels match the selector).",
                "format": "int32",
                "type": "integer"
              },
              "unavailableReplicas": {
                "description": "Total number of unavailable pods targeted by this Alertmanager cluster.",
                "format": "int32",
                "type": "integer"
              },
              "updatedReplicas": {
                "description": "Total number of non-terminated pods targeted by this Alertmanager cluster that have the desired version spec.",
                "format": "int32",
                "type": "integer"
              }
            },
            "required": [
              "paused",
              "replicas",
              "updatedReplicas",
              "availableReplicas",
              "unavailableReplicas"
            ]
          }
        }
      }
    },
    "version": "v1",
    "versions": [
      {
        "name": "v1",
        "served": true,
        "storage": true
      }
    ]
  }
}

---

{
  "metadata": {
    "name": "apiservers.config.openshift.io"
  },
  "apiVersion": "apiextensions.k8s.io/v1beta1",
  "kind": "CustomResourceDefinition",
  "spec": {
    "conversion": {
      "strategy": "None"
    },
    "group": "config.openshift.io",
    "names": {
      "kind": "APIServer",
      "listKind": "APIServerList",
      "plural": "apiservers",
      "singular": "apiserver"
    },
    "scope": "Cluster",
    "validation": {
      "openAPIV3Schema": {
        "properties": {
          "apiVersion": {
            "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#resources",
            "type": "string"
          },
          "kind": {
            "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#types-kinds",
            "type": "string"
          },
          "metadata": {
            "type": "object"
          },
          "spec": {
            "properties": {
              "clientCA": {
                "description": "clientCA references a ConfigMap containing a certificate bundle for the signers that will be recognized for incoming client certificates in addition to the operator managed signers. If this is empty, then only operator managed signers are valid. You usually only have to set this if you have your own PKI you wish to honor client certificates from. The ConfigMap must exist in the openshift-config namespace and contain the following required fields: - ConfigMap.Data[\"ca-bundle.crt\"] - CA bundle.",
                "properties": {
                  "name": {
                    "description": "name is the metadata.name of the referenced config map",
                    "type": "string"
                  }
                },
                "type": "object"
              },
              "servingCerts": {
                "description": "servingCert is the TLS cert info for serving secure traffic. If not specified, operator managed certificates will be used for serving secure traffic.",
                "properties": {
                  "defaultServingCertificate": {
                    "description": "defaultServingCertificate references a kubernetes.io/tls type secret containing the default TLS cert info for serving secure traffic. If no named certificates match the server name as understood by a client, this default certificate will be used. If defaultServingCertificate is not specified, then a operator managed certificate will be used. The secret must exist in the openshift-config namespace and contain the following required fields: - Secret.Data[\"tls.key\"] - TLS private key. - Secret.Data[\"tls.crt\"] - TLS certificate.",
                    "properties": {
                      "name": {
                        "description": "name is the metadata.name of the referenced secret",
                        "type": "string"
                      }
                    },
                    "type": "object"
                  },
                  "namedCertificates": {
                    "description": "namedCertificates references secrets containing the TLS cert info for serving secure traffic to specific hostnames. If no named certificates are provided, or no named certificates match the server name as understood by a client, the defaultServingCertificate will be used.",
                    "items": {
                      "properties": {
                        "names": {
                          "description": "names is a optional list of explicit DNS names (leading wildcards allowed) that should use this certificate to serve secure traffic. If no names are provided, the implicit names will be extracted from the certificates. Exact names trump over wildcard names. Explicit names defined here trump over extracted implicit names.",
                          "items": {
                            "type": "string"
                          },
                          "type": "array"
                        },
                        "servingCertificate": {
                          "description": "servingCertificate references a kubernetes.io/tls type secret containing the TLS cert info for serving secure traffic. The secret must exist in the openshift-config namespace and contain the following required fields: - Secret.Data[\"tls.key\"] - TLS private key. - Secret.Data[\"tls.crt\"] - TLS certificate.",
                          "properties": {
                            "name": {
                              "description": "name is the metadata.name of the referenced secret",
                              "type": "string"
                            }
                          },
                          "type": "object"
                        }
                      },
                      "type": "object"
                    },
                    "type": "array"
                  }
                },
                "type": "object"
              }
            },
            "type": "object"
          },
          "status": {
            "type": "object"
          }
        },
        "required": [
          "spec"
        ]
      }
    },
    "version": "v1",
    "versions": [
      {
        "name": "v1",
        "served": true,
        "storage": true
      }
    ]
  }
}

---

{
  "metadata": {
    "name": "authentications.config.openshift.io"
  },
  "apiVersion": "apiextensions.k8s.io/v1beta1",
  "kind": "CustomResourceDefinition",
  "spec": {
    "conversion": {
      "strategy": "None"
    },
    "group": "config.openshift.io",
    "names": {
      "kind": "Authentication",
      "listKind": "AuthenticationList",
      "plural": "authentications",
      "singular": "authentication"
    },
    "scope": "Cluster",
    "subresources": {
      "status": {}
    },
    "validation": {
      "openAPIV3Schema": {
        "properties": {
          "apiVersion": {
            "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#resources",
            "type": "string"
          },
          "kind": {
            "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#types-kinds",
            "type": "string"
          },
          "metadata": {
            "description": "Standard object's metadata.",
            "type": "object"
          },
          "spec": {
            "description": "spec holds user settable values for configuration",
            "properties": {
              "oauthMetadata": {
                "description": "oauthMetadata contains the discovery endpoint data for OAuth 2.0 Authorization Server Metadata for an external OAuth server. This discovery document can be viewed from its served location: oc get --raw '/.well-known/oauth-authorization-server' For further details, see the IETF Draft: https://tools.ietf.org/html/draft-ietf-oauth-discovery-04#section-2 If oauthMetadata.name is non-empty, this value has precedence over any metadata reference stored in status. The key \"oauthMetadata\" is used to locate the data. If specified and the config map or expected key is not found, no metadata is served. If the specified metadata is not valid, no metadata is served. The namespace for this config map is openshift-config.",
                "properties": {
                  "name": {
                    "description": "name is the metadata.name of the referenced config map",
                    "type": "string"
                  }
                },
                "type": "object"
              },
              "type": {
                "description": "type identifies the cluster managed, user facing authentication mode in use. Specifically, it manages the component that responds to login attempts. The default is IntegratedOAuth.",
                "type": "string"
              },
              "webhookTokenAuthenticators": {
                "description": "webhookTokenAuthenticators configures remote token reviewers. These remote authentication webhooks can be used to verify bearer tokens via the tokenreviews.authentication.k8s.io REST API.  This is required to honor bearer tokens that are provisioned by an external authentication service. The namespace for these secrets is openshift-config.",
                "items": {
                  "properties": {
                    "kubeConfig": {
                      "description": "kubeConfig contains kube config file data which describes how to access the remote webhook service. For further details, see: https://kubernetes.io/docs/reference/access-authn-authz/authentication/#webhook-token-authentication The key \"kubeConfig\" is used to locate the data. If the secret or expected key is not found, the webhook is not honored. If the specified kube config data is not valid, the webhook is not honored. The namespace for this secret is determined by the point of use.",
                      "properties": {
                        "name": {
                          "description": "name is the metadata.name of the referenced secret",
                          "type": "string"
                        }
                      },
                      "type": "object"
                    }
                  },
                  "type": "object"
                },
                "type": "array"
              }
            },
            "type": "object"
          },
          "status": {
            "description": "status holds observed values from the cluster. They may not be overridden.",
            "properties": {
              "integratedOAuthMetadata": {
                "description": "integratedOAuthMetadata contains the discovery endpoint data for OAuth 2.0 Authorization Server Metadata for the in-cluster integrated OAuth server. This discovery document can be viewed from its served location: oc get --raw '/.well-known/oauth-authorization-server' For further details, see the IETF Draft: https://tools.ietf.org/html/draft-ietf-oauth-discovery-04#section-2 This contains the observed value based on cluster state. An explicitly set value in spec.oauthMetadata has precedence over this field. This field has no meaning if authentication spec.type is not set to IntegratedOAuth. The key \"oauthMetadata\" is used to locate the data. If the config map or expected key is not found, no metadata is served. If the specified metadata is not valid, no metadata is served. The namespace for this config map is openshift-config-managed.",
                "properties": {
                  "name": {
                    "description": "name is the metadata.name of the referenced config map",
                    "type": "string"
                  }
                },
                "type": "object"
              }
            },
            "type": "object"
          }
        },
        "required": [
          "spec"
        ]
      }
    },
    "version": "v1",
    "versions": [
      {
        "name": "v1",
        "served": true,
        "storage": true
      }
    ]
  }
}

---

{
  "metadata": {
    "name": "authentications.operator.openshift.io"
  },
  "apiVersion": "apiextensions.k8s.io/v1beta1",
  "kind": "CustomResourceDefinition",
  "spec": {
    "conversion": {
      "strategy": "None"
    },
    "group": "operator.openshift.io",
    "names": {
      "kind": "Authentication",
      "listKind": "AuthenticationList",
      "plural": "authentications",
      "singular": "authentication"
    },
    "scope": "Cluster",
    "subresources": {
      "status": {}
    },
    "validation": {
      "openAPIV3Schema": {
        "properties": {
          "apiVersion": {
            "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#resources",
            "type": "string"
          },
          "kind": {
            "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#types-kinds",
            "type": "string"
          },
          "metadata": {
            "type": "object"
          },
          "spec": {
            "properties": {
              "logLevel": {
                "description": "logLevel is an intent based logging for an overall component.  It does not give fine grained control, but it is a simple way to manage coarse grained logging choices that operators have to interpret for their operands.",
                "type": "string"
              },
              "managementState": {
                "description": "managementState indicates whether and how the operator should manage the component",
                "pattern": "^(Managed|Unmanaged|Force|Removed)$",
                "type": "string"
              },
              "observedConfig": {
                "description": "observedConfig holds a sparse config that controller has observed from the cluster state.  It exists in spec because it is an input to the level for the operator",
                "nullable": true,
                "type": "object"
              },
              "operandSpecs": {
                "description": "operandSpecs provide customization for functional units within the component",
                "items": {
                  "properties": {
                    "name": {
                      "description": "name is the name of this unit.  The operator must be aware of it.",
                      "type": "string"
                    },
                    "operandContainerSpecs": {
                      "description": "operandContainerSpecs are per-container options",
                      "items": {
                        "properties": {
                          "name": {
                            "description": "name is the name of the container to modify",
                            "type": "string"
                          },
                          "resources": {
                            "description": "resources are the requests and limits to place in the container.  Nil means to accept the defaults.",
                            "type": "object"
                          }
                        },
                        "type": "object"
                      },
                      "type": "array"
                    },
                    "unsupportedResourcePatches": {
                      "description": "unsupportedResourcePatches are applied to the workload resource for this unit. This is an unsupported workaround if anything needs to be modified on the workload that is not otherwise configurable. TODO Decide: alternatively, we could simply include a RawExtension which is used in place of the \"normal\" default manifest",
                      "items": {
                        "properties": {
                          "patch": {
                            "description": "patch the patch itself",
                            "type": "string"
                          },
                          "type": {
                            "description": "type is the type of patch to apply: jsonmerge, strategicmerge",
                            "type": "string"
                          }
                        },
                        "type": "object"
                      },
                      "type": "array"
                    }
                  },
                  "type": "object"
                },
                "type": "array"
              },
              "unsupportedConfigOverrides": {
                "description": "unsupportedConfigOverrides holds a sparse config that will override any previously set options.  It only needs to be the fields to override it will end up overlaying in the following order: 1. hardcoded defaults 2. observedConfig 3. unsupportedConfigOverrides",
                "nullable": true,
                "type": "object"
              }
            },
            "type": "object"
          },
          "status": {
            "properties": {
              "conditions": {
                "description": "conditions is a list of conditions and their status",
                "items": {
                  "properties": {
                    "lastTransitionTime": {
                      "format": "date-time",
                      "type": "string"
                    },
                    "message": {
                      "type": "string"
                    },
                    "reason": {
                      "type": "string"
                    },
                    "status": {
                      "type": "string"
                    },
                    "type": {
                      "type": "string"
                    }
                  },
                  "type": "object"
                },
                "type": "array"
              },
              "generations": {
                "description": "generations are used to determine when an item needs to be reconciled or has changed in a way that needs a reaction.",
                "items": {
                  "properties": {
                    "group": {
                      "description": "group is the group of the thing you're tracking",
                      "type": "string"
                    },
                    "hash": {
                      "description": "hash is an optional field set for resources without generation that are content sensitive like secrets and configmaps",
                      "type": "string"
                    },
                    "lastGeneration": {
                      "description": "lastGeneration is the last generation of the workload controller involved",
                      "format": "int64",
                      "type": "integer"
                    },
                    "name": {
                      "description": "name is the name of the thing you're tracking",
                      "type": "string"
                    },
                    "namespace": {
                      "description": "namespace is where the thing you're tracking is",
                      "type": "string"
                    },
                    "resource": {
                      "description": "resource is the resource type of the thing you're tracking",
                      "type": "string"
                    }
                  },
                  "type": "object"
                },
                "type": "array"
              },
              "observedGeneration": {
                "description": "observedGeneration is the last generation change you've dealt with",
                "format": "int64",
                "type": "integer"
              },
              "readyReplicas": {
                "description": "readyReplicas indicates how many replicas are ready and at the desired state",
                "format": "int32",
                "type": "integer"
              },
              "version": {
                "description": "version is the level this availability applies to",
                "type": "string"
              }
            },
            "type": "object"
          }
        },
        "required": [
          "spec"
        ]
      }
    },
    "version": "v1",
    "versions": [
      {
        "name": "v1",
        "served": true,
        "storage": true
      }
    ]
  }
}

---

{
  "metadata": {
    "name": "builds.config.openshift.io"
  },
  "apiVersion": "apiextensions.k8s.io/v1beta1",
  "kind": "CustomResourceDefinition",
  "spec": {
    "conversion": {
      "strategy": "None"
    },
    "group": "config.openshift.io",
    "names": {
      "kind": "Build",
      "listKind": "BuildList",
      "plural": "builds",
      "singular": "build"
    },
    "scope": "Cluster",
    "validation": {
      "openAPIV3Schema": {
        "properties": {
          "apiVersion": {
            "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#resources",
            "type": "string"
          },
          "kind": {
            "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#types-kinds",
            "type": "string"
          },
          "metadata": {
            "type": "object"
          },
          "spec": {
            "description": "Spec holds user-settable values for the build controller configuration",
            "properties": {
              "additionalTrustedCA": {
                "description": "AdditionalTrustedCA is a reference to a ConfigMap containing additional CAs that should be trusted for image pushes and pulls during builds. The namespace for this config map is openshift-config.",
                "properties": {
                  "name": {
                    "description": "name is the metadata.name of the referenced config map",
                    "type": "string"
                  }
                },
                "type": "object"
              },
              "buildDefaults": {
                "description": "BuildDefaults controls the default information for Builds",
                "properties": {
                  "defaultProxy": {
                    "description": "DefaultProxy contains the default proxy settings for all build operations, including image pull/push and source download.  Values can be overrode by setting the `HTTP_PROXY`, `HTTPS_PROXY`, and `NO_PROXY` environment variables in the build config's strategy.",
                    "properties": {
                      "httpProxy": {
                        "description": "httpProxy is the URL of the proxy for HTTP requests.  Empty means unset and will not result in an env var.",
                        "type": "string"
                      },
                      "httpsProxy": {
                        "description": "httpsProxy is the URL of the proxy for HTTPS requests.  Empty means unset and will not result in an env var.",
                        "type": "string"
                      },
                      "noProxy": {
                        "description": "noProxy is the list of domains for which the proxy should not be used.  Empty means unset and will not result in an env var.",
                        "type": "string"
                      }
                    },
                    "type": "object"
                  },
                  "env": {
                    "description": "Env is a set of default environment variables that will be applied to the build if the specified variables do not exist on the build",
                    "items": {
                      "type": "object"
                    },
                    "type": "array"
                  },
                  "gitProxy": {
                    "description": "GitProxy contains the proxy settings for git operations only. If set, this will override any Proxy settings for all git commands, such as git clone.  Values that are not set here will be inherited from DefaultProxy.",
                    "properties": {
                      "httpProxy": {
                        "description": "httpProxy is the URL of the proxy for HTTP requests.  Empty means unset and will not result in an env var.",
                        "type": "string"
                      },
                      "httpsProxy": {
                        "description": "httpsProxy is the URL of the proxy for HTTPS requests.  Empty means unset and will not result in an env var.",
                        "type": "string"
                      },
                      "noProxy": {
                        "description": "noProxy is the list of domains for which the proxy should not be used.  Empty means unset and will not result in an env var.",
                        "type": "string"
                      }
                    },
                    "type": "object"
                  },
                  "imageLabels": {
                    "description": "ImageLabels is a list of docker labels that are applied to the resulting image. User can override a default label by providing a label with the same name in their Build/BuildConfig.",
                    "items": {
                      "properties": {
                        "name": {
                          "description": "Name defines the name of the label. It must have non-zero length.",
                          "type": "string"
                        },
                        "value": {
                          "description": "Value defines the literal value of the label.",
                          "type": "string"
                        }
                      },
                      "type": "object"
                    },
                    "type": "array"
                  },
                  "resources": {
                    "description": "Resources defines resource requirements to execute the build.",
                    "type": "object"
                  }
                },
                "type": "object"
              },
              "buildOverrides": {
                "description": "BuildOverrides controls override settings for builds",
                "properties": {
                  "imageLabels": {
                    "description": "ImageLabels is a list of docker labels that are applied to the resulting image. If user provided a label in their Build/BuildConfig with the same name as one in this list, the user's label will be overwritten.",
                    "items": {
                      "properties": {
                        "name": {
                          "description": "Name defines the name of the label. It must have non-zero length.",
                          "type": "string"
                        },
                        "value": {
                          "description": "Value defines the literal value of the label.",
                          "type": "string"
                        }
                      },
                      "type": "object"
                    },
                    "type": "array"
                  },
                  "nodeSelector": {
                    "description": "NodeSelector is a selector which must be true for the build pod to fit on a node",
                    "type": "object"
                  },
                  "tolerations": {
                    "description": "Tolerations is a list of Tolerations that will override any existing tolerations set on a build pod.",
                    "items": {
                      "type": "object"
                    },
                    "type": "array"
                  }
                },
                "type": "object"
              }
            },
            "type": "object"
          }
        },
        "required": [
          "spec"
        ]
      }
    },
    "version": "v1",
    "versions": [
      {
        "name": "v1",
        "served": true,
        "storage": true
      }
    ]
  }
}

---

{
  "metadata": {
    "name": "catalogsourceconfigs.operators.coreos.com"
  },
  "apiVersion": "apiextensions.k8s.io/v1beta1",
  "kind": "CustomResourceDefinition",
  "spec": {
    "additionalPrinterColumns": [
      {
        "JSONPath": ".status.currentPhase.phase.name",
        "description": "Current status of the CatalogSourceConfig",
        "name": "Status",
        "type": "string"
      },
      {
        "JSONPath": ".status.currentPhase.phase.message",
        "description": "Message associated with the current status",
        "name": "Message",
        "type": "string"
      },
      {
        "JSONPath": ".metadata.creationTimestamp",
        "name": "Age",
        "type": "date"
      }
    ],
    "conversion": {
      "strategy": "None"
    },
    "group": "operators.coreos.com",
    "names": {
      "kind": "CatalogSourceConfig",
      "listKind": "CatalogSourceConfigList",
      "plural": "catalogsourceconfigs",
      "shortNames": [
        "csc"
      ],
      "singular": "catalogsourceconfig"
    },
    "scope": "Namespaced",
    "validation": {
      "openAPIV3Schema": {
        "description": "CatalogSourceConfig is used to enable an operator present in the OperatorSource to your cluster. Behind the scenes, it will configure an OLM CatalogSource so that the operator can then be managed by OLM.",
        "properties": {
          "spec": {
            "description": "Spec for a CatalogSourceConfig",
            "properties": {
              "csDisplayName": {
                "description": "DisplayName is passed along to the CatalogSource to be used as a pretty name.",
                "type": "string"
              },
              "csPublisher": {
                "description": "It represents the entity that published the operator(s) specified in packages.",
                "type": "string"
              },
              "packages": {
                "description": "Comma separated list of operator(s) without spaces which will be enabled in the target namespace",
                "type": "string"
              },
              "targetNamespace": {
                "description": "The namespace where the operators will be enabled",
                "type": "string"
              }
            },
            "required": [
              "targetNamespace",
              "packages"
            ],
            "type": "object"
          },
          "status": {
            "type": "object"
          }
        }
      }
    },
    "version": "v1",
    "versions": [
      {
        "name": "v1",
        "served": true,
        "storage": true
      }
    ]
  }
}

---

{
  "metadata": {
    "name": "catalogsources.operators.coreos.com"
  },
  "apiVersion": "apiextensions.k8s.io/v1beta1",
  "kind": "CustomResourceDefinition",
  "spec": {
    "additionalPrinterColumns": [
      {
        "JSONPath": ".spec.displayName",
        "description": "The pretty name of the catalog",
        "name": "Name",
        "type": "string"
      },
      {
        "JSONPath": ".spec.sourceType",
        "description": "The type of the catalog",
        "name": "Type",
        "type": "string"
      },
      {
        "JSONPath": ".spec.publisher",
        "description": "The publisher of the catalog",
        "name": "Publisher",
        "type": "string"
      },
      {
        "JSONPath": ".metadata.creationTimestamp",
        "name": "Age",
        "type": "date"
      }
    ],
    "conversion": {
      "strategy": "None"
    },
    "group": "operators.coreos.com",
    "names": {
      "categories": [
        "olm"
      ],
      "kind": "CatalogSource",
      "listKind": "CatalogSourceList",
      "plural": "catalogsources",
      "shortNames": [
        "catsrc"
      ],
      "singular": "catalogsource"
    },
    "scope": "Namespaced",
    "subresources": {
      "status": {}
    },
    "validation": {
      "openAPIV3Schema": {
        "description": "A source configured to find packages and updates.",
        "properties": {
          "spec": {
            "description": "Spec for a catalog source.",
            "properties": {
              "address": {
                "description": "An optional address. When set, directs OLM to connect to use a pre-existing registry server at this address.",
                "type": "string"
              },
              "configMap": {
                "description": "The name of a ConfigMap that holds the entries for an in-memory catalog.",
                "type": "string"
              },
              "displayName": {
                "description": "Pretty name for display",
                "type": "string"
              },
              "image": {
                "description": "An image that serves a grpc registry. Only valid for `grpc` sourceType. If both image and address are set, OLM does not use the address field.",
                "type": "string"
              },
              "publisher": {
                "description": "The name of an entity that publishes this catalog",
                "type": "string"
              },
              "secrets": {
                "description": "A set of secrets that can be used to access the contents of the catalog. It is best to keep this list small, since each will need to be tried for every catalog entry.",
                "items": {
                  "description": "A name of a secret in the namespace where the CatalogSource is defined.",
                  "type": "string"
                },
                "type": "array"
              },
              "sourceType": {
                "description": "The type of the source. `configmap` is the new name for `internal`",
                "enum": [
                  "internal",
                  "configmap",
                  "grpc"
                ],
                "type": "string"
              }
            },
            "required": [
              "sourceType"
            ],
            "type": "object"
          },
          "status": {
            "description": "The status of the CatalogSource",
            "properties": {
              "configMapReference": {
                "description": "If sourceType is `internal` or `configmap`, then this holds a reference to the configmap associated with this CatalogSource.",
                "properties": {
                  "name": {
                    "description": "name of the configmap",
                    "type": "string"
                  },
                  "namespace": {
                    "description": "namespace of the configmap",
                    "type": "string"
                  },
                  "resourceVersion": {
                    "description": "resourceVersion of the configmap",
                    "type": "string"
                  },
                  "uid": {
                    "description": "uid of the configmap",
                    "type": "string"
                  }
                },
                "type": "object"
              },
              "lastSync": {
                "description": "the last time the catalog was updated. If this time is less than the last updated time on the object, the catalog will be re-cached.",
                "type": "string"
              },
              "registryService": {
                "properties": {
                  "port": {
                    "description": "port of the registry service",
                    "type": "string"
                  },
                  "protocol": {
                    "description": "protocol of the registry service",
                    "enum": [
                      "grpc"
                    ],
                    "type": "string"
                  },
                  "serviceName": {
                    "description": "name of the registry service",
                    "type": "string"
                  },
                  "serviceNamespace": {
                    "description": "namespace of the registry service",
                    "type": "string"
                  }
                },
                "type": "object"
              }
            },
            "type": "object"
          }
        }
      }
    },
    "version": "v1alpha1",
    "versions": [
      {
        "name": "v1alpha1",
        "served": true,
        "storage": true
      }
    ]
  }
}

---

{
  "metadata": {
    "name": "clusterautoscalers.autoscaling.openshift.io"
  },
  "apiVersion": "apiextensions.k8s.io/v1beta1",
  "kind": "CustomResourceDefinition",
  "spec": {
    "conversion": {
      "strategy": "None"
    },
    "group": "autoscaling.openshift.io",
    "names": {
      "kind": "ClusterAutoscaler",
      "listKind": "ClusterAutoscalerList",
      "plural": "clusterautoscalers",
      "singular": "clusterautoscaler"
    },
    "scope": "Cluster",
    "subresources": {
      "status": {}
    },
    "validation": {
      "openAPIV3Schema": {
        "properties": {
          "apiVersion": {
            "type": "string"
          },
          "kind": {
            "type": "string"
          },
          "metadata": {
            "type": "object"
          },
          "spec": {
            "properties": {
              "maxPodGracePeriod": {
                "format": "int32",
                "type": "integer"
              },
              "podPriorityThreshold": {
                "format": "int32",
                "type": "integer"
              },
              "resourceLimits": {
                "properties": {
                  "cores": {
                    "properties": {
                      "max": {
                        "format": "int32",
                        "type": "integer"
                      },
                      "min": {
                        "format": "int32",
                        "minimum": 0,
                        "type": "integer"
                      }
                    },
                    "required": [
                      "min",
                      "max"
                    ],
                    "type": "object"
                  },
                  "gpus": {
                    "items": {
                      "properties": {
                        "max": {
                          "format": "int32",
                          "minimum": 1,
                          "type": "integer"
                        },
                        "min": {
                          "format": "int32",
                          "minimum": 0,
                          "type": "integer"
                        },
                        "type": {
                          "minLength": 1,
                          "type": "string"
                        }
                      },
                      "required": [
                        "type",
                        "min",
                        "max"
                      ],
                      "type": "object"
                    },
                    "type": "array"
                  },
                  "maxNodesTotal": {
                    "format": "int32",
                    "minimum": 0,
                    "type": "integer"
                  },
                  "memory": {
                    "properties": {
                      "max": {
                        "format": "int32",
                        "type": "integer"
                      },
                      "min": {
                        "format": "int32",
                        "minimum": 0,
                        "type": "integer"
                      }
                    },
                    "required": [
                      "min",
                      "max"
                    ],
                    "type": "object"
                  }
                },
                "type": "object"
              },
              "scaleDown": {
                "properties": {
                  "delayAfterAdd": {
                    "pattern": "([0-9]*(\\.[0-9]*)?[a-z]+)+",
                    "type": "string"
                  },
                  "delayAfterDelete": {
                    "pattern": "([0-9]*(\\.[0-9]*)?[a-z]+)+",
                    "type": "string"
                  },
                  "delayAfterFailure": {
                    "pattern": "([0-9]*(\\.[0-9]*)?[a-z]+)+",
                    "type": "string"
                  },
                  "enabled": {
                    "type": "boolean"
                  },
                  "unneededTime": {
                    "pattern": "([0-9]*(\\.[0-9]*)?[a-z]+)+",
                    "type": "string"
                  }
                },
                "required": [
                  "enabled"
                ],
                "type": "object"
              }
            },
            "type": "object"
          },
          "status": {
            "type": "object"
          }
        }
      }
    },
    "version": "v1",
    "versions": [
      {
        "name": "v1",
        "served": true,
        "storage": true
      }
    ]
  }
}

---

{
  "metadata": {
    "name": "clusternetworks.network.openshift.io"
  },
  "apiVersion": "apiextensions.k8s.io/v1beta1",
  "kind": "CustomResourceDefinition",
  "spec": {
    "additionalPrinterColumns": [
      {
        "JSONPath": ".network",
        "description": "The primary cluster network CIDR",
        "name": "Cluster Network",
        "type": "string"
      },
      {
        "JSONPath": ".serviceNetwork",
        "description": "The service network CIDR",
        "name": "Service Network",
        "type": "string"
      },
      {
        "JSONPath": ".pluginName",
        "description": "The OpenShift SDN network plug-in in use",
        "name": "Plugin Name",
        "type": "string"
      }
    ],
    "conversion": {
      "strategy": "None"
    },
    "group": "network.openshift.io",
    "names": {
      "kind": "ClusterNetwork",
      "listKind": "ClusterNetworkList",
      "plural": "clusternetworks",
      "singular": "clusternetwork"
    },
    "scope": "Cluster",
    "validation": {
      "openAPIV3Schema": {
        "properties": {
          "clusterNetworks": {
            "items": {
              "properties": {
                "CIDR": {
                  "pattern": "^(([0-9]|[0-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[0-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])/([0-9]|[12][0-9]|3[0-2])$",
                  "type": "string"
                },
                "hostSubnetLength": {
                  "maximum": 30,
                  "minimum": 2,
                  "type": "integer"
                }
              },
              "type": "object"
            },
            "type": "array"
          },
          "hostsubnetlength": {
            "maximum": 30,
            "minimum": 2,
            "type": "integer"
          },
          "network": {
            "pattern": "^(([0-9]|[0-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[0-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])/([0-9]|[12][0-9]|3[0-2])$",
            "type": "string"
          },
          "pluginName": {
            "type": "string"
          },
          "serviceNetwork": {
            "pattern": "^(([0-9]|[0-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[0-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])/([0-9]|[12][0-9]|3[0-2])$",
            "type": "string"
          },
          "vxlanPort": {
            "maximum": 65535,
            "minimum": 1,
            "type": "integer"
          }
        }
      }
    },
    "version": "v1",
    "versions": [
      {
        "name": "v1",
        "served": true,
        "storage": true
      }
    ]
  }
}

---

{
  "metadata": {
    "name": "clusteroperators.config.openshift.io"
  },
  "apiVersion": "apiextensions.k8s.io/v1beta1",
  "kind": "CustomResourceDefinition",
  "spec": {
    "additionalPrinterColumns": [
      {
        "JSONPath": ".status.versions[?(@.name==\"operator\")].version",
        "description": "The version the operator is at.",
        "name": "Version",
        "type": "string"
      },
      {
        "JSONPath": ".status.conditions[?(@.type==\"Available\")].status",
        "description": "Whether the operator is running and stable.",
        "name": "Available",
        "type": "string"
      },
      {
        "JSONPath": ".status.conditions[?(@.type==\"Progressing\")].status",
        "description": "Whether the operator is processing changes.",
        "name": "Progressing",
        "type": "string"
      },
      {
        "JSONPath": ".status.conditions[?(@.type==\"Degraded\")].status",
        "description": "Whether the operator is degraded.",
        "name": "Degraded",
        "type": "string"
      },
      {
        "JSONPath": ".status.conditions[?(@.type==\"Available\")].lastTransitionTime",
        "description": "The time the operator's Available status last changed.",
        "name": "Since",
        "type": "date"
      }
    ],
    "conversion": {
      "strategy": "None"
    },
    "group": "config.openshift.io",
    "names": {
      "kind": "ClusterOperator",
      "listKind": "ClusterOperatorList",
      "plural": "clusteroperators",
      "shortNames": [
        "co"
      ],
      "singular": "clusteroperator"
    },
    "scope": "Cluster",
    "subresources": {
      "status": {}
    },
    "validation": {
      "openAPIV3Schema": {
        "properties": {
          "apiVersion": {
            "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#resources",
            "type": "string"
          },
          "kind": {
            "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#types-kinds",
            "type": "string"
          },
          "metadata": {
            "type": "object"
          },
          "spec": {
            "description": "spec hold the intent of how this operator should behave.",
            "type": "object"
          },
          "status": {
            "description": "status holds the information about the state of an operator.  It is consistent with status information across the kube ecosystem.",
            "properties": {
              "conditions": {
                "description": "conditions describes the state of the operator's reconciliation functionality. +patchMergeKey=type +patchStrategy=merge",
                "items": {
                  "properties": {
                    "lastTransitionTime": {
                      "description": "lastTransitionTime is the time of the last update to the current status object.",
                      "format": "date-time",
                      "type": "string"
                    },
                    "message": {
                      "description": "message provides additional information about the current condition. This is only to be consumed by humans.",
                      "type": "string"
                    },
                    "reason": {
                      "description": "reason is the reason for the condition's last transition.  Reasons are CamelCase",
                      "type": "string"
                    },
                    "status": {
                      "description": "status of the condition, one of True, False, Unknown.",
                      "type": "string"
                    },
                    "type": {
                      "description": "type specifies the state of the operator's reconciliation functionality.",
                      "type": "string"
                    }
                  },
                  "type": "object"
                },
                "type": "array"
              },
              "extension": {
                "description": "extension contains any additional status information specific to the operator which owns this status object.",
                "nullable": true,
                "type": "object"
              },
              "relatedObjects": {
                "description": "relatedObjects is a list of objects that are \"interesting\" or related to this operator.  Common uses are: 1. the detailed resource driving the operator 2. operator namespaces 3. operand namespaces",
                "items": {
                  "properties": {
                    "group": {
                      "description": "group of the referent.",
                      "type": "string"
                    },
                    "name": {
                      "description": "name of the referent.",
                      "type": "string"
                    },
                    "namespace": {
                      "description": "namespace of the referent.",
                      "type": "string"
                    },
                    "resource": {
                      "description": "resource of the referent.",
                      "type": "string"
                    }
                  },
                  "type": "object"
                },
                "type": "array"
              },
              "versions": {
                "description": "versions is a slice of operand version tuples.  Operators which manage multiple operands will have multiple entries in the array.  If an operator is Available, it must have at least one entry.  You must report the version of the operator itself with the name \"operator\".",
                "items": {
                  "properties": {
                    "name": {
                      "description": "name is the name of the particular operand this version is for.  It usually matches container images, not operators.",
                      "type": "string"
                    },
                    "version": {
                      "description": "version indicates which version of a particular operand is currently being manage.  It must always match the Available condition.  If 1.0.0 is Available, then this must indicate 1.0.0 even if the operator is trying to rollout 1.1.0",
                      "type": "string"
                    }
                  },
                  "type": "object"
                },
                "type": "array"
              }
            },
            "type": "object"
          }
        },
        "required": [
          "spec"
        ]
      }
    },
    "version": "v1",
    "versions": [
      {
        "name": "v1",
        "served": true,
        "storage": true
      }
    ]
  }
}

---

{
  "metadata": {
    "name": "clusterresourcequotas.quota.openshift.io"
  },
  "apiVersion": "apiextensions.k8s.io/v1beta1",
  "kind": "CustomResourceDefinition",
  "spec": {
    "conversion": {
      "strategy": "None"
    },
    "group": "quota.openshift.io",
    "names": {
      "kind": "ClusterResourceQuota",
      "listKind": "ClusterResourceQuotaList",
      "plural": "clusterresourcequotas",
      "singular": "clusterresourcequota"
    },
    "scope": "Cluster",
    "subresources": {
      "status": {}
    },
    "validation": {
      "openAPIV3Schema": {
        "properties": {
          "apiVersion": {
            "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#resources",
            "type": "string"
          },
          "kind": {
            "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#types-kinds",
            "type": "string"
          },
          "metadata": {
            "description": "Standard object's metadata.",
            "type": "object"
          },
          "spec": {
            "description": "Spec defines the desired quota",
            "properties": {
              "quota": {
                "description": "Quota defines the desired quota",
                "type": "object"
              },
              "selector": {
                "description": "Selector is the selector used to match projects. It should only select active projects on the scale of dozens (though it can select many more less active projects).  These projects will contend on object creation through this resource.",
                "properties": {
                  "annotations": {
                    "description": "AnnotationSelector is used to select projects by annotation.",
                    "nullable": true,
                    "type": "object"
                  },
                  "labels": {
                    "description": "LabelSelector is used to select projects by label.",
                    "nullable": true,
                    "type": "object"
                  }
                },
                "type": "object"
              }
            },
            "type": "object"
          },
          "status": {
            "description": "Status defines the actual enforced quota and its current usage",
            "properties": {
              "namespaces": {
                "description": "Namespaces slices the usage by project.  This division allows for quick resolution of deletion reconciliation inside of a single project without requiring a recalculation across all projects.  This can be used to pull the deltas for a given project.",
                "items": {
                  "properties": {
                    "namespace": {
                      "description": "Namespace the project this status applies to",
                      "type": "string"
                    },
                    "status": {
                      "description": "Status indicates how many resources have been consumed by this project",
                      "type": "object"
                    }
                  },
                  "type": "object"
                },
                "nullable": true,
                "type": "array"
              },
              "total": {
                "description": "Total defines the actual enforced quota and its current usage across all projects",
                "type": "object"
              }
            },
            "type": "object"
          }
        }
      }
    },
    "version": "v1",
    "versions": [
      {
        "name": "v1",
        "served": true,
        "storage": true
      }
    ]
  }
}

---

{
  "metadata": {
    "name": "clusterserviceversions.operators.coreos.com"
  },
  "apiVersion": "apiextensions.k8s.io/v1beta1",
  "kind": "CustomResourceDefinition",
  "spec": {
    "additionalPrinterColumns": [
      {
        "JSONPath": ".spec.displayName",
        "description": "The name of the CSV",
        "name": "Display",
        "type": "string"
      },
      {
        "JSONPath": ".spec.version",
        "description": "The version of the CSV",
        "name": "Version",
        "type": "string"
      },
      {
        "JSONPath": ".spec.replaces",
        "description": "The name of a CSV that this one replaces",
        "name": "Replaces",
        "type": "string"
      },
      {
        "JSONPath": ".status.phase",
        "name": "Phase",
        "type": "string"
      }
    ],
    "conversion": {
      "strategy": "None"
    },
    "group": "operators.coreos.com",
    "names": {
      "categories": [
        "olm"
      ],
      "kind": "ClusterServiceVersion",
      "listKind": "ClusterServiceVersionList",
      "plural": "clusterserviceversions",
      "shortNames": [
        "csv",
        "csvs"
      ],
      "singular": "clusterserviceversion"
    },
    "scope": "Namespaced",
    "subresources": {
      "status": {}
    },
    "validation": {
      "openAPIV3Schema": {
        "description": "Represents an Operator that should be running on the cluster, including requirements and install strategy.",
        "properties": {
          "spec": {
            "description": "Spec for a ClusterServiceVersion",
            "properties": {
              "apiservicedefinitions": {
                "properties": {
                  "owned": {
                    "description": "What resources this operator is responsible for managing. No two running operators should manage the same resource.",
                    "items": {
                      "properties": {
                        "actionDescriptors": {
                          "items": {
                            "description": "A spec for actions that can be performed on instances of the API resource",
                            "properties": {
                              "description": {
                                "description": "A description of the action.",
                                "type": "string"
                              },
                              "displayName": {
                                "description": "A human-readable name for the action.",
                                "type": "string"
                              },
                              "path": {
                                "description": "A jsonpath indexing into the spec object on the API resource where the the spec value can be found.",
                                "type": "string"
                              },
                              "value": {
                                "description": "If present, the value of this action is the same for all instances of the API resource and can be found here instead of on the API resource."
                              },
                              "x-descriptors": {
                                "description": "A list of descriptors for the action that indicate the meaning of the action.",
                                "items": {
                                  "type": "string"
                                },
                                "type": "array"
                              }
                            },
                            "required": [
                              "path",
                              "displayName",
                              "description"
                            ],
                            "type": "object"
                          },
                          "type": "array"
                        },
                        "containerPort": {
                          "description": "Port where the extension api-server serves TLS traffic",
                          "type": "number"
                        },
                        "deploymentName": {
                          "description": "Name of the extension api-server's deployment",
                          "type": "string"
                        },
                        "description": {
                          "description": "A description of the APIService",
                          "type": "string"
                        },
                        "displayName": {
                          "description": "A human-readable name for the APIService.",
                          "type": "string"
                        },
                        "group": {
                          "description": "Group of the APIService (e.g. app.coreos.com)",
                          "type": "string"
                        },
                        "kind": {
                          "description": "The kind field of the APIService",
                          "type": "string"
                        },
                        "name": {
                          "description": "The plural name for the APIService provided",
                          "type": "string"
                        },
                        "resources": {
                          "items": {
                            "description": "A list of resources that should be displayed for the APIService",
                            "properties": {
                              "kind": {
                                "description": "The kind field of the resource kind",
                                "type": "string"
                              },
                              "name": {
                                "description": "If a APIService, the fully qualified name of the APIService (e.g. my-resource-v1.app.coreos.com)",
                                "type": "string"
                              },
                              "version": {
                                "description": "The version of the resource kind",
                                "type": "string"
                              }
                            },
                            "required": [
                              "kind",
                              "version"
                            ],
                            "type": "object"
                          },
                          "type": "array"
                        },
                        "specDescriptors": {
                          "items": {
                            "description": "A spec for a field in the spec block of the APIService resource.",
                            "properties": {
                              "description": {
                                "description": "A description of the spec entry.",
                                "type": "string"
                              },
                              "displayName": {
                                "description": "A human-readable name for the spec entry.",
                                "type": "string"
                              },
                              "path": {
                                "description": "A jsonpath indexing into the spec object on the API resource where the the spec value can be found.",
                                "type": "string"
                              },
                              "value": {
                                "description": "If present, the value of this spec is the same for all instances of the API Resource and can be found here instead of on the API resource."
                              },
                              "x-descriptors": {
                                "description": "A list of descriptors for the spec entry that indicate the meaning of the field.",
                                "items": {
                                  "type": "string"
                                },
                                "type": "array"
                              }
                            },
                            "required": [
                              "path",
                              "displayName",
                              "description"
                            ],
                            "type": "object"
                          },
                          "type": "array"
                        },
                        "statusDescriptors": {
                          "items": {
                            "description": "A spec for a field in the status block of the API resource",
                            "properties": {
                              "description": {
                                "description": "A description of the status entry.",
                                "type": "string"
                              },
                              "displayName": {
                                "description": "A human-readable name for the status entry.",
                                "type": "string"
                              },
                              "path": {
                                "description": "A jsonpath indexing into the status object on the API resource where the the status value can be found.",
                                "type": "string"
                              },
                              "value": {
                                "description": "If present, the value of this status is the same for all instances of the API resource and can be found here instead of on the API resource."
                              },
                              "x-descriptors": {
                                "description": "A list of descriptors for the status entry that indicate the meaning of the field.",
                                "items": {
                                  "type": "string"
                                },
                                "type": "array"
                              }
                            },
                            "required": [
                              "path",
                              "displayName",
                              "description"
                            ],
                            "type": "object"
                          },
                          "type": "array"
                        },
                        "version": {
                          "description": "The version field of the APIService",
                          "type": "string"
                        }
                      },
                      "required": [
                        "group",
                        "version",
                        "kind",
                        "name",
                        "deploymentName",
                        "displayName",
                        "description"
                      ],
                      "type": "object"
                    },
                    "type": "array"
                  },
                  "required": {
                    "description": "What resources this operator is responsible for managing. No two running operators should manage the same resource.",
                    "items": {
                      "properties": {
                        "containerPort": {
                          "description": "Port where the extension api-server serves TLS traffic",
                          "type": "number"
                        },
                        "deploymentName": {
                          "description": "Name of the extension api-server's deployment",
                          "type": "string"
                        },
                        "description": {
                          "description": "A description of the APIService",
                          "type": "string"
                        },
                        "displayName": {
                          "description": "A human-readable name for the APIService.",
                          "type": "string"
                        },
                        "group": {
                          "description": "Group of the APIService (e.g. app.coreos.com)",
                          "type": "string"
                        },
                        "kind": {
                          "description": "The kind field of the APIService",
                          "type": "string"
                        },
                        "name": {
                          "description": "The plural name for the APIService provided",
                          "type": "string"
                        },
                        "statusDescriptors": {
                          "items": {
                            "description": "A spec for a field in the status block of the APIService",
                            "properties": {
                              "description": {
                                "description": "A description of the status entry.",
                                "type": "string"
                              },
                              "displayName": {
                                "description": "A human-readable name for the status entry.",
                                "type": "string"
                              },
                              "path": {
                                "description": "A jsonpath indexing into the status object on the API Resource where the the status value can be found.",
                                "type": "string"
                              },
                              "value": {
                                "description": "If present, the value of this status is the same for all instances of the API Resource and can be found here instead of on the API Resource."
                              },
                              "x-descriptors": {
                                "description": "A list of descriptors for the status entry that indicate the meaning of the field.",
                                "items": {
                                  "type": "string"
                                },
                                "type": "array"
                              }
                            },
                            "required": [
                              "path",
                              "displayName",
                              "description"
                            ],
                            "type": "object"
                          },
                          "type": "array"
                        },
                        "version": {
                          "description": "The version field of the APIService",
                          "type": "string"
                        }
                      },
                      "required": [
                        "group",
                        "version",
                        "kind",
                        "name",
                        "displayName",
                        "description"
                      ],
                      "type": "object"
                    },
                    "type": "array"
                  }
                },
                "type": "object"
              },
              "customresourcedefinitions": {
                "properties": {
                  "owned": {
                    "description": "What resources this operator is responsible for managing. No two running operators should manage the same resource.",
                    "items": {
                      "properties": {
                        "actionDescriptors": {
                          "items": {
                            "description": "A spec for actions that can be performed on instances of the CRD",
                            "properties": {
                              "description": {
                                "description": "A description of the action.",
                                "type": "string"
                              },
                              "displayName": {
                                "description": "A human-readable name for the action.",
                                "type": "string"
                              },
                              "path": {
                                "description": "A jsonpath indexing into the spec object on the CR where the the spec value can be found.",
                                "type": "string"
                              },
                              "value": {
                                "description": "If present, the value of this action is the same for all instances of the CRD and can be found here instead of on the CR."
                              },
                              "x-descriptors": {
                                "description": "A list of descriptors for the action that indicate the meaning of the action.",
                                "items": {
                                  "type": "string"
                                },
                                "type": "array"
                              }
                            },
                            "required": [
                              "path",
                              "displayName",
                              "description"
                            ],
                            "type": "object"
                          },
                          "type": "array"
                        },
                        "description": {
                          "description": "A description of the CRD",
                          "type": "string"
                        },
                        "displayName": {
                          "description": "A human-readable name for the CRD.",
                          "type": "string"
                        },
                        "kind": {
                          "description": "The kind field of the CustomResourceDefinition",
                          "type": "string"
                        },
                        "name": {
                          "description": "Fully qualified name of the CustomResourceDefinition (e.g. my-resource-v1.app.coreos.com)",
                          "type": "string"
                        },
                        "resources": {
                          "items": {
                            "description": "A list of resources that should be displayed for the CRD",
                            "properties": {
                              "kind": {
                                "description": "The kind field of the resource kind",
                                "type": "string"
                              },
                              "name": {
                                "description": "If a CRD, the fully qualified name of the CustomResourceDefinition (e.g. my-resource-v1.app.coreos.com)",
                                "type": "string"
                              },
                              "version": {
                                "description": "The version of the resource kind",
                                "type": "string"
                              }
                            },
                            "required": [
                              "kind",
                              "version"
                            ],
                            "type": "object"
                          },
                          "type": "array"
                        },
                        "specDescriptors": {
                          "items": {
                            "description": "A spec for a field in the spec block of the CRD",
                            "properties": {
                              "description": {
                                "description": "A description of the spec entry.",
                                "type": "string"
                              },
                              "displayName": {
                                "description": "A human-readable name for the spec entry.",
                                "type": "string"
                              },
                              "path": {
                                "description": "A jsonpath indexing into the spec object on the CR where the the spec value can be found.",
                                "type": "string"
                              },
                              "value": {
                                "description": "If present, the value of this spec is the same for all instances of the CRD and can be found here instead of on the CR."
                              },
                              "x-descriptors": {
                                "description": "A list of descriptors for the spec entry that indicate the meaning of the field.",
                                "items": {
                                  "type": "string"
                                },
                                "type": "array"
                              }
                            },
                            "required": [
                              "path",
                              "displayName",
                              "description"
                            ],
                            "type": "object"
                          },
                          "type": "array"
                        },
                        "statusDescriptors": {
                          "items": {
                            "description": "A spec for a field in the status block of the CRD",
                            "properties": {
                              "description": {
                                "description": "A description of the status entry.",
                                "type": "string"
                              },
                              "displayName": {
                                "description": "A human-readable name for the status entry.",
                                "type": "string"
                              },
                              "path": {
                                "description": "A jsonpath indexing into the status object on the CR where the the status value can be found.",
                                "type": "string"
                              },
                              "value": {
                                "description": "If present, the value of this status is the same for all instances of the CRD and can be found here instead of on the CR."
                              },
                              "x-descriptors": {
                                "description": "A list of descriptors for the status entry that indicate the meaning of the field.",
                                "items": {
                                  "type": "string"
                                },
                                "type": "array"
                              }
                            },
                            "required": [
                              "path",
                              "displayName",
                              "description"
                            ],
                            "type": "object"
                          },
                          "type": "array"
                        },
                        "version": {
                          "description": "The version field of the CustomResourceDefinition",
                          "type": "string"
                        }
                      },
                      "required": [
                        "name",
                        "version",
                        "kind",
                        "displayName",
                        "description"
                      ],
                      "type": "object"
                    },
                    "type": "array"
                  },
                  "required": {
                    "description": "What resources this operator is responsible for managing. No two running operators should manage the same resource.",
                    "items": {
                      "properties": {
                        "description": {
                          "description": "A description of the CRD",
                          "type": "string"
                        },
                        "displayName": {
                          "description": "A human-readable name for the CRD.",
                          "type": "string"
                        },
                        "kind": {
                          "description": "The kind field of the CustomResourceDefinition",
                          "type": "string"
                        },
                        "name": {
                          "description": "Fully qualified name of the CustomResourceDefinition (e.g. my-resource-v1.app.coreos.com)",
                          "type": "string"
                        },
                        "statusDescriptors": {
                          "items": {
                            "description": "A spec for a field in the status block of the CRD",
                            "properties": {
                              "description": {
                                "description": "A description of the status entry.",
                                "type": "string"
                              },
                              "displayName": {
                                "description": "A human-readable name for the status entry.",
                                "type": "string"
                              },
                              "path": {
                                "description": "A jsonpath indexing into the status object on the CR where the the status value can be found.",
                                "type": "string"
                              },
                              "value": {
                                "description": "If present, the value of this status is the same for all instances of the CRD and can be found here instead of on the CR."
                              },
                              "x-descriptors": {
                                "description": "A list of descriptors for the status entry that indicate the meaning of the field.",
                                "items": {
                                  "type": "string"
                                },
                                "type": "array"
                              }
                            },
                            "required": [
                              "path",
                              "displayName",
                              "description"
                            ],
                            "type": "object"
                          },
                          "type": "array"
                        },
                        "version": {
                          "description": "The version field of the CustomResourceDefinition",
                          "type": "string"
                        }
                      },
                      "required": [
                        "name",
                        "version",
                        "kind",
                        "displayName",
                        "description"
                      ],
                      "type": "object"
                    },
                    "type": "array"
                  }
                },
                "type": "object"
              },
              "description": {
                "description": "Human readable description of what the application does",
                "type": "string"
              },
              "displayName": {
                "description": "Human readable name of the application that will be displayed in the ALM UI",
                "type": "string"
              },
              "icon": {
                "description": "Icon which should be rendered with the application information",
                "items": {
                  "properties": {
                    "base64data": {
                      "description": "Base64 binary representation of the icon image",
                      "type": "string"
                    },
                    "mediatype": {
                      "description": "Mediatype for the binary data specified in the base64data property",
                      "enum": [
                        "image/gif",
                        "image/jpeg",
                        "image/png",
                        "image/svg+xml"
                      ],
                      "type": "string"
                    }
                  },
                  "required": [
                    "base64data",
                    "mediatype"
                  ],
                  "type": "object"
                },
                "type": "array"
              },
              "install": {
                "description": "Information required to install this specific version of the operator software",
                "oneOf": [
                  {
                    "properties": {
                      "spec": {
                        "properties": {
                          "image": {
                            "type": "string"
                          }
                        },
                        "required": [
                          "image"
                        ],
                        "type": "object"
                      },
                      "strategy": {
                        "enum": [
                          "image"
                        ],
                        "type": "string"
                      }
                    },
                    "required": [
                      "strategy",
                      "spec"
                    ],
                    "type": "object"
                  },
                  {
                    "properties": {
                      "spec": {
                        "properties": {
                          "clusterPermissions": {
                            "description": "Cluster permissions needed by the deployment to run correctly",
                            "items": {
                              "properties": {
                                "rules": {
                                  "items": {
                                    "description": "a rule required by the service account",
                                    "properties": {
                                      "apiGroups": {
                                        "description": "apiGroups the rule applies to",
                                        "items": {
                                          "type": "string"
                                        },
                                        "type": "array"
                                      },
                                      "nonResourceURLs": {
                                        "items": {
                                          "type": "string"
                                        },
                                        "type": "array"
                                      },
                                      "resourceNames": {
                                        "items": {
                                          "type": "string"
                                        },
                                        "type": "array"
                                      },
                                      "resources": {
                                        "items": {
                                          "type": "string"
                                        },
                                        "type": "array"
                                      },
                                      "verbs": {
                                        "items": {
                                          "enum": [
                                            "*",
                                            "assign",
                                            "get",
                                            "list",
                                            "watch",
                                            "create",
                                            "update",
                                            "patch",
                                            "put",
                                            "post",
                                            "delete",
                                            "deletecollection",
                                            "initialize",
                                            "use"
                                          ],
                                          "type": "string"
                                        },
                                        "type": "array"
                                      }
                                    },
                                    "required": [
                                      "verbs"
                                    ],
                                    "type": "object"
                                  },
                                  "type": "array"
                                },
                                "serviceAccountName": {
                                  "description": "The service account name to create for the deployment",
                                  "type": "string"
                                }
                              },
                              "required": [
                                "serviceAccountName",
                                "rules"
                              ],
                              "type": "object"
                            },
                            "type": "array"
                          },
                          "deployments": {
                            "description": "List of deployments to create",
                            "items": {
                              "description": "A name and deployment to create in the cluster",
                              "properties": {
                                "name": {
                                  "description": "the consistent name of the deployment",
                                  "type": "string"
                                },
                                "spec": {
                                  "description": "The deployment spec to create in the cluster",
                                  "type": "object"
                                }
                              },
                              "required": [
                                "name",
                                "spec"
                              ],
                              "type": "object"
                            },
                            "type": "array"
                          },
                          "installModes": {
                            "description": "List of supported install modes for the operator",
                            "items": {
                              "description": "A tuple representing a mode of installation and whether the operator supports it",
                              "properties": {
                                "supported": {
                                  "description": "Represents if the install mode type is supported",
                                  "type": "boolean"
                                },
                                "type": {
                                  "description": "A type of install mode",
                                  "enum": [
                                    "OwnNamespace",
                                    "SingleNamespace",
                                    "MultiNamespace",
                                    "AllNamespaces"
                                  ],
                                  "type": "string"
                                }
                              },
                              "required": [
                                "type",
                                "supported"
                              ],
                              "type": "object"
                            },
                            "type": "array"
                          },
                          "permissions": {
                            "description": "Permissions needed by the deployment to run correctly",
                            "items": {
                              "properties": {
                                "rules": {
                                  "items": {
                                    "description": "a rule required by the service account",
                                    "properties": {
                                      "apiGroups": {
                                        "description": "apiGroups the rule applies to",
                                        "items": {
                                          "type": "string"
                                        },
                                        "type": "array"
                                      },
                                      "resourceNames": {
                                        "items": {
                                          "type": "string"
                                        },
                                        "type": "array"
                                      },
                                      "resources": {
                                        "items": {
                                          "type": "string"
                                        },
                                        "type": "array"
                                      },
                                      "verbs": {
                                        "items": {
                                          "enum": [
                                            "*",
                                            "assign",
                                            "get",
                                            "list",
                                            "watch",
                                            "create",
                                            "update",
                                            "patch",
                                            "delete",
                                            "deletecollection",
                                            "initialize",
                                            "use"
                                          ],
                                          "type": "string"
                                        },
                                        "type": "array"
                                      }
                                    },
                                    "type": "object"
                                  },
                                  "type": "array"
                                },
                                "serviceAccountName": {
                                  "description": "The service account name to create for the deployment",
                                  "type": "string"
                                }
                              },
                              "required": [
                                "serviceAccountName",
                                "rules"
                              ],
                              "type": "object"
                            },
                            "type": "array"
                          }
                        },
                        "required": [
                          "deployments"
                        ],
                        "type": "object"
                      },
                      "strategy": {
                        "enum": [
                          "deployment"
                        ],
                        "type": "string"
                      }
                    },
                    "required": [
                      "strategy",
                      "spec"
                    ],
                    "type": "object"
                  }
                ],
                "type": "object"
              },
              "keywords": {
                "description": "List of keywords which will be used to discover and categorize app types",
                "items": {
                  "type": "string"
                },
                "type": "array"
              },
              "labels": {
                "description": "Labels that will be applied to associated resources created by the operator.",
                "type": "object"
              },
              "links": {
                "description": "Interesting links to find more information about the project, such as marketing page, documentation, or github page",
                "items": {
                  "description": "A single link to describe one aspect of the project",
                  "properties": {
                    "name": {
                      "description": "Name of the link type, e.g. homepage or github url",
                      "type": "string"
                    },
                    "url": {
                      "description": "URL to which the link should point",
                      "format": "uri",
                      "type": "string"
                    }
                  },
                  "required": [
                    "name",
                    "url"
                  ],
                  "type": "object"
                },
                "type": "array"
              },
              "maintainers": {
                "description": "Those responsible for the creation of this specific app type",
                "items": {
                  "description": "Information for a single maintainer",
                  "properties": {
                    "email": {
                      "description": "Maintainer's email address",
                      "format": "email",
                      "type": "string"
                    },
                    "name": {
                      "description": "Maintainer's name",
                      "type": "string"
                    }
                  },
                  "required": [
                    "name",
                    "email"
                  ],
                  "type": "object"
                },
                "type": "array"
              },
              "maturity": {
                "description": "What level of maturity the software has achieved at this version",
                "enum": [
                  "planning",
                  "pre-alpha",
                  "alpha",
                  "beta",
                  "stable",
                  "mature",
                  "inactive",
                  "deprecated"
                ],
                "type": "string"
              },
              "minKubeVersion": {
                "description": "Minimum kubernetes version requirement on the server to deploy operator",
                "pattern": "^\\bv?(0|[1-9]\\d*)\\.(0|[1-9]\\d*)\\.(0|[1-9]\\d*)(-(0|[1-9]\\d*|\\d*[a-zA-Z-][0-9a-zA-Z-]*)(\\.(0|[1-9]\\d*|\\d*[a-zA-Z-][0-9a-zA-Z-]*))*)?(\\+[0-9a-zA-Z-]+(\\.[0-9a-zA-Z-]+)*)?$",
                "type": "string"
              },
              "nativeAPIs": {
                "description": "What resources are required by the Operator, but must be provided by the underlying cluster and not as an extension.",
                "items": {
                  "properties": {
                    "group": {
                      "description": "Group of the API resource",
                      "type": "string"
                    },
                    "kind": {
                      "description": "Kind of the API resource",
                      "type": "string"
                    },
                    "version": {
                      "description": "Version of the API resource",
                      "type": "string"
                    }
                  },
                  "required": [
                    "group",
                    "version",
                    "kind"
                  ],
                  "type": "object"
                },
                "type": "array"
              },
              "replaces": {
                "description": "Name of the ClusterServiceVersion custom resource that this version replaces",
                "type": "string"
              },
              "selector": {
                "description": "Label selector to find resources associated with or managed by the operator",
                "properties": {
                  "matchExpressions": {
                    "description": "A set of expressions to match against the resource.",
                    "items": {
                      "allOf": [
                        {
                          "properties": {
                            "key": {
                              "description": "the key to match",
                              "type": "string"
                            },
                            "operator": {
                              "description": "the operator for the expression",
                              "enum": [
                                "In",
                                "NotIn",
                                "Exists",
                                "DoesNotExist"
                              ],
                              "type": "string"
                            },
                            "values": {
                              "description": "set of values for the expression",
                              "type": "array"
                            }
                          },
                          "required": [
                            "key",
                            "operator",
                            "values"
                          ],
                          "type": "object"
                        }
                      ]
                    },
                    "type": "array"
                  },
                  "matchLabels": {
                    "description": "Label key:value pairs to match directly",
                    "type": "object"
                  }
                },
                "type": "object"
              },
              "version": {
                "description": "Version string, recommended that users use semantic versioning",
                "pattern": "^(0|[1-9]\\d*)\\.(0|[1-9]\\d*)\\.(0|[1-9]\\d*)(-(0|[1-9]\\d*|\\d*[a-zA-Z-][0-9a-zA-Z-]*)(\\.(0|[1-9]\\d*|\\d*[a-zA-Z-][0-9a-zA-Z-]*))*)?(\\+[0-9a-zA-Z-]+(\\.[0-9a-zA-Z-]+)*)?$",
                "type": "string"
              }
            },
            "required": [
              "displayName",
              "install"
            ],
            "type": "object"
          },
          "status": {
            "description": "Status for a ClusterServiceVersion",
            "type": "object"
          }
        }
      }
    },
    "version": "v1alpha1",
    "versions": [
      {
        "name": "v1alpha1",
        "served": true,
        "storage": true
      }
    ]
  }
}

---

{
  "metadata": {
    "name": "clusterversions.config.openshift.io"
  },
  "apiVersion": "apiextensions.k8s.io/v1beta1",
  "kind": "CustomResourceDefinition",
  "spec": {
    "additionalPrinterColumns": [
      {
        "JSONPath": ".status.history[?(@.state==\"Completed\")].version",
        "name": "Version",
        "type": "string"
      },
      {
        "JSONPath": ".status.conditions[?(@.type==\"Available\")].status",
        "name": "Available",
        "type": "string"
      },
      {
        "JSONPath": ".status.conditions[?(@.type==\"Progressing\")].status",
        "name": "Progressing",
        "type": "string"
      },
      {
        "JSONPath": ".status.conditions[?(@.type==\"Progressing\")].lastTransitionTime",
        "name": "Since",
        "type": "date"
      },
      {
        "JSONPath": ".status.conditions[?(@.type==\"Progressing\")].message",
        "name": "Status",
        "type": "string"
      }
    ],
    "conversion": {
      "strategy": "None"
    },
    "group": "config.openshift.io",
    "names": {
      "kind": "ClusterVersion",
      "listKind": "ClusterVersionList",
      "plural": "clusterversions",
      "singular": "clusterversion"
    },
    "scope": "Cluster",
    "subresources": {
      "status": {}
    },
    "validation": {
      "openAPIV3Schema": {
        "properties": {
          "apiVersion": {
            "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#resources",
            "type": "string"
          },
          "kind": {
            "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#types-kinds",
            "type": "string"
          },
          "metadata": {
            "type": "object"
          },
          "spec": {
            "description": "spec is the desired state of the cluster version - the operator will work to ensure that the desired version is applied to the cluster.",
            "properties": {
              "channel": {
                "description": "channel is an identifier for explicitly requesting that a non-default set of updates be applied to this cluster. The default channel will be contain stable updates that are appropriate for production clusters.",
                "type": "string"
              },
              "clusterID": {
                "description": "clusterID uniquely identifies this cluster. This is expected to be an RFC4122 UUID value (xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx in hexadecimal values). This is a required field.",
                "type": "string"
              },
              "desiredUpdate": {
                "description": "desiredUpdate is an optional field that indicates the desired value of the cluster version. Setting this value will trigger an upgrade (if the current version does not match the desired version). The set of recommended update values is listed as part of available updates in status, and setting values outside that range may cause the upgrade to fail. You may specify the version field without setting image if an update exists with that version in the availableUpdates or history.  If an upgrade fails the operator will halt and report status about the failing component. Setting the desired update value back to the previous version will cause a rollback to be attempted. Not all rollbacks will succeed.",
                "properties": {
                  "force": {
                    "description": "force allows an administrator to update to an image that has failed verification, does not appear in the availableUpdates list, or otherwise would be blocked by normal protections on update. This option should only be used when the authenticity of the provided image has been verified out of band because the provided image will run with full administrative access to the cluster. Do not use this flag with images that comes from unknown or potentially malicious sources.  This flag does not override other forms of consistency checking that are required before a new update is deployed.",
                    "type": "boolean"
                  },
                  "image": {
                    "description": "image is a container image location that contains the update. When this field is part of spec, image is optional if version is specified and the availableUpdates field contains a matching version.",
                    "type": "string"
                  },
                  "version": {
                    "description": "version is a semantic versioning identifying the update version. When this field is part of spec, version is optional if image is specified.",
                    "type": "string"
                  }
                },
                "type": "object"
              },
              "overrides": {
                "description": "overrides is list of overrides for components that are managed by cluster version operator. Marking a component unmanaged will prevent the operator from creating or updating the object.",
                "items": {
                  "properties": {
                    "group": {
                      "description": "group identifies the API group that the kind is in.",
                      "type": "string"
                    },
                    "kind": {
                      "description": "kind identifies which object to override.",
                      "type": "string"
                    },
                    "name": {
                      "description": "name is the component's name.",
                      "type": "string"
                    },
                    "namespace": {
                      "description": "namespace is the component's namespace. If the resource is cluster scoped, the namespace should be empty.",
                      "type": "string"
                    },
                    "unmanaged": {
                      "description": "unmanaged controls if cluster version operator should stop managing the resources in this cluster. Default: false",
                      "type": "boolean"
                    }
                  },
                  "type": "object"
                },
                "type": "array"
              },
              "upstream": {
                "description": "upstream may be used to specify the preferred update server. By default it will use the appropriate update server for the cluster and region.",
                "type": "string"
              }
            },
            "type": "object"
          },
          "status": {
            "description": "status contains information about the available updates and any in-progress updates.",
            "properties": {
              "availableUpdates": {
                "description": "availableUpdates contains the list of updates that are appropriate for this cluster. This list may be empty if no updates are recommended, if the update service is unavailable, or if an invalid channel has been specified.",
                "items": {
                  "properties": {
                    "force": {
                      "description": "force allows an administrator to update to an image that has failed verification, does not appear in the availableUpdates list, or otherwise would be blocked by normal protections on update. This option should only be used when the authenticity of the provided image has been verified out of band because the provided image will run with full administrative access to the cluster. Do not use this flag with images that comes from unknown or potentially malicious sources.  This flag does not override other forms of consistency checking that are required before a new update is deployed.",
                      "type": "boolean"
                    },
                    "image": {
                      "description": "image is a container image location that contains the update. When this field is part of spec, image is optional if version is specified and the availableUpdates field contains a matching version.",
                      "type": "string"
                    },
                    "version": {
                      "description": "version is a semantic versioning identifying the update version. When this field is part of spec, version is optional if image is specified.",
                      "type": "string"
                    }
                  },
                  "type": "object"
                },
                "nullable": true,
                "type": "array"
              },
              "conditions": {
                "description": "conditions provides information about the cluster version. The condition \"Available\" is set to true if the desiredUpdate has been reached. The condition \"Progressing\" is set to true if an update is being applied. The condition \"Degraded\" is set to true if an update is currently blocked by a temporary or permanent error. Conditions are only valid for the current desiredUpdate when metadata.generation is equal to status.generation.",
                "items": {
                  "properties": {
                    "lastTransitionTime": {
                      "description": "lastTransitionTime is the time of the last update to the current status object.",
                      "format": "date-time",
                      "type": "string"
                    },
                    "message": {
                      "description": "message provides additional information about the current condition. This is only to be consumed by humans.",
                      "type": "string"
                    },
                    "reason": {
                      "description": "reason is the reason for the condition's last transition.  Reasons are CamelCase",
                      "type": "string"
                    },
                    "status": {
                      "description": "status of the condition, one of True, False, Unknown.",
                      "type": "string"
                    },
                    "type": {
                      "description": "type specifies the state of the operator's reconciliation functionality.",
                      "type": "string"
                    }
                  },
                  "type": "object"
                },
                "type": "array"
              },
              "desired": {
                "description": "desired is the version that the cluster is reconciling towards. If the cluster is not yet fully initialized desired will be set with the information available, which may be an image or a tag.",
                "properties": {
                  "force": {
                    "description": "force allows an administrator to update to an image that has failed verification, does not appear in the availableUpdates list, or otherwise would be blocked by normal protections on update. This option should only be used when the authenticity of the provided image has been verified out of band because the provided image will run with full administrative access to the cluster. Do not use this flag with images that comes from unknown or potentially malicious sources.  This flag does not override other forms of consistency checking that are required before a new update is deployed.",
                    "type": "boolean"
                  },
                  "image": {
                    "description": "image is a container image location that contains the update. When this field is part of spec, image is optional if version is specified and the availableUpdates field contains a matching version.",
                    "type": "string"
                  },
                  "version": {
                    "description": "version is a semantic versioning identifying the update version. When this field is part of spec, version is optional if image is specified.",
                    "type": "string"
                  }
                },
                "type": "object"
              },
              "history": {
                "description": "history contains a list of the most recent versions applied to the cluster. This value may be empty during cluster startup, and then will be updated when a new update is being applied. The newest update is first in the list and it is ordered by recency. Updates in the history have state Completed if the rollout completed - if an update was failing or halfway applied the state will be Partial. Only a limited amount of update history is preserved.",
                "items": {
                  "properties": {
                    "completionTime": {
                      "description": "completionTime, if set, is when the update was fully applied. The update that is currently being applied will have a null completion time. Completion time will always be set for entries that are not the current update (usually to the started time of the next update).",
                      "format": "date-time",
                      "nullable": true,
                      "type": "string"
                    },
                    "image": {
                      "description": "image is a container image location that contains the update. This value is always populated.",
                      "type": "string"
                    },
                    "startedTime": {
                      "description": "startedTime is the time at which the update was started.",
                      "format": "date-time",
                      "type": "string"
                    },
                    "state": {
                      "description": "state reflects whether the update was fully applied. The Partial state indicates the update is not fully applied, while the Completed state indicates the update was successfully rolled out at least once (all parts of the update successfully applied).",
                      "type": "string"
                    },
                    "verified": {
                      "description": "verified indicates whether the provided update was properly verified before it was installed. If this is false the cluster may not be trusted.",
                      "type": "boolean"
                    },
                    "version": {
                      "description": "version is a semantic versioning identifying the update version. If the requested image does not define a version, or if a failure occurs retrieving the image, this value may be empty.",
                      "type": "string"
                    }
                  },
                  "type": "object"
                },
                "type": "array"
              },
              "observedGeneration": {
                "description": "observedGeneration reports which version of the spec is being synced. If this value is not equal to metadata.generation, then the desired and conditions fields may represent from a previous version.",
                "format": "int64",
                "type": "integer"
              },
              "versionHash": {
                "description": "versionHash is a fingerprint of the content that the cluster will be updated with. It is used by the operator to avoid unnecessary work and is for internal use only.",
                "type": "string"
              }
            },
            "type": "object"
          }
        },
        "required": [
          "spec"
        ]
      }
    },
    "version": "v1",
    "versions": [
      {
        "name": "v1",
        "served": true,
        "storage": true
      }
    ]
  }
}

---

{
  "metadata": {
    "name": "configs.imageregistry.operator.openshift.io"
  },
  "apiVersion": "apiextensions.k8s.io/v1beta1",
  "kind": "CustomResourceDefinition",
  "spec": {
    "conversion": {
      "strategy": "None"
    },
    "group": "imageregistry.operator.openshift.io",
    "names": {
      "kind": "Config",
      "listKind": "ConfigList",
      "plural": "configs",
      "singular": "config"
    },
    "scope": "Cluster",
    "subresources": {
      "status": {}
    },
    "version": "v1",
    "versions": [
      {
        "name": "v1",
        "served": true,
        "storage": true
      }
    ]
  }
}

---

{
  "metadata": {
    "name": "configs.samples.operator.openshift.io"
  },
  "apiVersion": "apiextensions.k8s.io/v1beta1",
  "kind": "CustomResourceDefinition",
  "spec": {
    "conversion": {
      "strategy": "None"
    },
    "group": "samples.operator.openshift.io",
    "names": {
      "kind": "Config",
      "listKind": "ConfigList",
      "plural": "configs",
      "singular": "config"
    },
    "scope": "Cluster",
    "subresources": {
      "status": {}
    },
    "version": "v1",
    "versions": [
      {
        "name": "v1",
        "served": true,
        "storage": true
      }
    ]
  }
}

---

{
  "metadata": {
    "name": "consoles.config.openshift.io"
  },
  "apiVersion": "apiextensions.k8s.io/v1beta1",
  "kind": "CustomResourceDefinition",
  "spec": {
    "conversion": {
      "strategy": "None"
    },
    "group": "config.openshift.io",
    "names": {
      "kind": "Console",
      "listKind": "ConsoleList",
      "plural": "consoles",
      "singular": "console"
    },
    "scope": "Cluster",
    "subresources": {
      "status": {}
    },
    "validation": {
      "openAPIV3Schema": {
        "properties": {
          "apiVersion": {
            "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#resources",
            "type": "string"
          },
          "kind": {
            "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#types-kinds",
            "type": "string"
          },
          "metadata": {
            "description": "Standard object's metadata.",
            "type": "object"
          },
          "spec": {
            "description": "spec holds user settable values for configuration",
            "properties": {
              "authentication": {
                "properties": {
                  "logoutRedirect": {
                    "description": "An optional, absolute URL to redirect web browsers to after logging out of the console. If not specified, it will redirect to the default login page. This is required when using an identity provider that supports single sign-on (SSO) such as: - OpenID (Keycloak, Azure) - RequestHeader (GSSAPI, SSPI, SAML) - OAuth (GitHub, GitLab, Google) Logging out of the console will destroy the user's token. The logoutRedirect provides the user the option to perform single logout (SLO) through the identity provider to destroy their single sign-on session.",
                    "pattern": "^$|^((https):\\/\\/?)[^\\s()<>]+(?:\\([\\w\\d]+\\)|([^[:punct:]\\s]|\\/?))$",
                    "type": "string"
                  }
                },
                "type": "object"
              }
            },
            "type": "object"
          },
          "status": {
            "description": "status holds observed values from the cluster. They may not be overridden.",
            "properties": {
              "consoleURL": {
                "description": "The URL for the console. This will be derived from the host for the route that is created for the console.",
                "type": "string"
              }
            },
            "type": "object"
          }
        },
        "required": [
          "spec"
        ]
      }
    },
    "version": "v1",
    "versions": [
      {
        "name": "v1",
        "served": true,
        "storage": true
      }
    ]
  }
}

---

{
  "metadata": {
    "name": "consoles.operator.openshift.io"
  },
  "apiVersion": "apiextensions.k8s.io/v1beta1",
  "kind": "CustomResourceDefinition",
  "spec": {
    "conversion": {
      "strategy": "None"
    },
    "group": "operator.openshift.io",
    "names": {
      "kind": "Console",
      "listKind": "ConsoleList",
      "plural": "consoles",
      "singular": "console"
    },
    "scope": "Cluster",
    "subresources": {
      "status": {}
    },
    "validation": {
      "openAPIV3Schema": {
        "properties": {
          "spec": {
            "properties": {
              "customization": {
                "properties": {
                  "brand": {
                    "description": "Brand may be optionally set to one of six values - azure|dedicated|ocp|okd|online|origin",
                    "pattern": "^$|^(ocp|origin|okd|dedicated|online|azure)$",
                    "type": "string"
                  },
                  "documentationBaseURL": {
                    "description": "Documentation base url can optionally be set but must end in a trailing slash",
                    "pattern": "^$|^((https):\\/\\/?)[^\\s()<>]+(?:\\([\\w\\d]+\\)|([^[:punct:]\\s]|\\/?))\\/$",
                    "type": "string"
                  }
                }
              },
              "managementState": {
                "description": "ManagementState indicates whether and how the operator should manage the component",
                "pattern": "^(Managed|Unmanaged|Removed|Forced)$",
                "type": "string"
              }
            }
          }
        }
      }
    },
    "version": "v1",
    "versions": [
      {
        "name": "v1",
        "served": true,
        "storage": true
      }
    ]
  }
}

---

{
  "metadata": {
    "name": "containerruntimeconfigs.machineconfiguration.openshift.io"
  },
  "apiVersion": "apiextensions.k8s.io/v1beta1",
  "kind": "CustomResourceDefinition",
  "spec": {
    "conversion": {
      "strategy": "None"
    },
    "group": "machineconfiguration.openshift.io",
    "names": {
      "kind": "ContainerRuntimeConfig",
      "listKind": "ContainerRuntimeConfigList",
      "plural": "containerruntimeconfigs",
      "shortNames": [
        "ctrcfg"
      ],
      "singular": "containerruntimeconfig"
    },
    "scope": "Cluster",
    "subresources": {
      "status": {}
    },
    "version": "v1",
    "versions": [
      {
        "name": "v1",
        "served": true,
        "storage": true
      }
    ]
  }
}

---

{
  "metadata": {
    "name": "controllerconfigs.machineconfiguration.openshift.io"
  },
  "apiVersion": "apiextensions.k8s.io/v1beta1",
  "kind": "CustomResourceDefinition",
  "spec": {
    "conversion": {
      "strategy": "None"
    },
    "group": "machineconfiguration.openshift.io",
    "names": {
      "kind": "ControllerConfig",
      "listKind": "ControllerConfigList",
      "plural": "controllerconfigs",
      "singular": "controllerconfig"
    },
    "scope": "Cluster",
    "subresources": {
      "status": {}
    },
    "version": "v1",
    "versions": [
      {
        "name": "v1",
        "served": true,
        "storage": true
      }
    ]
  }
}

---

{
  "metadata": {
    "name": "credentialsrequests.cloudcredential.openshift.io"
  },
  "apiVersion": "apiextensions.k8s.io/v1beta1",
  "kind": "CustomResourceDefinition",
  "spec": {
    "conversion": {
      "strategy": "None"
    },
    "group": "cloudcredential.openshift.io",
    "names": {
      "kind": "CredentialsRequest",
      "listKind": "CredentialsRequestList",
      "plural": "credentialsrequests",
      "singular": "credentialsrequest"
    },
    "scope": "Namespaced",
    "subresources": {
      "status": {}
    },
    "validation": {
      "openAPIV3Schema": {
        "properties": {
          "apiVersion": {
            "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#resources",
            "type": "string"
          },
          "kind": {
            "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#types-kinds",
            "type": "string"
          },
          "metadata": {
            "type": "object"
          },
          "spec": {
            "properties": {
              "providerSpec": {
                "description": "ProviderSpec contains the cloud provider specific credentials specification.",
                "type": "object"
              },
              "secretRef": {
                "description": "SecretRef points to the secret where the credentials should be stored once generated.",
                "type": "object"
              }
            },
            "required": [
              "secretRef"
            ],
            "type": "object"
          },
          "status": {
            "properties": {
              "conditions": {
                "description": "Conditions includes detailed status for the CredentialsRequest",
                "items": {
                  "properties": {
                    "lastProbeTime": {
                      "description": "LastProbeTime is the last time we probed the condition",
                      "format": "date-time",
                      "type": "string"
                    },
                    "lastTransitionTime": {
                      "description": "LastTransitionTime is the last time the condition transitioned from one status to another.",
                      "format": "date-time",
                      "type": "string"
                    },
                    "message": {
                      "description": "Message is a human-readable message indicating details about the last transition",
                      "type": "string"
                    },
                    "reason": {
                      "description": "Reason is a unique, one-word, CamelCase reason for the condition's last transition",
                      "type": "string"
                    },
                    "status": {
                      "description": "Status is the status of the condition",
                      "type": "string"
                    },
                    "type": {
                      "description": "Type is the specific type of the condition",
                      "type": "string"
                    }
                  },
                  "required": [
                    "type",
                    "status"
                  ],
                  "type": "object"
                },
                "type": "array"
              },
              "lastSyncGeneration": {
                "description": "LastSyncGeneration is the generation of the credentials request resource that was last synced. Used to determine if the object has changed and requires a sync.",
                "format": "int64",
                "type": "integer"
              },
              "lastSyncTimestamp": {
                "description": "LastSyncTimestamp is the time that the credentials were last synced.",
                "format": "date-time",
                "type": "string"
              },
              "providerStatus": {
                "description": "ProviderStatus contains cloud provider specific status.",
                "type": "object"
              },
              "provisioned": {
                "description": "Provisioned is true once the credentials have been initially provisioned.",
                "type": "boolean"
              }
            },
            "required": [
              "provisioned",
              "lastSyncGeneration"
            ],
            "type": "object"
          }
        },
        "required": [
          "spec"
        ]
      }
    },
    "version": "v1",
    "versions": [
      {
        "name": "v1",
        "served": true,
        "storage": true
      }
    ]
  }
}

---

{
  "metadata": {
    "name": "dnses.config.openshift.io"
  },
  "apiVersion": "apiextensions.k8s.io/v1beta1",
  "kind": "CustomResourceDefinition",
  "spec": {
    "conversion": {
      "strategy": "None"
    },
    "group": "config.openshift.io",
    "names": {
      "kind": "DNS",
      "listKind": "DNSList",
      "plural": "dnses",
      "singular": "dns"
    },
    "scope": "Cluster",
    "validation": {
      "openAPIV3Schema": {
        "properties": {
          "apiVersion": {
            "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#resources",
            "type": "string"
          },
          "kind": {
            "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#types-kinds",
            "type": "string"
          },
          "metadata": {
            "description": "Standard object's metadata.",
            "type": "object"
          },
          "spec": {
            "description": "spec holds user settable values for configuration",
            "properties": {
              "baseDomain": {
                "description": "baseDomain is the base domain of the cluster. All managed DNS records will be sub-domains of this base.  For example, given the base domain `openshift.example.com`, an API server DNS record may be created for `cluster-api.openshift.example.com`.",
                "type": "string"
              },
              "privateZone": {
                "description": "privateZone is the location where all the DNS records that are only available internally to the cluster exist. If this field is nil, no private records should be created.",
                "properties": {
                  "id": {
                    "description": "id is the identifier that can be used to find the DNS hosted zone.  on AWS zone can be fetched using `ID` as id in [1] on Azure zone can be fetched using `ID` as a pre-determined name in [2], on GCP zone can be fetched using `ID` as a pre-determined name in [3].  [1]: https://docs.aws.amazon.com/cli/latest/reference/route53/get-hosted-zone.html#options [2]: https://docs.microsoft.com/en-us/cli/azure/network/dns/zone?view=azure-cli-latest#az-network-dns-zone-show [3]: https://cloud.google.com/dns/docs/reference/v1/managedZones/get",
                    "type": "string"
                  },
                  "tags": {
                    "description": "tags can be used to query the DNS hosted zone.  on AWS, resourcegroupstaggingapi [1] can be used to fetch a zone using `Tags` as tag-filters,  [1]: https://docs.aws.amazon.com/cli/latest/reference/resourcegroupstaggingapi/get-resources.html#options",
                    "type": "object"
                  }
                },
                "type": "object"
              },
              "publicZone": {
                "description": "publicZone is the location where all the DNS records that are publicly accessible to the internet exist. If this field is nil, no public records should be created.",
                "properties": {
                  "id": {
                    "description": "id is the identifier that can be used to find the DNS hosted zone.  on AWS zone can be fetched using `ID` as id in [1] on Azure zone can be fetched using `ID` as a pre-determined name in [2], on GCP zone can be fetched using `ID` as a pre-determined name in [3].  [1]: https://docs.aws.amazon.com/cli/latest/reference/route53/get-hosted-zone.html#options [2]: https://docs.microsoft.com/en-us/cli/azure/network/dns/zone?view=azure-cli-latest#az-network-dns-zone-show [3]: https://cloud.google.com/dns/docs/reference/v1/managedZones/get",
                    "type": "string"
                  },
                  "tags": {
                    "description": "tags can be used to query the DNS hosted zone.  on AWS, resourcegroupstaggingapi [1] can be used to fetch a zone using `Tags` as tag-filters,  [1]: https://docs.aws.amazon.com/cli/latest/reference/resourcegroupstaggingapi/get-resources.html#options",
                    "type": "object"
                  }
                },
                "type": "object"
              }
            },
            "type": "object"
          },
          "status": {
            "description": "status holds observed values from the cluster. They may not be overridden.",
            "type": "object"
          }
        },
        "required": [
          "spec"
        ]
      }
    },
    "version": "v1",
    "versions": [
      {
        "name": "v1",
        "served": true,
        "storage": true
      }
    ]
  }
}

---

{
  "metadata": {
    "name": "dnses.operator.openshift.io"
  },
  "apiVersion": "apiextensions.k8s.io/v1beta1",
  "kind": "CustomResourceDefinition",
  "spec": {
    "conversion": {
      "strategy": "None"
    },
    "group": "operator.openshift.io",
    "names": {
      "kind": "DNS",
      "listKind": "DNSList",
      "plural": "dnses",
      "singular": "dns"
    },
    "scope": "Cluster",
    "subresources": {
      "status": {}
    },
    "validation": {
      "openAPIV3Schema": {
        "properties": {
          "apiVersion": {
            "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#resources",
            "type": "string"
          },
          "kind": {
            "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#types-kinds",
            "type": "string"
          },
          "metadata": {
            "type": "object"
          },
          "spec": {
            "description": "spec is the specification of the desired behavior of the DNS.",
            "type": "object"
          },
          "status": {
            "description": "status is the most recently observed status of the DNS.",
            "properties": {
              "clusterDomain": {
                "description": "clusterDomain is the local cluster DNS domain suffix for DNS services. This will be a subdomain as defined in RFC 1034, section 3.5: https://tools.ietf.org/html/rfc1034#section-3.5 Example: \"cluster.local\"  More info: https://kubernetes.io/docs/concepts/services-networking/dns-pod-service",
                "type": "string"
              },
              "clusterIP": {
                "description": "clusterIP is the service IP through which this DNS is made available.  In the case of the default DNS, this will be a well known IP that is used as the default nameserver for pods that are using the default ClusterFirst DNS policy.  In general, this IP can be specified in a pod's spec.dnsConfig.nameservers list or used explicitly when performing name resolution from within the cluster. Example: dig foo.com @<service IP>  More info: https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies",
                "type": "string"
              },
              "conditions": {
                "description": "conditions provide information about the state of the DNS on the cluster.  These are the supported DNS conditions:    * Available   - True if the following conditions are met:     * DNS controller daemonset is available.   - False if any of those conditions are unsatisfied.  +patchMergeKey=type +patchStrategy=merge",
                "items": {
                  "properties": {
                    "lastTransitionTime": {
                      "format": "date-time",
                      "type": "string"
                    },
                    "message": {
                      "type": "string"
                    },
                    "reason": {
                      "type": "string"
                    },
                    "status": {
                      "type": "string"
                    },
                    "type": {
                      "type": "string"
                    }
                  },
                  "type": "object"
                },
                "type": "array"
              }
            },
            "type": "object"
          }
        }
      }
    },
    "version": "v1",
    "versions": [
      {
        "name": "v1",
        "served": true,
        "storage": true
      }
    ]
  }
}

---

{
  "metadata": {
    "name": "egressnetworkpolicies.network.openshift.io"
  },
  "apiVersion": "apiextensions.k8s.io/v1beta1",
  "kind": "CustomResourceDefinition",
  "spec": {
    "conversion": {
      "strategy": "None"
    },
    "group": "network.openshift.io",
    "names": {
      "kind": "EgressNetworkPolicy",
      "listKind": "EgressNetworkPolicyList",
      "plural": "egressnetworkpolicies",
      "singular": "egressnetworkpolicy"
    },
    "scope": "Namespaced",
    "validation": {
      "openAPIV3Schema": {
        "properties": {
          "spec": {
            "properties": {
              "egress": {
                "items": {
                  "properties": {
                    "to": {
                      "maxProperties": 1,
                      "minProperties": 1,
                      "properties": {
                        "cidrSelector": {
                          "pattern": "^(([0-9]|[0-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[0-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])/([0-9]|[12][0-9]|3[0-2])$",
                          "type": "string"
                        },
                        "dnsName": {
                          "pattern": "^([A-Za-z0-9-]+\\.)*[A-Za-z0-9-]+\\.?$",
                          "type": "string"
                        }
                      },
                      "type": "object"
                    },
                    "type": {
                      "pattern": "^Allow|Deny$",
                      "type": "string"
                    }
                  },
                  "type": "object"
                },
                "maxItems": 50,
                "type": "array"
              }
            },
            "type": "object"
          }
        }
      }
    },
    "version": "v1",
    "versions": [
      {
        "name": "v1",
        "served": true,
        "storage": true
      }
    ]
  }
}

---

{
  "metadata": {
    "name": "featuregates.config.openshift.io"
  },
  "apiVersion": "apiextensions.k8s.io/v1beta1",
  "kind": "CustomResourceDefinition",
  "spec": {
    "conversion": {
      "strategy": "None"
    },
    "group": "config.openshift.io",
    "names": {
      "kind": "FeatureGate",
      "listKind": "FeatureGateList",
      "plural": "featuregates",
      "singular": "featuregate"
    },
    "scope": "Cluster",
    "validation": {
      "openAPIV3Schema": {
        "properties": {
          "apiVersion": {
            "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#resources",
            "type": "string"
          },
          "kind": {
            "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#types-kinds",
            "type": "string"
          },
          "metadata": {
            "description": "Standard object's metadata.",
            "type": "object"
          },
          "spec": {
            "description": "spec holds user settable values for configuration",
            "properties": {
              "featureSet": {
                "description": "featureSet changes the list of features in the cluster.  The default is empty.  Be very careful adjusting this setting. Turning on or off features may cause irreversible changes in your cluster which cannot be undone.",
                "type": "string"
              }
            },
            "type": "object"
          },
          "status": {
            "description": "status holds observed values from the cluster. They may not be overridden.",
            "type": "object"
          }
        },
        "required": [
          "spec"
        ]
      }
    },
    "version": "v1",
    "versions": [
      {
        "name": "v1",
        "served": true,
        "storage": true
      }
    ]
  }
}

---

{
  "metadata": {
    "name": "hostsubnets.network.openshift.io"
  },
  "apiVersion": "apiextensions.k8s.io/v1beta1",
  "kind": "CustomResourceDefinition",
  "spec": {
    "additionalPrinterColumns": [
      {
        "JSONPath": ".host",
        "description": "The name of the node",
        "name": "Host",
        "type": "string"
      },
      {
        "JSONPath": ".hostIP",
        "description": "The IP address to be used as a VTEP by other nodes in the overlay network",
        "name": "Host IP",
        "type": "string"
      },
      {
        "JSONPath": ".subnet",
        "description": "The CIDR range of the overlay network assigned to the node for its pods",
        "name": "Subnet",
        "type": "string"
      }
    ],
    "conversion": {
      "strategy": "None"
    },
    "group": "network.openshift.io",
    "names": {
      "kind": "HostSubnet",
      "listKind": "HostSubnetList",
      "plural": "hostsubnets",
      "singular": "hostsubnet"
    },
    "scope": "Cluster",
    "validation": {
      "openAPIV3Schema": {
        "properties": {
          "egressCIDRs": {
            "items": {
              "pattern": "^(([0-9]|[0-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[0-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])/([0-9]|[12][0-9]|3[0-2])$",
              "type": "string"
            },
            "type": "array"
          },
          "egressIPs": {
            "items": {
              "pattern": "^(([0-9]|[0-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[0-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])$",
              "type": "string"
            },
            "type": "array"
          },
          "host": {
            "pattern": "^[a-z0-9.-]+$",
            "type": "string"
          },
          "hostIP": {
            "pattern": "^(([0-9]|[0-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[0-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])$",
            "type": "string"
          },
          "subnet": {
            "pattern": "^(([0-9]|[0-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[0-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])/([0-9]|[12][0-9]|3[0-2])$",
            "type": "string"
          }
        }
      }
    },
    "version": "v1",
    "versions": [
      {
        "name": "v1",
        "served": true,
        "storage": true
      }
    ]
  }
}

---

{
  "metadata": {
    "name": "images.config.openshift.io"
  },
  "apiVersion": "apiextensions.k8s.io/v1beta1",
  "kind": "CustomResourceDefinition",
  "spec": {
    "conversion": {
      "strategy": "None"
    },
    "group": "config.openshift.io",
    "names": {
      "kind": "Image",
      "listKind": "ImageList",
      "plural": "images",
      "singular": "image"
    },
    "scope": "Cluster",
    "subresources": {
      "status": {}
    },
    "validation": {
      "openAPIV3Schema": {
        "properties": {
          "apiVersion": {
            "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#resources",
            "type": "string"
          },
          "kind": {
            "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#types-kinds",
            "type": "string"
          },
          "metadata": {
            "description": "Standard object's metadata.",
            "type": "object"
          },
          "spec": {
            "description": "spec holds user settable values for configuration",
            "properties": {
              "additionalTrustedCA": {
                "description": "AdditionalTrustedCA is a reference to a ConfigMap containing additional CAs that should be trusted during imagestream import, pod image pull, and imageregistry pullthrough. The namespace for this config map is openshift-config.",
                "properties": {
                  "name": {
                    "description": "name is the metadata.name of the referenced config map",
                    "type": "string"
                  }
                },
                "type": "object"
              },
              "allowedRegistriesForImport": {
                "description": "AllowedRegistriesForImport limits the container image registries that normal users may import images from. Set this list to the registries that you trust to contain valid Docker images and that you want applications to be able to import from. Users with permission to create Images or ImageStreamMappings via the API are not affected by this policy - typically only administrators or system integrations will have those permissions.",
                "items": {
                  "properties": {
                    "domainName": {
                      "description": "DomainName specifies a domain name for the registry In case the registry use non-standard (80 or 443) port, the port should be included in the domain name as well.",
                      "type": "string"
                    },
                    "insecure": {
                      "description": "Insecure indicates whether the registry is secure (https) or insecure (http) By default (if not specified) the registry is assumed as secure.",
                      "type": "boolean"
                    }
                  },
                  "type": "object"
                },
                "type": "array"
              },
              "externalRegistryHostnames": {
                "description": "externalRegistryHostnames provides the hostnames for the default external image registry. The external hostname should be set only when the image registry is exposed externally. The first value is used in 'publicDockerImageRepository' field in ImageStreams. The value must be in \"hostname[:port]\" format.",
                "items": {
                  "type": "string"
                },
                "type": "array"
              },
              "registrySources": {
                "description": "RegistrySources contains configuration that determines how the container runtime should treat individual registries when accessing images for builds+pods. (e.g. whether or not to allow insecure access).  It does not contain configuration for the internal cluster registry.",
                "properties": {
                  "allowedRegistries": {
                    "description": "AllowedRegistries are whitelisted for image pull/push. All other registries are blocked.  Only one of BlockedRegistries or AllowedRegistries may be set.",
                    "items": {
                      "type": "string"
                    },
                    "type": "array"
                  },
                  "blockedRegistries": {
                    "description": "BlockedRegistries are blacklisted from image pull/push. All other registries are allowed.  Only one of BlockedRegistries or AllowedRegistries may be set.",
                    "items": {
                      "type": "string"
                    },
                    "type": "array"
                  },
                  "insecureRegistries": {
                    "description": "InsecureRegistries are registries which do not have a valid SSL certificate or only support HTTP connections.",
                    "items": {
                      "type": "string"
                    },
                    "type": "array"
                  }
                },
                "type": "object"
              }
            },
            "type": "object"
          },
          "status": {
            "description": "status holds observed values from the cluster. They may not be overridden.",
            "properties": {
              "externalRegistryHostnames": {
                "description": "externalRegistryHostnames provides the hostnames for the default external image registry. The external hostname should be set only when the image registry is exposed externally. The first value is used in 'publicDockerImageRepository' field in ImageStreams. The value must be in \"hostname[:port]\" format.",
                "items": {
                  "type": "string"
                },
                "type": "array"
              },
              "internalRegistryHostname": {
                "description": "this value is set by the image registry operator which controls the internal registry hostname InternalRegistryHostname sets the hostname for the default internal image registry. The value must be in \"hostname[:port]\" format. For backward compatibility, users can still use OPENSHIFT_DEFAULT_REGISTRY environment variable but this setting overrides the environment variable.",
                "type": "string"
              }
            },
            "type": "object"
          }
        },
        "required": [
          "spec"
        ]
      }
    },
    "version": "v1",
    "versions": [
      {
        "name": "v1",
        "served": true,
        "storage": true
      }
    ]
  }
}

---

{
  "metadata": {
    "name": "infrastructures.config.openshift.io"
  },
  "apiVersion": "apiextensions.k8s.io/v1beta1",
  "kind": "CustomResourceDefinition",
  "spec": {
    "conversion": {
      "strategy": "None"
    },
    "group": "config.openshift.io",
    "names": {
      "kind": "Infrastructure",
      "listKind": "InfrastructureList",
      "plural": "infrastructures",
      "singular": "infrastructure"
    },
    "scope": "Cluster",
    "validation": {
      "openAPIV3Schema": {
        "properties": {
          "apiVersion": {
            "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#resources",
            "type": "string"
          },
          "kind": {
            "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#types-kinds",
            "type": "string"
          },
          "metadata": {
            "description": "Standard object's metadata.",
            "type": "object"
          },
          "spec": {
            "description": "spec holds user settable values for configuration",
            "properties": {
              "cloudConfig": {
                "description": "cloudConfig is a reference to a ConfigMap containing the cloud provider configuration file. This configuration file is used to configure the Kubernetes cloud provider integration when using the built-in cloud provider integration or the external cloud controller manager. The namespace for this config map is openshift-config.",
                "properties": {
                  "key": {
                    "description": "Key allows pointing to a specific key/value inside of the configmap.  This is useful for logical file references.",
                    "type": "string"
                  },
                  "name": {
                    "type": "string"
                  }
                },
                "type": "object"
              }
            },
            "type": "object"
          },
          "status": {
            "description": "status holds observed values from the cluster. They may not be overridden.",
            "properties": {
              "apiServerURL": {
                "description": "apiServerURL is a valid URL with scheme(http/https), address and port. apiServerURL can be used by components like kubelet on machines, to contact the `apisever` using the infrastructure provider rather than the kubernetes networking.",
                "type": "string"
              },
              "etcdDiscoveryDomain": {
                "description": "etcdDiscoveryDomain is the domain used to fetch the SRV records for discovering etcd servers and clients. For more info: https://github.com/etcd-io/etcd/blob/329be66e8b3f9e2e6af83c123ff89297e49ebd15/Documentation/op-guide/clustering.md#dns-discovery",
                "type": "string"
              },
              "infrastructureName": {
                "description": "infrastructureName uniquely identifies a cluster with a human friendly name. Once set it should not be changed. Must be of max length 27 and must have only alphanumeric or hyphen characters.",
                "type": "string"
              },
              "platform": {
                "description": "platform is the underlying infrastructure provider for the cluster. This value controls whether infrastructure automation such as service load balancers, dynamic volume provisioning, machine creation and deletion, and other integrations are enabled. If None, no infrastructure automation is enabled. Allowed values are \"AWS\", \"Azure\", \"BareMetal\", \"GCP\", \"Libvirt\", \"OpenStack\", \"VSphere\", and \"None\". Individual components may not support all platforms, and must handle unrecognized platforms as None if they do not support that platform.",
                "type": "string"
              }
            },
            "type": "object"
          }
        },
        "required": [
          "spec"
        ]
      }
    },
    "version": "v1",
    "versions": [
      {
        "name": "v1",
        "served": true,
        "storage": true
      }
    ]
  }
}

---

{
  "metadata": {
    "name": "ingresscontrollers.operator.openshift.io"
  },
  "apiVersion": "apiextensions.k8s.io/v1beta1",
  "kind": "CustomResourceDefinition",
  "spec": {
    "conversion": {
      "strategy": "None"
    },
    "group": "operator.openshift.io",
    "names": {
      "kind": "IngressController",
      "listKind": "IngressControllerList",
      "plural": "ingresscontrollers",
      "singular": "ingresscontroller"
    },
    "scope": "Namespaced",
    "subresources": {
      "scale": {
        "labelSelectorPath": ".status.labelSelector",
        "specReplicasPath": ".spec.replicas",
        "statusReplicasPath": ".status.availableReplicas"
      },
      "status": {}
    },
    "validation": {
      "openAPIV3Schema": {
        "properties": {
          "apiVersion": {
            "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#resources",
            "type": "string"
          },
          "kind": {
            "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#types-kinds",
            "type": "string"
          },
          "metadata": {
            "type": "object"
          },
          "spec": {
            "description": "spec is the specification of the desired behavior of the IngressController.",
            "properties": {
              "defaultCertificate": {
                "description": "defaultCertificate is a reference to a secret containing the default certificate served by the ingress controller. When Routes don't specify their own certificate, defaultCertificate is used.  The secret must contain the following keys and data:    tls.crt: certificate file contents   tls.key: key file contents  If unset, a wildcard certificate is automatically generated and used. The certificate is valid for the ingress controller domain (and subdomains) and the generated certificate's CA will be automatically integrated with the cluster's trust store.  The in-use certificate (whether generated or user-specified) will be automatically integrated with OpenShift's built-in OAuth server.",
                "type": "object"
              },
              "domain": {
                "description": "domain is a DNS name serviced by the ingress controller and is used to configure multiple features:  * For the LoadBalancerService endpoint publishing strategy, domain is   used to configure DNS records. See endpointPublishingStrategy.  * When using a generated default certificate, the certificate will be valid   for domain and its subdomains. See defaultCertificate.  * The value is published to individual Route statuses so that end-users   know where to target external DNS records.  domain must be unique among all IngressControllers, and cannot be updated.  If empty, defaults to ingress.config.openshift.io/cluster .spec.domain.",
                "type": "string"
              },
              "endpointPublishingStrategy": {
                "description": "endpointPublishingStrategy is used to publish the ingress controller endpoints to other networks, enable load balancer integrations, etc.  If unset, the default is based on infrastructure.config.openshift.io/cluster .status.platform:    AWS:      LoadBalancerService   Libvirt:  HostNetwork  Any other platform types (including None) default to HostNetwork.  endpointPublishingStrategy cannot be updated.",
                "properties": {
                  "type": {
                    "description": "type is the publishing strategy to use. Valid values are:  * LoadBalancerService  Publishes the ingress controller using a Kubernetes LoadBalancer Service.  In this configuration, the ingress controller deployment uses container networking. A LoadBalancer Service is created to publish the deployment.  See: https://kubernetes.io/docs/concepts/services-networking/#loadbalancer  If domain is set, a wildcard DNS record will be managed to point at the LoadBalancer Service's external name. DNS records are managed only in DNS zones defined by dns.config.openshift.io/cluster .spec.publicZone and .spec.privateZone.  Wildcard DNS management is currently supported only on the AWS platform.  * HostNetwork  Publishes the ingress controller on node ports where the ingress controller is deployed.  In this configuration, the ingress controller deployment uses host networking, bound to node ports 80 and 443. The user is responsible for configuring an external load balancer to publish the ingress controller via the node ports.  * Private  Does not publish the ingress controller.  In this configuration, the ingress controller deployment uses container networking, and is not explicitly published. The user must manually publish the ingress controller.",
                    "type": "string"
                  }
                },
                "type": "object"
              },
              "namespaceSelector": {
                "description": "namespaceSelector is used to filter the set of namespaces serviced by the ingress controller. This is useful for implementing shards.  If unset, the default is no filtering.",
                "type": "object"
              },
              "nodePlacement": {
                "description": "nodePlacement enables explicit control over the scheduling of the ingress controller.  If unset, defaults are used. See NodePlacement for more details.",
                "properties": {
                  "nodeSelector": {
                    "description": "nodeSelector is the node selector applied to ingress controller deployments.  If unset, the default is:    beta.kubernetes.io/os: linux   node-role.kubernetes.io/worker: ''  If set, the specified selector is used and replaces the default.",
                    "type": "object"
                  },
                  "tolerations": {
                    "description": "tolerations is a list of tolerations applied to ingress controller deployments.  The default is an empty list.  See https://kubernetes.io/docs/concepts/configuration/taint-and-toleration/",
                    "items": {
                      "type": "object"
                    },
                    "type": "array"
                  }
                },
                "type": "object"
              },
              "replicas": {
                "description": "replicas is the desired number of ingress controller replicas. If unset, defaults to 2.",
                "format": "int32",
                "type": "integer"
              },
              "routeSelector": {
                "description": "routeSelector is used to filter the set of Routes serviced by the ingress controller. This is useful for implementing shards.  If unset, the default is no filtering.",
                "type": "object"
              }
            },
            "type": "object"
          },
          "status": {
            "description": "status is the most recently observed status of the IngressController.",
            "properties": {
              "availableReplicas": {
                "description": "availableReplicas is number of observed available replicas according to the ingress controller deployment.",
                "format": "int32",
                "type": "integer"
              },
              "conditions": {
                "description": "conditions is a list of conditions and their status.  Available means the ingress controller deployment is available and servicing route and ingress resources (i.e, .status.availableReplicas equals .spec.replicas)  There are additional conditions which indicate the status of other ingress controller features and capabilities.    * LoadBalancerManaged   - True if the following conditions are met:     * The endpoint publishing strategy requires a service load balancer.   - False if any of those conditions are unsatisfied.    * LoadBalancerReady   - True if the following conditions are met:     * A load balancer is managed.     * The load balancer is ready.   - False if any of those conditions are unsatisfied.    * DNSManaged   - True if the following conditions are met:     * The endpoint publishing strategy and platform support DNS.     * The ingress controller domain is set.     * dns.config.openshift.io/cluster configures DNS zones.   - False if any of those conditions are unsatisfied.    * DNSReady   - True if the following conditions are met:     * DNS is managed.     * DNS records have been successfully created.   - False if any of those conditions are unsatisfied.",
                "items": {
                  "properties": {
                    "lastTransitionTime": {
                      "format": "date-time",
                      "type": "string"
                    },
                    "message": {
                      "type": "string"
                    },
                    "reason": {
                      "type": "string"
                    },
                    "status": {
                      "type": "string"
                    },
                    "type": {
                      "type": "string"
                    }
                  },
                  "type": "object"
                },
                "type": "array"
              },
              "domain": {
                "description": "domain is the actual domain in use.",
                "type": "string"
              },
              "endpointPublishingStrategy": {
                "description": "endpointPublishingStrategy is the actual strategy in use.",
                "properties": {
                  "type": {
                    "description": "type is the publishing strategy to use. Valid values are:  * LoadBalancerService  Publishes the ingress controller using a Kubernetes LoadBalancer Service.  In this configuration, the ingress controller deployment uses container networking. A LoadBalancer Service is created to publish the deployment.  See: https://kubernetes.io/docs/concepts/services-networking/#loadbalancer  If domain is set, a wildcard DNS record will be managed to point at the LoadBalancer Service's external name. DNS records are managed only in DNS zones defined by dns.config.openshift.io/cluster .spec.publicZone and .spec.privateZone.  Wildcard DNS management is currently supported only on the AWS platform.  * HostNetwork  Publishes the ingress controller on node ports where the ingress controller is deployed.  In this configuration, the ingress controller deployment uses host networking, bound to node ports 80 and 443. The user is responsible for configuring an external load balancer to publish the ingress controller via the node ports.  * Private  Does not publish the ingress controller.  In this configuration, the ingress controller deployment uses container networking, and is not explicitly published. The user must manually publish the ingress controller.",
                    "type": "string"
                  }
                },
                "type": "object"
              },
              "selector": {
                "description": "selector is a label selector, in string format, for ingress controller pods corresponding to the IngressController. The number of matching pods should equal the value of availableReplicas.",
                "type": "string"
              }
            },
            "type": "object"
          }
        }
      }
    },
    "version": "v1",
    "versions": [
      {
        "name": "v1",
        "served": true,
        "storage": true
      }
    ]
  }
}

---

{
  "metadata": {
    "name": "ingresses.config.openshift.io"
  },
  "apiVersion": "apiextensions.k8s.io/v1beta1",
  "kind": "CustomResourceDefinition",
  "spec": {
    "conversion": {
      "strategy": "None"
    },
    "group": "config.openshift.io",
    "names": {
      "kind": "Ingress",
      "listKind": "IngressList",
      "plural": "ingresses",
      "singular": "ingress"
    },
    "scope": "Cluster",
    "validation": {
      "openAPIV3Schema": {
        "properties": {
          "apiVersion": {
            "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#resources",
            "type": "string"
          },
          "kind": {
            "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#types-kinds",
            "type": "string"
          },
          "metadata": {
            "description": "Standard object's metadata.",
            "type": "object"
          },
          "spec": {
            "description": "spec holds user settable values for configuration",
            "properties": {
              "domain": {
                "description": "domain is used to generate a default host name for a route when the route's host name is empty.  The generated host name will follow this pattern: \"<route-name>.<route-namespace>.<domain>\".",
                "type": "string"
              }
            },
            "type": "object"
          },
          "status": {
            "description": "status holds observed values from the cluster. They may not be overridden.",
            "type": "object"
          }
        },
        "required": [
          "spec"
        ]
      }
    },
    "version": "v1",
    "versions": [
      {
        "name": "v1",
        "served": true,
        "storage": true
      }
    ]
  }
}

---

{
  "metadata": {
    "name": "installplans.operators.coreos.com"
  },
  "apiVersion": "apiextensions.k8s.io/v1beta1",
  "kind": "CustomResourceDefinition",
  "spec": {
    "additionalPrinterColumns": [
      {
        "JSONPath": ".spec.clusterServiceVersionNames[0]",
        "description": "The first CSV in the list of clusterServiceVersionNames",
        "name": "CSV",
        "type": "string"
      },
      {
        "JSONPath": ".spec.source",
        "description": "The catalog source for the specified CSVs.",
        "name": "Source",
        "type": "string"
      },
      {
        "JSONPath": ".spec.approval",
        "description": "The approval mode",
        "name": "Approval",
        "type": "string"
      },
      {
        "JSONPath": ".spec.approved",
        "name": "Approved",
        "type": "boolean"
      }
    ],
    "conversion": {
      "strategy": "None"
    },
    "group": "operators.coreos.com",
    "names": {
      "categories": [
        "olm"
      ],
      "kind": "InstallPlan",
      "listKind": "InstallPlanList",
      "plural": "installplans",
      "shortNames": [
        "ip"
      ],
      "singular": "installplan"
    },
    "scope": "Namespaced",
    "subresources": {
      "status": {}
    },
    "validation": {
      "openAPIV3Schema": {
        "description": "Represents a plan to install and resolve dependencies for Cluster Services.",
        "properties": {
          "spec": {
            "anyOf": [
              {
                "properties": {
                  "approval": {
                    "enum": [
                      "Manual"
                    ]
                  },
                  "approved": {
                    "type": "boolean"
                  }
                },
                "required": [
                  "approved"
                ]
              },
              {
                "properties": {
                  "approval": {
                    "enum": [
                      "Automatic"
                    ]
                  }
                }
              }
            ],
            "description": "Spec for an InstallPlan",
            "properties": {
              "clusterServiceVersionNames": {
                "description": "A list of the names of the Cluster Services",
                "items": {
                  "type": "string"
                },
                "type": "array"
              },
              "source": {
                "description": "Name of the preferred CatalogSource",
                "type": "string"
              },
              "sourceNamespace": {
                "description": "Namespace that contains the preferred CatalogSource",
                "type": "string"
              }
            },
            "required": [
              "clusterServiceVersionNames",
              "approval"
            ],
            "type": "object"
          }
        }
      }
    },
    "version": "v1alpha1",
    "versions": [
      {
        "name": "v1alpha1",
        "served": true,
        "storage": true
      }
    ]
  }
}

---

{
  "metadata": {
    "name": "kubeapiservers.operator.openshift.io"
  },
  "apiVersion": "apiextensions.k8s.io/v1beta1",
  "kind": "CustomResourceDefinition",
  "spec": {
    "conversion": {
      "strategy": "None"
    },
    "group": "operator.openshift.io",
    "names": {
      "kind": "KubeAPIServer",
      "listKind": "KubeAPIServerList",
      "plural": "kubeapiservers",
      "singular": "kubeapiserver"
    },
    "scope": "Cluster",
    "subresources": {
      "status": {}
    },
    "validation": {
      "openAPIV3Schema": {
        "properties": {
          "apiVersion": {
            "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#resources",
            "type": "string"
          },
          "kind": {
            "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#types-kinds",
            "type": "string"
          },
          "metadata": {
            "type": "object"
          },
          "spec": {
            "properties": {
              "failedRevisionLimit": {
                "description": "failedRevisionLimit is the number of failed static pod installer revisions to keep on disk and in the api -1 = unlimited, 0 or unset = 5 (default)",
                "format": "int32",
                "type": "integer"
              },
              "forceRedeploymentReason": {
                "description": "forceRedeploymentReason can be used to force the redeployment of the operand by providing a unique string. This provides a mechanism to kick a previously failed deployment and provide a reason why you think it will work this time instead of failing again on the same config.",
                "type": "string"
              },
              "logLevel": {
                "description": "logLevel is an intent based logging for an overall component.  It does not give fine grained control, but it is a simple way to manage coarse grained logging choices that operators have to interpret for their operands.",
                "type": "string"
              },
              "managementState": {
                "description": "managementState indicates whether and how the operator should manage the component",
                "pattern": "^(Managed|Force)$",
                "type": "string"
              },
              "observedConfig": {
                "description": "observedConfig holds a sparse config that controller has observed from the cluster state.  It exists in spec because it is an input to the level for the operator",
                "nullable": true,
                "type": "object"
              },
              "operatorLogLevel": {
                "description": "operatorLogLevel is an intent based logging for the operator itself.  It does not give fine grained control, but it is a simple way to manage coarse grained logging choices that operators have to interpret for themselves.",
                "type": "string"
              },
              "succeededRevisionLimit": {
                "description": "succeededRevisionLimit is the number of successful static pod installer revisions to keep on disk and in the api -1 = unlimited, 0 or unset = 5 (default)",
                "format": "int32",
                "type": "integer"
              },
              "unsupportedConfigOverrides": {
                "description": "unsupportedConfigOverrides holds a sparse config that will override any previously set options.  It only needs to be the fields to override it will end up overlaying in the following order: 1. hardcoded defaults 2. observedConfig 3. unsupportedConfigOverrides",
                "nullable": true,
                "type": "object"
              }
            },
            "type": "object"
          },
          "status": {
            "properties": {
              "conditions": {
                "description": "conditions is a list of conditions and their status",
                "items": {
                  "properties": {
                    "lastTransitionTime": {
                      "format": "date-time",
                      "type": "string"
                    },
                    "message": {
                      "type": "string"
                    },
                    "reason": {
                      "type": "string"
                    },
                    "status": {
                      "type": "string"
                    },
                    "type": {
                      "type": "string"
                    }
                  },
                  "type": "object"
                },
                "type": "array"
              },
              "generations": {
                "description": "generations are used to determine when an item needs to be reconciled or has changed in a way that needs a reaction.",
                "items": {
                  "properties": {
                    "group": {
                      "description": "group is the group of the thing you're tracking",
                      "type": "string"
                    },
                    "hash": {
                      "description": "hash is an optional field set for resources without generation that are content sensitive like secrets and configmaps",
                      "type": "string"
                    },
                    "lastGeneration": {
                      "description": "lastGeneration is the last generation of the workload controller involved",
                      "format": "int64",
                      "type": "integer"
                    },
                    "name": {
                      "description": "name is the name of the thing you're tracking",
                      "type": "string"
                    },
                    "namespace": {
                      "description": "namespace is where the thing you're tracking is",
                      "type": "string"
                    },
                    "resource": {
                      "description": "resource is the resource type of the thing you're tracking",
                      "type": "string"
                    }
                  },
                  "type": "object"
                },
                "type": "array"
              },
              "latestAvailableRevision": {
                "description": "latestAvailableRevision is the deploymentID of the most recent deployment",
                "format": "int32",
                "type": "integer"
              },
              "nodeStatuses": {
                "description": "nodeStatuses track the deployment values and errors across individual nodes",
                "items": {
                  "properties": {
                    "currentRevision": {
                      "description": "currentRevision is the generation of the most recently successful deployment",
                      "format": "int32",
                      "type": "integer"
                    },
                    "lastFailedRevision": {
                      "description": "lastFailedRevision is the generation of the deployment we tried and failed to deploy.",
                      "format": "int32",
                      "type": "integer"
                    },
                    "lastFailedRevisionErrors": {
                      "description": "lastFailedRevisionErrors is a list of the errors during the failed deployment referenced in lastFailedRevision",
                      "items": {
                        "type": "string"
                      },
                      "type": "array"
                    },
                    "nodeName": {
                      "description": "nodeName is the name of the node",
                      "type": "string"
                    },
                    "targetRevision": {
                      "description": "targetRevision is the generation of the deployment we're trying to apply",
                      "format": "int32",
                      "type": "integer"
                    }
                  },
                  "type": "object"
                },
                "type": "array"
              },
              "observedGeneration": {
                "description": "observedGeneration is the last generation change you've dealt with",
                "format": "int64",
                "type": "integer"
              },
              "readyReplicas": {
                "description": "readyReplicas indicates how many replicas are ready and at the desired state",
                "format": "int32",
                "type": "integer"
              },
              "version": {
                "description": "version is the level this availability applies to",
                "type": "string"
              }
            },
            "type": "object"
          }
        },
        "required": [
          "spec"
        ]
      }
    },
    "version": "v1",
    "versions": [
      {
        "name": "v1",
        "served": true,
        "storage": true
      }
    ]
  }
}

---

{
  "metadata": {
    "name": "kubecontrollermanagers.operator.openshift.io"
  },
  "apiVersion": "apiextensions.k8s.io/v1beta1",
  "kind": "CustomResourceDefinition",
  "spec": {
    "conversion": {
      "strategy": "None"
    },
    "group": "operator.openshift.io",
    "names": {
      "categories": [
        "coreoperators"
      ],
      "kind": "KubeControllerManager",
      "listKind": "KubeControllerManagerList",
      "plural": "kubecontrollermanagers",
      "singular": "kubecontrollermanager"
    },
    "scope": "Cluster",
    "subresources": {
      "status": {}
    },
    "validation": {
      "openAPIV3Schema": {
        "properties": {
          "apiVersion": {
            "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#resources",
            "type": "string"
          },
          "kind": {
            "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#types-kinds",
            "type": "string"
          },
          "metadata": {
            "type": "object"
          },
          "spec": {
            "properties": {
              "failedRevisionLimit": {
                "description": "failedRevisionLimit is the number of failed static pod installer revisions to keep on disk and in the api -1 = unlimited, 0 or unset = 5 (default)",
                "format": "int32",
                "type": "integer"
              },
              "forceRedeploymentReason": {
                "description": "forceRedeploymentReason can be used to force the redeployment of the operand by providing a unique string. This provides a mechanism to kick a previously failed deployment and provide a reason why you think it will work this time instead of failing again on the same config.",
                "type": "string"
              },
              "logLevel": {
                "description": "logLevel is an intent based logging for an overall component.  It does not give fine grained control, but it is a simple way to manage coarse grained logging choices that operators have to interpret for their operands.",
                "type": "string"
              },
              "managementState": {
                "description": "managementState indicates whether and how the operator should manage the component",
                "pattern": "^(Managed|Unmanaged|Force|Removed)$",
                "type": "string"
              },
              "observedConfig": {
                "description": "observedConfig holds a sparse config that controller has observed from the cluster state.  It exists in spec because it is an input to the level for the operator",
                "nullable": true,
                "type": "object"
              },
              "operatorLogLevel": {
                "description": "operatorLogLevel is an intent based logging for the operator itself.  It does not give fine grained control, but it is a simple way to manage coarse grained logging choices that operators have to interpret for themselves.",
                "type": "string"
              },
              "succeededRevisionLimit": {
                "description": "succeededRevisionLimit is the number of successful static pod installer revisions to keep on disk and in the api -1 = unlimited, 0 or unset = 5 (default)",
                "format": "int32",
                "type": "integer"
              },
              "unsupportedConfigOverrides": {
                "description": "unsupportedConfigOverrides holds a sparse config that will override any previously set options.  It only needs to be the fields to override it will end up overlaying in the following order: 1. hardcoded defaults 2. observedConfig 3. unsupportedConfigOverrides",
                "nullable": true,
                "type": "object"
              }
            },
            "type": "object"
          },
          "status": {
            "properties": {
              "conditions": {
                "description": "conditions is a list of conditions and their status",
                "items": {
                  "properties": {
                    "lastTransitionTime": {
                      "format": "date-time",
                      "type": "string"
                    },
                    "message": {
                      "type": "string"
                    },
                    "reason": {
                      "type": "string"
                    },
                    "status": {
                      "type": "string"
                    },
                    "type": {
                      "type": "string"
                    }
                  },
                  "type": "object"
                },
                "type": "array"
              },
              "generations": {
                "description": "generations are used to determine when an item needs to be reconciled or has changed in a way that needs a reaction.",
                "items": {
                  "properties": {
                    "group": {
                      "description": "group is the group of the thing you're tracking",
                      "type": "string"
                    },
                    "hash": {
                      "description": "hash is an optional field set for resources without generation that are content sensitive like secrets and configmaps",
                      "type": "string"
                    },
                    "lastGeneration": {
                      "description": "lastGeneration is the last generation of the workload controller involved",
                      "format": "int64",
                      "type": "integer"
                    },
                    "name": {
                      "description": "name is the name of the thing you're tracking",
                      "type": "string"
                    },
                    "namespace": {
                      "description": "namespace is where the thing you're tracking is",
                      "type": "string"
                    },
                    "resource": {
                      "description": "resource is the resource type of the thing you're tracking",
                      "type": "string"
                    }
                  },
                  "type": "object"
                },
                "type": "array"
              },
              "latestAvailableRevision": {
                "description": "latestAvailableRevision is the deploymentID of the most recent deployment",
                "format": "int32",
                "type": "integer"
              },
              "nodeStatuses": {
                "description": "nodeStatuses track the deployment values and errors across individual nodes",
                "items": {
                  "properties": {
                    "currentRevision": {
                      "description": "currentRevision is the generation of the most recently successful deployment",
                      "format": "int32",
                      "type": "integer"
                    },
                    "lastFailedRevision": {
                      "description": "lastFailedRevision is the generation of the deployment we tried and failed to deploy.",
                      "format": "int32",
                      "type": "integer"
                    },
                    "lastFailedRevisionErrors": {
                      "description": "lastFailedRevisionErrors is a list of the errors during the failed deployment referenced in lastFailedRevision",
                      "items": {
                        "type": "string"
                      },
                      "type": "array"
                    },
                    "nodeName": {
                      "description": "nodeName is the name of the node",
                      "type": "string"
                    },
                    "targetRevision": {
                      "description": "targetRevision is the generation of the deployment we're trying to apply",
                      "format": "int32",
                      "type": "integer"
                    }
                  },
                  "type": "object"
                },
                "type": "array"
              },
              "observedGeneration": {
                "description": "observedGeneration is the last generation change you've dealt with",
                "format": "int64",
                "type": "integer"
              },
              "readyReplicas": {
                "description": "readyReplicas indicates how many replicas are ready and at the desired state",
                "format": "int32",
                "type": "integer"
              },
              "version": {
                "description": "version is the level this availability applies to",
                "type": "string"
              }
            },
            "type": "object"
          }
        },
        "required": [
          "spec"
        ]
      }
    },
    "version": "v1",
    "versions": [
      {
        "name": "v1",
        "served": true,
        "storage": true
      }
    ]
  }
}

---

{
  "metadata": {
    "name": "kubeletconfigs.machineconfiguration.openshift.io"
  },
  "apiVersion": "apiextensions.k8s.io/v1beta1",
  "kind": "CustomResourceDefinition",
  "spec": {
    "conversion": {
      "strategy": "None"
    },
    "group": "machineconfiguration.openshift.io",
    "names": {
      "kind": "KubeletConfig",
      "listKind": "KubeletConfigList",
      "plural": "kubeletconfigs",
      "singular": "kubeletconfig"
    },
    "scope": "Cluster",
    "subresources": {
      "status": {}
    },
    "version": "v1",
    "versions": [
      {
        "name": "v1",
        "served": true,
        "storage": true
      }
    ]
  }
}

---

{
  "metadata": {
    "name": "kubeschedulers.operator.openshift.io"
  },
  "apiVersion": "apiextensions.k8s.io/v1beta1",
  "kind": "CustomResourceDefinition",
  "spec": {
    "conversion": {
      "strategy": "None"
    },
    "group": "operator.openshift.io",
    "names": {
      "categories": [
        "coreoperators"
      ],
      "kind": "KubeScheduler",
      "listKind": "KubeSchedulerList",
      "plural": "kubeschedulers",
      "singular": "kubescheduler"
    },
    "scope": "Cluster",
    "subresources": {
      "status": {}
    },
    "validation": {
      "openAPIV3Schema": {
        "properties": {
          "apiVersion": {
            "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#resources",
            "type": "string"
          },
          "kind": {
            "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#types-kinds",
            "type": "string"
          },
          "metadata": {
            "type": "object"
          },
          "spec": {
            "properties": {
              "failedRevisionLimit": {
                "description": "failedRevisionLimit is the number of failed static pod installer revisions to keep on disk and in the api -1 = unlimited, 0 or unset = 5 (default)",
                "format": "int32",
                "type": "integer"
              },
              "forceRedeploymentReason": {
                "description": "forceRedeploymentReason can be used to force the redeployment of the operand by providing a unique string. This provides a mechanism to kick a previously failed deployment and provide a reason why you think it will work this time instead of failing again on the same config.",
                "type": "string"
              },
              "logLevel": {
                "description": "logLevel is an intent based logging for an overall component.  It does not give fine grained control, but it is a simple way to manage coarse grained logging choices that operators have to interpret for their operands.",
                "type": "string"
              },
              "managementState": {
                "description": "managementState indicates whether and how the operator should manage the component",
                "pattern": "^(Managed|Unmanaged|Force|Removed)$",
                "type": "string"
              },
              "observedConfig": {
                "description": "observedConfig holds a sparse config that controller has observed from the cluster state.  It exists in spec because it is an input to the level for the operator",
                "nullable": true,
                "type": "object"
              },
              "operatorLogLevel": {
                "description": "operatorLogLevel is an intent based logging for the operator itself.  It does not give fine grained control, but it is a simple way to manage coarse grained logging choices that operators have to interpret for themselves.",
                "type": "string"
              },
              "succeededRevisionLimit": {
                "description": "succeededRevisionLimit is the number of successful static pod installer revisions to keep on disk and in the api -1 = unlimited, 0 or unset = 5 (default)",
                "format": "int32",
                "type": "integer"
              },
              "unsupportedConfigOverrides": {
                "description": "unsupportedConfigOverrides holds a sparse config that will override any previously set options.  It only needs to be the fields to override it will end up overlaying in the following order: 1. hardcoded defaults 2. observedConfig 3. unsupportedConfigOverrides",
                "nullable": true,
                "type": "object"
              }
            },
            "type": "object"
          },
          "status": {
            "properties": {
              "conditions": {
                "description": "conditions is a list of conditions and their status",
                "items": {
                  "properties": {
                    "lastTransitionTime": {
                      "format": "date-time",
                      "type": "string"
                    },
                    "message": {
                      "type": "string"
                    },
                    "reason": {
                      "type": "string"
                    },
                    "status": {
                      "type": "string"
                    },
                    "type": {
                      "type": "string"
                    }
                  },
                  "type": "object"
                },
                "type": "array"
              },
              "generations": {
                "description": "generations are used to determine when an item needs to be reconciled or has changed in a way that needs a reaction.",
                "items": {
                  "properties": {
                    "group": {
                      "description": "group is the group of the thing you're tracking",
                      "type": "string"
                    },
                    "hash": {
                      "description": "hash is an optional field set for resources without generation that are content sensitive like secrets and configmaps",
                      "type": "string"
                    },
                    "lastGeneration": {
                      "description": "lastGeneration is the last generation of the workload controller involved",
                      "format": "int64",
                      "type": "integer"
                    },
                    "name": {
                      "description": "name is the name of the thing you're tracking",
                      "type": "string"
                    },
                    "namespace": {
                      "description": "namespace is where the thing you're tracking is",
                      "type": "string"
                    },
                    "resource": {
                      "description": "resource is the resource type of the thing you're tracking",
                      "type": "string"
                    }
                  },
                  "type": "object"
                },
                "type": "array"
              },
              "latestAvailableRevision": {
                "description": "latestAvailableRevision is the deploymentID of the most recent deployment",
                "format": "int32",
                "type": "integer"
              },
              "nodeStatuses": {
                "description": "nodeStatuses track the deployment values and errors across individual nodes",
                "items": {
                  "properties": {
                    "currentRevision": {
                      "description": "currentRevision is the generation of the most recently successful deployment",
                      "format": "int32",
                      "type": "integer"
                    },
                    "lastFailedRevision": {
                      "description": "lastFailedRevision is the generation of the deployment we tried and failed to deploy.",
                      "format": "int32",
                      "type": "integer"
                    },
                    "lastFailedRevisionErrors": {
                      "description": "lastFailedRevisionErrors is a list of the errors during the failed deployment referenced in lastFailedRevision",
                      "items": {
                        "type": "string"
                      },
                      "type": "array"
                    },
                    "nodeName": {
                      "description": "nodeName is the name of the node",
                      "type": "string"
                    },
                    "targetRevision": {
                      "description": "targetRevision is the generation of the deployment we're trying to apply",
                      "format": "int32",
                      "type": "integer"
                    }
                  },
                  "type": "object"
                },
                "type": "array"
              },
              "observedGeneration": {
                "description": "observedGeneration is the last generation change you've dealt with",
                "format": "int64",
                "type": "integer"
              },
              "readyReplicas": {
                "description": "readyReplicas indicates how many replicas are ready and at the desired state",
                "format": "int32",
                "type": "integer"
              },
              "version": {
                "description": "version is the level this availability applies to",
                "type": "string"
              }
            },
            "type": "object"
          }
        },
        "required": [
          "spec"
        ]
      }
    },
    "version": "v1",
    "versions": [
      {
        "name": "v1",
        "served": true,
        "storage": true
      }
    ]
  }
}

---

{
  "metadata": {
    "name": "machineautoscalers.autoscaling.openshift.io"
  },
  "apiVersion": "apiextensions.k8s.io/v1beta1",
  "kind": "CustomResourceDefinition",
  "spec": {
    "additionalPrinterColumns": [
      {
        "JSONPath": ".spec.scaleTargetRef.kind",
        "description": "Kind of object scaled",
        "name": "Ref Kind",
        "type": "string"
      },
      {
        "JSONPath": ".spec.scaleTargetRef.name",
        "description": "Name of object scaled",
        "name": "Ref Name",
        "type": "string"
      },
      {
        "JSONPath": ".spec.minReplicas",
        "description": "Min number of replicas",
        "name": "Min",
        "type": "integer"
      },
      {
        "JSONPath": ".spec.maxReplicas",
        "description": "Max number of replicas",
        "name": "Max",
        "type": "integer"
      },
      {
        "JSONPath": ".metadata.creationTimestamp",
        "name": "Age",
        "type": "date"
      }
    ],
    "conversion": {
      "strategy": "None"
    },
    "group": "autoscaling.openshift.io",
    "names": {
      "kind": "MachineAutoscaler",
      "listKind": "MachineAutoscalerList",
      "plural": "machineautoscalers",
      "singular": "machineautoscaler"
    },
    "scope": "Namespaced",
    "subresources": {
      "status": {}
    },
    "validation": {
      "openAPIV3Schema": {
        "properties": {
          "apiVersion": {
            "type": "string"
          },
          "kind": {
            "type": "string"
          },
          "metadata": {
            "type": "object"
          },
          "spec": {
            "properties": {
              "maxReplicas": {
                "format": "int32",
                "minimum": 1,
                "type": "integer"
              },
              "minReplicas": {
                "format": "int32",
                "minimum": 0,
                "type": "integer"
              },
              "scaleTargetRef": {
                "properties": {
                  "apiVersion": {
                    "type": "string"
                  },
                  "kind": {
                    "minLength": 1,
                    "type": "string"
                  },
                  "name": {
                    "minLength": 1,
                    "type": "string"
                  }
                },
                "required": [
                  "kind",
                  "name"
                ],
                "type": "object"
              }
            },
            "required": [
              "minReplicas",
              "maxReplicas",
              "scaleTargetRef"
            ],
            "type": "object"
          },
          "status": {
            "properties": {
              "lastTargetRef": {
                "properties": {
                  "apiVersion": {
                    "type": "string"
                  },
                  "kind": {
                    "minLength": 1,
                    "type": "string"
                  },
                  "name": {
                    "minLength": 1,
                    "type": "string"
                  }
                },
                "required": [
                  "kind",
                  "name"
                ],
                "type": "object"
              }
            },
            "type": "object"
          }
        }
      }
    },
    "version": "v1beta1",
    "versions": [
      {
        "name": "v1beta1",
        "served": true,
        "storage": true
      }
    ]
  }
}

---

{
  "metadata": {
    "name": "machineconfigpools.machineconfiguration.openshift.io"
  },
  "apiVersion": "apiextensions.k8s.io/v1beta1",
  "kind": "CustomResourceDefinition",
  "spec": {
    "additionalPrinterColumns": [
      {
        "JSONPath": ".status.configuration.name",
        "name": "Config",
        "type": "string"
      },
      {
        "JSONPath": ".status.conditions[?(@.type==\"Updated\")].status",
        "description": "When all the machines in the pool are updated to the correct machine config.",
        "name": "Updated",
        "type": "string"
      },
      {
        "JSONPath": ".status.conditions[?(@.type==\"Updating\")].status",
        "description": "When at least one of machine is not either not updated or is in the process of updating to the desired machine config.",
        "name": "Updating",
        "type": "string"
      },
      {
        "JSONPath": ".status.conditions[?(@.type==\"Degraded\")].status",
        "description": "When progress is blocked on updating one or more nodes, or the pool configuration is failing.",
        "name": "Degraded",
        "type": "string"
      }
    ],
    "conversion": {
      "strategy": "None"
    },
    "group": "machineconfiguration.openshift.io",
    "names": {
      "kind": "MachineConfigPool",
      "listKind": "MachineConfigPoolList",
      "plural": "machineconfigpools",
      "singular": "machineconfigpool"
    },
    "scope": "Cluster",
    "subresources": {
      "status": {}
    },
    "version": "v1",
    "versions": [
      {
        "name": "v1",
        "served": true,
        "storage": true
      }
    ]
  }
}

---

{
  "metadata": {
    "name": "machineconfigs.machineconfiguration.openshift.io"
  },
  "apiVersion": "apiextensions.k8s.io/v1beta1",
  "kind": "CustomResourceDefinition",
  "spec": {
    "additionalPrinterColumns": [
      {
        "JSONPath": ".metadata.annotations.machineconfiguration\\.openshift\\.io/generated-by-controller-version",
        "description": "Version of the controller that generated the machineconfig. This will be empty if the machineconfig is not managed by a controller.",
        "name": "GeneratedByController",
        "type": "string"
      },
      {
        "JSONPath": ".spec.config.ignition.version",
        "description": "Version of the Ignition Config defined in the machineconfig.",
        "name": "IgnitionVersion",
        "type": "string"
      },
      {
        "JSONPath": ".metadata.creationTimestamp",
        "name": "Created",
        "type": "date"
      }
    ],
    "conversion": {
      "strategy": "None"
    },
    "group": "machineconfiguration.openshift.io",
    "names": {
      "kind": "MachineConfig",
      "listKind": "MachineConfigList",
      "plural": "machineconfigs",
      "singular": "machineconfig"
    },
    "scope": "Cluster",
    "version": "v1",
    "versions": [
      {
        "name": "v1",
        "served": true,
        "storage": true
      }
    ]
  }
}

---

{
  "metadata": {
    "name": "machinehealthchecks.healthchecking.openshift.io"
  },
  "apiVersion": "apiextensions.k8s.io/v1beta1",
  "kind": "CustomResourceDefinition",
  "spec": {
    "conversion": {
      "strategy": "None"
    },
    "group": "healthchecking.openshift.io",
    "names": {
      "kind": "MachineHealthCheck",
      "listKind": "MachineHealthCheckList",
      "plural": "machinehealthchecks",
      "singular": "machinehealthcheck"
    },
    "scope": "Namespaced",
    "validation": {
      "openAPIV3Schema": {
        "properties": {
          "apiVersion": {
            "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#resources",
            "type": "string"
          },
          "kind": {
            "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#types-kinds",
            "type": "string"
          },
          "metadata": {
            "type": "object"
          },
          "spec": {
            "description": "Specification of machine health check policy",
            "properties": {
              "selector": {
                "description": "Label selector to match machines whose health will be exercised",
                "type": "object"
              }
            },
            "required": [
              "selector"
            ],
            "type": "object"
          },
          "status": {
            "description": "Most recently observed status of MachineHealthCheck resource",
            "type": "object"
          }
        }
      }
    },
    "version": "v1alpha1",
    "versions": [
      {
        "name": "v1alpha1",
        "served": true,
        "storage": true
      }
    ]
  }
}

---

{
  "metadata": {
    "name": "machines.machine.openshift.io"
  },
  "apiVersion": "apiextensions.k8s.io/v1beta1",
  "kind": "CustomResourceDefinition",
  "spec": {
    "additionalPrinterColumns": [
      {
        "JSONPath": ".status.providerStatus.instanceId",
        "description": "Instance ID of machine created in AWS",
        "name": "Instance",
        "type": "string"
      },
      {
        "JSONPath": ".status.providerStatus.instanceState",
        "description": "State of the AWS instance",
        "name": "State",
        "type": "string"
      },
      {
        "JSONPath": ".spec.providerSpec.value.instanceType",
        "description": "Type of instance",
        "name": "Type",
        "type": "string"
      },
      {
        "JSONPath": ".spec.providerSpec.value.placement.region",
        "description": "Region associated with machine",
        "name": "Region",
        "type": "string"
      },
      {
        "JSONPath": ".spec.providerSpec.value.placement.availabilityZone",
        "description": "Zone associated with machine",
        "name": "Zone",
        "type": "string"
      },
      {
        "JSONPath": ".metadata.creationTimestamp",
        "description": "Machine age",
        "name": "Age",
        "type": "date"
      }
    ],
    "conversion": {
      "strategy": "None"
    },
    "group": "machine.openshift.io",
    "names": {
      "kind": "Machine",
      "listKind": "MachineList",
      "plural": "machines",
      "singular": "machine"
    },
    "scope": "Namespaced",
    "subresources": {
      "status": {}
    },
    "validation": {
      "openAPIV3Schema": {
        "properties": {
          "apiVersion": {
            "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#resources",
            "type": "string"
          },
          "kind": {
            "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#types-kinds",
            "type": "string"
          },
          "metadata": {
            "type": "object"
          },
          "spec": {
            "properties": {
              "metadata": {
                "description": "ObjectMeta will autopopulate the Node created. Use this to indicate what labels, annotations, name prefix, etc., should be used when creating the Node.",
                "type": "object"
              },
              "providerID": {
                "description": "ProviderID is the identification ID of the machine provided by the provider. This field must match the provider ID as seen on the node object corresponding to this machine. This field is required by higher level consumers of cluster-api. Example use case is cluster autoscaler with cluster-api as provider. Clean-up login in the autoscaler compares machines v/s nodes to find out machines at provider which could not get registered as Kubernetes nodes. With cluster-api as a generic out-of-tree provider for autoscaler, this field is required by autoscaler to be able to have a provider view of the list of machines. Another list of nodes is queries from the k8s apiserver and then comparison is done to find out unregistered machines and are marked for delete. This field will be set by the actuators and consumed by higher level entities like autoscaler  who will be interfacing with cluster-api as generic provider.",
                "type": "string"
              },
              "providerSpec": {
                "description": "ProviderSpec details Provider-specific configuration to use during node creation.",
                "properties": {
                  "value": {
                    "description": "Value is an inlined, serialized representation of the resource configuration. It is recommended that providers maintain their own versioned API types that should be serialized/deserialized from this field, akin to component config.",
                    "type": "object"
                  }
                },
                "type": "object"
              },
              "taints": {
                "description": "Taints is the full, authoritative list of taints to apply to the corresponding Node. This list will overwrite any modifications made to the Node on an ongoing basis.",
                "items": {
                  "type": "object"
                },
                "type": "array"
              }
            },
            "required": [
              "providerSpec"
            ],
            "type": "object"
          },
          "status": {
            "properties": {
              "addresses": {
                "description": "Addresses is a list of addresses assigned to the machine. Queried from cloud provider, if available.",
                "items": {
                  "type": "object"
                },
                "type": "array"
              },
              "errorMessage": {
                "description": "ErrorMessage will be set in the event that there is a terminal problem reconciling the Machine and will contain a more verbose string suitable for logging and human consumption.  This field should not be set for transitive errors that a controller faces that are expected to be fixed automatically over time (like service outages), but instead indicate that something is fundamentally wrong with the Machine's spec or the configuration of the controller, and that manual intervention is required. Examples of terminal errors would be invalid combinations of settings in the spec, values that are unsupported by the controller, or the responsible controller itself being critically misconfigured.  Any transient errors that occur during the reconciliation of Machines can be added as events to the Machine object and/or logged in the controller's output.",
                "type": "string"
              },
              "errorReason": {
                "description": "ErrorReason will be set in the event that there is a terminal problem reconciling the Machine and will contain a succinct value suitable for machine interpretation.  This field should not be set for transitive errors that a controller faces that are expected to be fixed automatically over time (like service outages), but instead indicate that something is fundamentally wrong with the Machine's spec or the configuration of the controller, and that manual intervention is required. Examples of terminal errors would be invalid combinations of settings in the spec, values that are unsupported by the controller, or the responsible controller itself being critically misconfigured.  Any transient errors that occur during the reconciliation of Machines can be added as events to the Machine object and/or logged in the controller's output.",
                "type": "string"
              },
              "lastOperation": {
                "description": "LastOperation describes the last-operation performed by the machine-controller. This API should be useful as a history in terms of the latest operation performed on the specific machine. It should also convey the state of the latest-operation for example if it is still on-going, failed or completed successfully.",
                "properties": {
                  "description": {
                    "description": "Description is the human-readable description of the last operation.",
                    "type": "string"
                  },
                  "lastUpdated": {
                    "description": "LastUpdated is the timestamp at which LastOperation API was last-updated.",
                    "format": "date-time",
                    "type": "string"
                  },
                  "state": {
                    "description": "State is the current status of the last performed operation. E.g. Processing, Failed, Successful etc",
                    "type": "string"
                  },
                  "type": {
                    "description": "Type is the type of operation which was last performed. E.g. Create, Delete, Update etc",
                    "type": "string"
                  }
                },
                "type": "object"
              },
              "lastUpdated": {
                "description": "LastUpdated identifies when this status was last observed.",
                "format": "date-time",
                "type": "string"
              },
              "nodeRef": {
                "description": "NodeRef will point to the corresponding Node if it exists.",
                "type": "object"
              },
              "phase": {
                "description": "Phase represents the current phase of machine actuation. E.g. Pending, Running, Terminating, Failed etc.",
                "type": "string"
              },
              "providerStatus": {
                "description": "ProviderStatus details a Provider-specific status. It is recommended that providers maintain their own versioned API types that should be serialized/deserialized from this field.",
                "type": "object"
              }
            },
            "type": "object"
          }
        }
      }
    },
    "version": "v1beta1",
    "versions": [
      {
        "name": "v1beta1",
        "served": true,
        "storage": true
      }
    ]
  }
}

---

{
  "metadata": {
    "name": "machinesets.machine.openshift.io"
  },
  "apiVersion": "apiextensions.k8s.io/v1beta1",
  "kind": "CustomResourceDefinition",
  "spec": {
    "additionalPrinterColumns": [
      {
        "JSONPath": ".spec.replicas",
        "description": "Desired Replicas",
        "name": "Desired",
        "type": "integer"
      },
      {
        "JSONPath": ".status.replicas",
        "description": "Current Replicas",
        "name": "Current",
        "type": "integer"
      },
      {
        "JSONPath": ".status.readyReplicas",
        "description": "Ready Replicas",
        "name": "Ready",
        "type": "integer"
      },
      {
        "JSONPath": ".status.availableReplicas",
        "description": "Observed number of available replicas",
        "name": "Available",
        "type": "string"
      },
      {
        "JSONPath": ".metadata.creationTimestamp",
        "description": "Machineset age",
        "name": "Age",
        "type": "date"
      }
    ],
    "conversion": {
      "strategy": "None"
    },
    "group": "machine.openshift.io",
    "names": {
      "kind": "MachineSet",
      "listKind": "MachineSetList",
      "plural": "machinesets",
      "singular": "machineset"
    },
    "scope": "Namespaced",
    "subresources": {
      "scale": {
        "labelSelectorPath": ".status.labelSelector",
        "specReplicasPath": ".spec.replicas",
        "statusReplicasPath": ".status.replicas"
      },
      "status": {}
    },
    "validation": {
      "openAPIV3Schema": {
        "properties": {
          "apiVersion": {
            "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#resources",
            "type": "string"
          },
          "kind": {
            "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#types-kinds",
            "type": "string"
          },
          "metadata": {
            "type": "object"
          },
          "spec": {
            "properties": {
              "minReadySeconds": {
                "description": "MinReadySeconds is the minimum number of seconds for which a newly created machine should be ready. Defaults to 0 (machine will be considered available as soon as it is ready)",
                "format": "int32",
                "type": "integer"
              },
              "replicas": {
                "description": "Replicas is the number of desired replicas. This is a pointer to distinguish between explicit zero and unspecified. Defaults to 1.",
                "format": "int32",
                "type": "integer"
              },
              "selector": {
                "description": "Selector is a label query over machines that should match the replica count. Label keys and values that must match in order to be controlled by this MachineSet. It must match the machine template's labels. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/#label-selectors",
                "type": "object"
              },
              "template": {
                "description": "Template is the object that describes the machine that will be created if insufficient replicas are detected.",
                "properties": {
                  "metadata": {
                    "description": "Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#metadata",
                    "type": "object"
                  },
                  "spec": {
                    "description": "Specification of the desired behavior of the machine. More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#spec-and-status",
                    "properties": {
                      "metadata": {
                        "description": "ObjectMeta will autopopulate the Node created. Use this to indicate what labels, annotations, name prefix, etc., should be used when creating the Node.",
                        "type": "object"
                      },
                      "providerID": {
                        "description": "ProviderID is the identification ID of the machine provided by the provider. This field must match the provider ID as seen on the node object corresponding to this machine. This field is required by higher level consumers of cluster-api. Example use case is cluster autoscaler with cluster-api as provider. Clean-up login in the autoscaler compares machines v/s nodes to find out machines at provider which could not get registered as Kubernetes nodes. With cluster-api as a generic out-of-tree provider for autoscaler, this field is required by autoscaler to be able to have a provider view of the list of machines. Another list of nodes is queries from the k8s apiserver and then comparison is done to find out unregistered machines and are marked for delete. This field will be set by the actuators and consumed by higher level entities like autoscaler  who will be interfacing with cluster-api as generic provider.",
                        "type": "string"
                      },
                      "providerSpec": {
                        "description": "ProviderSpec details Provider-specific configuration to use during node creation.",
                        "properties": {
                          "value": {
                            "description": "Value is an inlined, serialized representation of the resource configuration. It is recommended that providers maintain their own versioned API types that should be serialized/deserialized from this field, akin to component config.",
                            "type": "object"
                          }
                        },
                        "type": "object"
                      },
                      "taints": {
                        "description": "Taints is the full, authoritative list of taints to apply to the corresponding Node. This list will overwrite any modifications made to the Node on an ongoing basis.",
                        "items": {
                          "type": "object"
                        },
                        "type": "array"
                      }
                    },
                    "required": [
                      "providerSpec"
                    ],
                    "type": "object"
                  }
                },
                "type": "object"
              }
            },
            "required": [
              "selector"
            ],
            "type": "object"
          },
          "status": {
            "properties": {
              "availableReplicas": {
                "description": "The number of available replicas (ready for at least minReadySeconds) for this MachineSet.",
                "format": "int32",
                "type": "integer"
              },
              "errorMessage": {
                "type": "string"
              },
              "errorReason": {
                "description": "In the event that there is a terminal problem reconciling the replicas, both ErrorReason and ErrorMessage will be set. ErrorReason will be populated with a succinct value suitable for machine interpretation, while ErrorMessage will contain a more verbose string suitable for logging and human consumption.  These fields should not be set for transitive errors that a controller faces that are expected to be fixed automatically over time (like service outages), but instead indicate that something is fundamentally wrong with the MachineTemplate's spec or the configuration of the machine controller, and that manual intervention is required. Examples of terminal errors would be invalid combinations of settings in the spec, values that are unsupported by the machine controller, or the responsible machine controller itself being critically misconfigured.  Any transient errors that occur during the reconciliation of Machines can be added as events to the MachineSet object and/or logged in the controller's output.",
                "type": "string"
              },
              "fullyLabeledReplicas": {
                "description": "The number of replicas that have labels matching the labels of the machine template of the MachineSet.",
                "format": "int32",
                "type": "integer"
              },
              "observedGeneration": {
                "description": "ObservedGeneration reflects the generation of the most recently observed MachineSet.",
                "format": "int64",
                "type": "integer"
              },
              "readyReplicas": {
                "description": "The number of ready replicas for this MachineSet. A machine is considered ready when the node has been created and is \"Ready\".",
                "format": "int32",
                "type": "integer"
              },
              "replicas": {
                "description": "Replicas is the most recently observed number of replicas.",
                "format": "int32",
                "type": "integer"
              }
            },
            "required": [
              "replicas"
            ],
            "type": "object"
          }
        }
      }
    },
    "version": "v1beta1",
    "versions": [
      {
        "name": "v1beta1",
        "served": true,
        "storage": true
      }
    ]
  }
}

---

{
  "metadata": {
    "name": "mcoconfigs.machineconfiguration.openshift.io"
  },
  "apiVersion": "apiextensions.k8s.io/v1beta1",
  "kind": "CustomResourceDefinition",
  "spec": {
    "conversion": {
      "strategy": "None"
    },
    "group": "machineconfiguration.openshift.io",
    "names": {
      "kind": "MCOConfig",
      "listKind": "MCOConfigList",
      "plural": "mcoconfigs",
      "singular": "mcoconfig"
    },
    "scope": "Namespaced",
    "version": "v1",
    "versions": [
      {
        "name": "v1",
        "served": true,
        "storage": true
      }
    ]
  }
}

---

{
  "metadata": {
    "name": "netnamespaces.network.openshift.io"
  },
  "apiVersion": "apiextensions.k8s.io/v1beta1",
  "kind": "CustomResourceDefinition",
  "spec": {
    "additionalPrinterColumns": [
      {
        "JSONPath": ".netid",
        "description": "The network identifier of the network namespace",
        "name": "NetID",
        "type": "integer"
      }
    ],
    "conversion": {
      "strategy": "None"
    },
    "group": "network.openshift.io",
    "names": {
      "kind": "NetNamespace",
      "listKind": "NetNamespaceList",
      "plural": "netnamespaces",
      "singular": "netnamespace"
    },
    "scope": "Cluster",
    "validation": {
      "openAPIV3Schema": {
        "properties": {
          "egressIPs": {
            "items": {
              "pattern": "^(([0-9]|[0-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[0-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])$",
              "type": "string"
            },
            "type": "array"
          },
          "netid": {
            "maximum": 16777215,
            "minimum": 0,
            "type": "integer"
          },
          "netname": {
            "pattern": "^[a-z0-9.-]+$",
            "type": "string"
          }
        }
      }
    },
    "version": "v1",
    "versions": [
      {
        "name": "v1",
        "served": true,
        "storage": true
      }
    ]
  }
}

---

{
  "metadata": {
    "name": "network-attachment-definitions.k8s.cni.cncf.io"
  },
  "apiVersion": "apiextensions.k8s.io/v1beta1",
  "kind": "CustomResourceDefinition",
  "spec": {
    "conversion": {
      "strategy": "None"
    },
    "group": "k8s.cni.cncf.io",
    "names": {
      "kind": "NetworkAttachmentDefinition",
      "listKind": "NetworkAttachmentDefinitionList",
      "plural": "network-attachment-definitions",
      "shortNames": [
        "net-attach-def"
      ],
      "singular": "network-attachment-definition"
    },
    "scope": "Namespaced",
    "version": "v1",
    "versions": [
      {
        "name": "v1",
        "served": true,
        "storage": true
      }
    ]
  }
}

---

{
  "metadata": {
    "name": "networks.config.openshift.io"
  },
  "apiVersion": "apiextensions.k8s.io/v1beta1",
  "kind": "CustomResourceDefinition",
  "spec": {
    "conversion": {
      "strategy": "None"
    },
    "group": "config.openshift.io",
    "names": {
      "kind": "Network",
      "listKind": "NetworkList",
      "plural": "networks",
      "singular": "network"
    },
    "scope": "Cluster",
    "validation": {
      "openAPIV3Schema": {
        "properties": {
          "apiVersion": {
            "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#resources",
            "type": "string"
          },
          "kind": {
            "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#types-kinds",
            "type": "string"
          },
          "metadata": {
            "description": "Standard object's metadata.",
            "type": "object"
          },
          "spec": {
            "description": "spec holds user settable values for configuration.",
            "properties": {
              "clusterNetwork": {
                "description": "IP address pool to use for pod IPs.",
                "items": {
                  "properties": {
                    "cidr": {
                      "description": "The complete block for pod IPs.",
                      "type": "string"
                    },
                    "hostPrefix": {
                      "description": "The size (prefix) of block to allocate to each node.",
                      "format": "int32",
                      "type": "integer"
                    }
                  },
                  "type": "object"
                },
                "type": "array"
              },
              "networkType": {
                "description": "NetworkType is the plugin that is to be deployed (e.g. OpenShiftSDN). This should match a value that the cluster-network-operator understands, or else no networking will be installed. Currently supported values are: - OpenShiftSDN",
                "type": "string"
              },
              "serviceNetwork": {
                "description": "IP address pool for services. Currently, we only support a single entry here.",
                "items": {
                  "type": "string"
                },
                "type": "array"
              }
            },
            "type": "object"
          },
          "status": {
            "description": "status holds observed values from the cluster. They may not be overridden.",
            "properties": {
              "clusterNetwork": {
                "description": "IP address pool to use for pod IPs.",
                "items": {
                  "properties": {
                    "cidr": {
                      "description": "The complete block for pod IPs.",
                      "type": "string"
                    },
                    "hostPrefix": {
                      "description": "The size (prefix) of block to allocate to each node.",
                      "format": "int32",
                      "type": "integer"
                    }
                  },
                  "type": "object"
                },
                "type": "array"
              },
              "clusterNetworkMTU": {
                "description": "ClusterNetworkMTU is the MTU for inter-pod networking.",
                "format": "int64",
                "type": "integer"
              },
              "networkType": {
                "description": "NetworkType is the plugin that is deployed (e.g. OpenShiftSDN).",
                "type": "string"
              },
              "serviceNetwork": {
                "description": "IP address pool for services. Currently, we only support a single entry here.",
                "items": {
                  "type": "string"
                },
                "type": "array"
              }
            },
            "type": "object"
          }
        },
        "required": [
          "spec"
        ]
      }
    },
    "version": "v1",
    "versions": [
      {
        "name": "v1",
        "served": true,
        "storage": true
      }
    ]
  }
}

---

{
  "metadata": {
    "name": "networks.operator.openshift.io"
  },
  "apiVersion": "apiextensions.k8s.io/v1beta1",
  "kind": "CustomResourceDefinition",
  "spec": {
    "conversion": {
      "strategy": "None"
    },
    "group": "operator.openshift.io",
    "names": {
      "kind": "Network",
      "listKind": "NetworkList",
      "plural": "networks",
      "singular": "network"
    },
    "scope": "Cluster",
    "validation": {
      "openAPIV3Schema": {
        "properties": {
          "spec": {
            "properties": {
              "additionalNetworks": {
                "items": {
                  "properties": {
                    "name": {
                      "type": "string"
                    },
                    "namespace": {
                      "type": "string"
                    },
                    "rawCNIConfig": {
                      "type": "string"
                    },
                    "type": {
                      "type": "string"
                    }
                  },
                  "required": [
                    "type",
                    "name",
                    "rawCNIConfig"
                  ],
                  "type": "object"
                },
                "type": "array"
              },
              "clusterNetwork": {
                "items": {
                  "properties": {
                    "cidr": {
                      "type": "string"
                    },
                    "hostPrefix": {
                      "minimum": 0,
                      "type": "integer"
                    }
                  },
                  "required": [
                    "cidr",
                    "hostPrefix"
                  ],
                  "type": "object"
                },
                "type": "array"
              },
              "defaultNetwork": {
                "properties": {
                  "openshiftSDNConfig": {
                    "properties": {
                      "mode": {
                        "type": "string"
                      },
                      "mtu": {
                        "minimum": 0,
                        "type": "integer"
                      },
                      "useExternalOpenvswitch": {
                        "type": "boolean"
                      },
                      "vxlanPort": {
                        "minimum": 0,
                        "type": "integer"
                      }
                    },
                    "required": [
                      "mode"
                    ],
                    "type": "object"
                  },
                  "ovnKubernetesConfig": {
                    "properties": {
                      "mtu": {
                        "minimum": 0,
                        "type": "integer"
                      }
                    },
                    "type": "object"
                  },
                  "type": {
                    "type": "string"
                  }
                },
                "required": [
                  "type"
                ],
                "type": "object"
              },
              "deployKubeProxy": {
                "type": "boolean"
              },
              "disableMultiNetwork": {
                "type": "boolean"
              },
              "kubeProxyConfig": {
                "properties": {
                  "bindAddress": {
                    "type": "string"
                  },
                  "iptablesSyncPeriod": {
                    "type": "string"
                  },
                  "proxyArguments": {
                    "additionalProperties": {
                      "items": {
                        "type": "string"
                      },
                      "type": "array"
                    },
                    "type": "object"
                  }
                },
                "type": "object"
              },
              "serviceNetwork": {
                "items": {
                  "type": "string"
                },
                "type": "array"
              }
            },
            "required": [
              "clusterNetwork",
              "serviceNetwork",
              "defaultNetwork"
            ],
            "type": "object"
          },
          "status": {
            "type": "object"
          }
        }
      }
    },
    "version": "v1",
    "versions": [
      {
        "name": "v1",
        "served": true,
        "storage": true
      }
    ]
  }
}

---

{
  "metadata": {
    "name": "oauths.config.openshift.io"
  },
  "apiVersion": "apiextensions.k8s.io/v1beta1",
  "kind": "CustomResourceDefinition",
  "spec": {
    "conversion": {
      "strategy": "None"
    },
    "group": "config.openshift.io",
    "names": {
      "kind": "OAuth",
      "listKind": "OAuthList",
      "plural": "oauths",
      "singular": "oauth"
    },
    "scope": "Cluster",
    "subresources": {
      "status": {}
    },
    "validation": {
      "openAPIV3Schema": {
        "properties": {
          "apiVersion": {
            "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#resources",
            "type": "string"
          },
          "kind": {
            "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#types-kinds",
            "type": "string"
          },
          "metadata": {
            "type": "object"
          },
          "spec": {
            "properties": {
              "identityProviders": {
                "description": "identityProviders is an ordered list of ways for a user to identify themselves. When this list is empty, no identities are provisioned for users.",
                "items": {
                  "properties": {
                    "basicAuth": {
                      "description": "basicAuth contains configuration options for the BasicAuth IdP",
                      "properties": {
                        "ca": {
                          "description": "ca is an optional reference to a config map by name containing the PEM-encoded CA bundle. It is used as a trust anchor to validate the TLS certificate presented by the remote server. The key \"ca.crt\" is used to locate the data. If specified and the config map or expected key is not found, the identity provider is not honored. If the specified ca data is not valid, the identity provider is not honored. If empty, the default system roots are used. The namespace for this config map is openshift-config.",
                          "properties": {
                            "name": {
                              "description": "name is the metadata.name of the referenced config map",
                              "type": "string"
                            }
                          },
                          "type": "object"
                        },
                        "tlsClientCert": {
                          "description": "tlsClientCert is an optional reference to a secret by name that contains the PEM-encoded TLS client certificate to present when connecting to the server. The key \"tls.crt\" is used to locate the data. If specified and the secret or expected key is not found, the identity provider is not honored. If the specified certificate data is not valid, the identity provider is not honored. The namespace for this secret is openshift-config.",
                          "properties": {
                            "name": {
                              "description": "name is the metadata.name of the referenced secret",
                              "type": "string"
                            }
                          },
                          "type": "object"
                        },
                        "tlsClientKey": {
                          "description": "tlsClientKey is an optional reference to a secret by name that contains the PEM-encoded TLS private key for the client certificate referenced in tlsClientCert. The key \"tls.key\" is used to locate the data. If specified and the secret or expected key is not found, the identity provider is not honored. If the specified certificate data is not valid, the identity provider is not honored. The namespace for this secret is openshift-config.",
                          "properties": {
                            "name": {
                              "description": "name is the metadata.name of the referenced secret",
                              "type": "string"
                            }
                          },
                          "type": "object"
                        },
                        "url": {
                          "description": "url is the remote URL to connect to",
                          "type": "string"
                        }
                      },
                      "type": "object"
                    },
                    "github": {
                      "description": "github enables user authentication using GitHub credentials",
                      "properties": {
                        "ca": {
                          "description": "ca is an optional reference to a config map by name containing the PEM-encoded CA bundle. It is used as a trust anchor to validate the TLS certificate presented by the remote server. The key \"ca.crt\" is used to locate the data. If specified and the config map or expected key is not found, the identity provider is not honored. If the specified ca data is not valid, the identity provider is not honored. If empty, the default system roots are used. This can only be configured when hostname is set to a non-empty value. The namespace for this config map is openshift-config.",
                          "properties": {
                            "name": {
                              "description": "name is the metadata.name of the referenced config map",
                              "type": "string"
                            }
                          },
                          "type": "object"
                        },
                        "clientID": {
                          "description": "clientID is the oauth client ID",
                          "type": "string"
                        },
                        "clientSecret": {
                          "description": "clientSecret is a required reference to the secret by name containing the oauth client secret. The key \"clientSecret\" is used to locate the data. If the secret or expected key is not found, the identity provider is not honored. The namespace for this secret is openshift-config.",
                          "properties": {
                            "name": {
                              "description": "name is the metadata.name of the referenced secret",
                              "type": "string"
                            }
                          },
                          "type": "object"
                        },
                        "hostname": {
                          "description": "hostname is the optional domain (e.g. \"mycompany.com\") for use with a hosted instance of GitHub Enterprise. It must match the GitHub Enterprise settings value configured at /setup/settings#hostname.",
                          "type": "string"
                        },
                        "organizations": {
                          "description": "organizations optionally restricts which organizations are allowed to log in",
                          "items": {
                            "type": "string"
                          },
                          "type": "array"
                        },
                        "teams": {
                          "description": "teams optionally restricts which teams are allowed to log in. Format is <org>/<team>.",
                          "items": {
                            "type": "string"
                          },
                          "type": "array"
                        }
                      },
                      "type": "object"
                    },
                    "gitlab": {
                      "description": "gitlab enables user authentication using GitLab credentials",
                      "properties": {
                        "ca": {
                          "description": "ca is an optional reference to a config map by name containing the PEM-encoded CA bundle. It is used as a trust anchor to validate the TLS certificate presented by the remote server. The key \"ca.crt\" is used to locate the data. If specified and the config map or expected key is not found, the identity provider is not honored. If the specified ca data is not valid, the identity provider is not honored. If empty, the default system roots are used. The namespace for this config map is openshift-config.",
                          "properties": {
                            "name": {
                              "description": "name is the metadata.name of the referenced config map",
                              "type": "string"
                            }
                          },
                          "type": "object"
                        },
                        "clientID": {
                          "description": "clientID is the oauth client ID",
                          "type": "string"
                        },
                        "clientSecret": {
                          "description": "clientSecret is a required reference to the secret by name containing the oauth client secret. The key \"clientSecret\" is used to locate the data. If the secret or expected key is not found, the identity provider is not honored. The namespace for this secret is openshift-config.",
                          "properties": {
                            "name": {
                              "description": "name is the metadata.name of the referenced secret",
                              "type": "string"
                            }
                          },
                          "type": "object"
                        },
                        "url": {
                          "description": "url is the oauth server base URL",
                          "type": "string"
                        }
                      },
                      "type": "object"
                    },
                    "google": {
                      "description": "google enables user authentication using Google credentials",
                      "properties": {
                        "clientID": {
                          "description": "clientID is the oauth client ID",
                          "type": "string"
                        },
                        "clientSecret": {
                          "description": "clientSecret is a required reference to the secret by name containing the oauth client secret. The key \"clientSecret\" is used to locate the data. If the secret or expected key is not found, the identity provider is not honored. The namespace for this secret is openshift-config.",
                          "properties": {
                            "name": {
                              "description": "name is the metadata.name of the referenced secret",
                              "type": "string"
                            }
                          },
                          "type": "object"
                        },
                        "hostedDomain": {
                          "description": "hostedDomain is the optional Google App domain (e.g. \"mycompany.com\") to restrict logins to",
                          "type": "string"
                        }
                      },
                      "type": "object"
                    },
                    "htpasswd": {
                      "description": "htpasswd enables user authentication using an HTPasswd file to validate credentials",
                      "properties": {
                        "fileData": {
                          "description": "fileData is a required reference to a secret by name containing the data to use as the htpasswd file. The key \"htpasswd\" is used to locate the data. If the secret or expected key is not found, the identity provider is not honored. If the specified htpasswd data is not valid, the identity provider is not honored. The namespace for this secret is openshift-config.",
                          "properties": {
                            "name": {
                              "description": "name is the metadata.name of the referenced secret",
                              "type": "string"
                            }
                          },
                          "type": "object"
                        }
                      },
                      "type": "object"
                    },
                    "keystone": {
                      "description": "keystone enables user authentication using keystone password credentials",
                      "properties": {
                        "ca": {
                          "description": "ca is an optional reference to a config map by name containing the PEM-encoded CA bundle. It is used as a trust anchor to validate the TLS certificate presented by the remote server. The key \"ca.crt\" is used to locate the data. If specified and the config map or expected key is not found, the identity provider is not honored. If the specified ca data is not valid, the identity provider is not honored. If empty, the default system roots are used. The namespace for this config map is openshift-config.",
                          "properties": {
                            "name": {
                              "description": "name is the metadata.name of the referenced config map",
                              "type": "string"
                            }
                          },
                          "type": "object"
                        },
                        "domainName": {
                          "description": "domainName is required for keystone v3",
                          "type": "string"
                        },
                        "tlsClientCert": {
                          "description": "tlsClientCert is an optional reference to a secret by name that contains the PEM-encoded TLS client certificate to present when connecting to the server. The key \"tls.crt\" is used to locate the data. If specified and the secret or expected key is not found, the identity provider is not honored. If the specified certificate data is not valid, the identity provider is not honored. The namespace for this secret is openshift-config.",
                          "properties": {
                            "name": {
                              "description": "name is the metadata.name of the referenced secret",
                              "type": "string"
                            }
                          },
                          "type": "object"
                        },
                        "tlsClientKey": {
                          "description": "tlsClientKey is an optional reference to a secret by name that contains the PEM-encoded TLS private key for the client certificate referenced in tlsClientCert. The key \"tls.key\" is used to locate the data. If specified and the secret or expected key is not found, the identity provider is not honored. If the specified certificate data is not valid, the identity provider is not honored. The namespace for this secret is openshift-config.",
                          "properties": {
                            "name": {
                              "description": "name is the metadata.name of the referenced secret",
                              "type": "string"
                            }
                          },
                          "type": "object"
                        },
                        "url": {
                          "description": "url is the remote URL to connect to",
                          "type": "string"
                        }
                      },
                      "type": "object"
                    },
                    "ldap": {
                      "description": "ldap enables user authentication using LDAP credentials",
                      "properties": {
                        "attributes": {
                          "description": "attributes maps LDAP attributes to identities",
                          "properties": {
                            "email": {
                              "description": "email is the list of attributes whose values should be used as the email address. Optional. If unspecified, no email is set for the identity",
                              "items": {
                                "type": "string"
                              },
                              "type": "array"
                            },
                            "id": {
                              "description": "id is the list of attributes whose values should be used as the user ID. Required. First non-empty attribute is used. At least one attribute is required. If none of the listed attribute have a value, authentication fails. LDAP standard identity attribute is \"dn\"",
                              "items": {
                                "type": "string"
                              },
                              "type": "array"
                            },
                            "name": {
                              "description": "name is the list of attributes whose values should be used as the display name. Optional. If unspecified, no display name is set for the identity LDAP standard display name attribute is \"cn\"",
                              "items": {
                                "type": "string"
                              },
                              "type": "array"
                            },
                            "preferredUsername": {
                              "description": "preferredUsername is the list of attributes whose values should be used as the preferred username. LDAP standard login attribute is \"uid\"",
                              "items": {
                                "type": "string"
                              },
                              "type": "array"
                            }
                          },
                          "type": "object"
                        },
                        "bindDN": {
                          "description": "bindDN is an optional DN to bind with during the search phase.",
                          "type": "string"
                        },
                        "bindPassword": {
                          "description": "bindPassword is an optional reference to a secret by name containing a password to bind with during the search phase. The key \"bindPassword\" is used to locate the data. If specified and the secret or expected key is not found, the identity provider is not honored. The namespace for this secret is openshift-config.",
                          "properties": {
                            "name": {
                              "description": "name is the metadata.name of the referenced secret",
                              "type": "string"
                            }
                          },
                          "type": "object"
                        },
                        "ca": {
                          "description": "ca is an optional reference to a config map by name containing the PEM-encoded CA bundle. It is used as a trust anchor to validate the TLS certificate presented by the remote server. The key \"ca.crt\" is used to locate the data. If specified and the config map or expected key is not found, the identity provider is not honored. If the specified ca data is not valid, the identity provider is not honored. If empty, the default system roots are used. The namespace for this config map is openshift-config.",
                          "properties": {
                            "name": {
                              "description": "name is the metadata.name of the referenced config map",
                              "type": "string"
                            }
                          },
                          "type": "object"
                        },
                        "insecure": {
                          "description": "insecure, if true, indicates the connection should not use TLS WARNING: Should not be set to `true` with the URL scheme \"ldaps://\" as \"ldaps://\" URLs always          attempt to connect using TLS, even when `insecure` is set to `true` When `true`, \"ldap://\" URLS connect insecurely. When `false`, \"ldap://\" URLs are upgraded to a TLS connection using StartTLS as specified in https://tools.ietf.org/html/rfc2830.",
                          "type": "boolean"
                        },
                        "url": {
                          "description": "url is an RFC 2255 URL which specifies the LDAP search parameters to use. The syntax of the URL is: ldap://host:port/basedn?attribute?scope?filter",
                          "type": "string"
                        }
                      },
                      "type": "object"
                    },
                    "mappingMethod": {
                      "description": "mappingMethod determines how identities from this provider are mapped to users Defaults to \"claim\"",
                      "type": "string"
                    },
                    "name": {
                      "description": "name is used to qualify the identities returned by this provider. - It MUST be unique and not shared by any other identity provider used - It MUST be a valid path segment: name cannot equal \".\" or \"..\" or contain \"/\" or \"%\" or \":\"   Ref: https://godoc.org/github.com/openshift/origin/pkg/user/apis/user/validation#ValidateIdentityProviderName",
                      "type": "string"
                    },
                    "openID": {
                      "description": "openID enables user authentication using OpenID credentials",
                      "properties": {
                        "ca": {
                          "description": "ca is an optional reference to a config map by name containing the PEM-encoded CA bundle. It is used as a trust anchor to validate the TLS certificate presented by the remote server. The key \"ca.crt\" is used to locate the data. If specified and the config map or expected key is not found, the identity provider is not honored. If the specified ca data is not valid, the identity provider is not honored. If empty, the default system roots are used. The namespace for this config map is openshift-config.",
                          "properties": {
                            "name": {
                              "description": "name is the metadata.name of the referenced config map",
                              "type": "string"
                            }
                          },
                          "type": "object"
                        },
                        "claims": {
                          "description": "claims mappings",
                          "properties": {
                            "email": {
                              "description": "email is the list of claims whose values should be used as the email address. Optional. If unspecified, no email is set for the identity",
                              "items": {
                                "type": "string"
                              },
                              "type": "array"
                            },
                            "name": {
                              "description": "name is the list of claims whose values should be used as the display name. Optional. If unspecified, no display name is set for the identity",
                              "items": {
                                "type": "string"
                              },
                              "type": "array"
                            },
                            "preferredUsername": {
                              "description": "preferredUsername is the list of claims whose values should be used as the preferred username. If unspecified, the preferred username is determined from the value of the sub claim",
                              "items": {
                                "type": "string"
                              },
                              "type": "array"
                            }
                          },
                          "type": "object"
                        },
                        "clientID": {
                          "description": "clientID is the oauth client ID",
                          "type": "string"
                        },
                        "clientSecret": {
                          "description": "clientSecret is a required reference to the secret by name containing the oauth client secret. The key \"clientSecret\" is used to locate the data. If the secret or expected key is not found, the identity provider is not honored. The namespace for this secret is openshift-config.",
                          "properties": {
                            "name": {
                              "description": "name is the metadata.name of the referenced secret",
                              "type": "string"
                            }
                          },
                          "type": "object"
                        },
                        "extraAuthorizeParameters": {
                          "description": "extraAuthorizeParameters are any custom parameters to add to the authorize request.",
                          "type": "object"
                        },
                        "extraScopes": {
                          "description": "extraScopes are any scopes to request in addition to the standard \"openid\" scope.",
                          "items": {
                            "type": "string"
                          },
                          "type": "array"
                        },
                        "issuer": {
                          "description": "issuer is the URL that the OpenID Provider asserts as its Issuer Identifier. It must use the https scheme with no query or fragment component.",
                          "type": "string"
                        }
                      },
                      "type": "object"
                    },
                    "requestHeader": {
                      "description": "requestHeader enables user authentication using request header credentials",
                      "properties": {
                        "ca": {
                          "description": "ca is a required reference to a config map by name containing the PEM-encoded CA bundle. It is used as a trust anchor to validate the TLS certificate presented by the remote server. Specifically, it allows verification of incoming requests to prevent header spoofing. The key \"ca.crt\" is used to locate the data. If the config map or expected key is not found, the identity provider is not honored. If the specified ca data is not valid, the identity provider is not honored. The namespace for this config map is openshift-config.",
                          "properties": {
                            "name": {
                              "description": "name is the metadata.name of the referenced config map",
                              "type": "string"
                            }
                          },
                          "type": "object"
                        },
                        "challengeURL": {
                          "description": "challengeURL is a URL to redirect unauthenticated /authorize requests to Unauthenticated requests from OAuth clients which expect WWW-Authenticate challenges will be redirected here. ${url} is replaced with the current URL, escaped to be safe in a query parameter   https://www.example.com/sso-login?then=${url} ${query} is replaced with the current query string   https://www.example.com/auth-proxy/oauth/authorize?${query} Required when challenge is set to true.",
                          "type": "string"
                        },
                        "clientCommonNames": {
                          "description": "clientCommonNames is an optional list of common names to require a match from. If empty, any client certificate validated against the clientCA bundle is considered authoritative.",
                          "items": {
                            "type": "string"
                          },
                          "type": "array"
                        },
                        "emailHeaders": {
                          "description": "emailHeaders is the set of headers to check for the email address",
                          "items": {
                            "type": "string"
                          },
                          "type": "array"
                        },
                        "headers": {
                          "description": "headers is the set of headers to check for identity information",
                          "items": {
                            "type": "string"
                          },
                          "type": "array"
                        },
                        "loginURL": {
                          "description": "loginURL is a URL to redirect unauthenticated /authorize requests to Unauthenticated requests from OAuth clients which expect interactive logins will be redirected here ${url} is replaced with the current URL, escaped to be safe in a query parameter   https://www.example.com/sso-login?then=${url} ${query} is replaced with the current query string   https://www.example.com/auth-proxy/oauth/authorize?${query} Required when login is set to true.",
                          "type": "string"
                        },
                        "nameHeaders": {
                          "description": "nameHeaders is the set of headers to check for the display name",
                          "items": {
                            "type": "string"
                          },
                          "type": "array"
                        },
                        "preferredUsernameHeaders": {
                          "description": "preferredUsernameHeaders is the set of headers to check for the preferred username",
                          "items": {
                            "type": "string"
                          },
                          "type": "array"
                        }
                      },
                      "type": "object"
                    },
                    "type": {
                      "description": "type identifies the identity provider type for this entry.",
                      "type": "string"
                    }
                  },
                  "type": "object"
                },
                "type": "array"
              },
              "templates": {
                "description": "templates allow you to customize pages like the login page.",
                "properties": {
                  "error": {
                    "description": "error is the name of a secret that specifies a go template to use to render error pages during the authentication or grant flow. The key \"errors.html\" is used to locate the template data. If specified and the secret or expected key is not found, the default error page is used. If the specified template is not valid, the default error page is used. If unspecified, the default error page is used. The namespace for this secret is openshift-config.",
                    "properties": {
                      "name": {
                        "description": "name is the metadata.name of the referenced secret",
                        "type": "string"
                      }
                    },
                    "type": "object"
                  },
                  "login": {
                    "description": "login is the name of a secret that specifies a go template to use to render the login page. The key \"login.html\" is used to locate the template data. If specified and the secret or expected key is not found, the default login page is used. If the specified template is not valid, the default login page is used. If unspecified, the default login page is used. The namespace for this secret is openshift-config.",
                    "properties": {
                      "name": {
                        "description": "name is the metadata.name of the referenced secret",
                        "type": "string"
                      }
                    },
                    "type": "object"
                  },
                  "providerSelection": {
                    "description": "providerSelection is the name of a secret that specifies a go template to use to render the provider selection page. The key \"providers.html\" is used to locate the template data. If specified and the secret or expected key is not found, the default provider selection page is used. If the specified template is not valid, the default provider selection page is used. If unspecified, the default provider selection page is used. The namespace for this secret is openshift-config.",
                    "properties": {
                      "name": {
                        "description": "name is the metadata.name of the referenced secret",
                        "type": "string"
                      }
                    },
                    "type": "object"
                  }
                },
                "type": "object"
              },
              "tokenConfig": {
                "description": "tokenConfig contains options for authorization and access tokens",
                "properties": {
                  "accessTokenInactivityTimeoutSeconds": {
                    "description": "accessTokenInactivityTimeoutSeconds defines the default token inactivity timeout for tokens granted by any client. The value represents the maximum amount of time that can occur between consecutive uses of the token. Tokens become invalid if they are not used within this temporal window. The user will need to acquire a new token to regain access once a token times out. Valid values are integer values:   x < 0  Tokens time out is enabled but tokens never timeout unless configured per client (e.g. `-1`)   x = 0  Tokens time out is disabled (default)   x > 0  Tokens time out if there is no activity for x seconds The current minimum allowed value for X is 300 (5 minutes)",
                    "format": "int32",
                    "type": "integer"
                  },
                  "accessTokenMaxAgeSeconds": {
                    "description": "accessTokenMaxAgeSeconds defines the maximum age of access tokens",
                    "format": "int32",
                    "type": "integer"
                  }
                },
                "type": "object"
              }
            },
            "type": "object"
          },
          "status": {
            "type": "object"
          }
        },
        "required": [
          "spec"
        ]
      }
    },
    "version": "v1",
    "versions": [
      {
        "name": "v1",
        "served": true,
        "storage": true
      }
    ]
  }
}

---

{
  "metadata": {
    "name": "openshiftapiservers.operator.openshift.io"
  },
  "apiVersion": "apiextensions.k8s.io/v1beta1",
  "kind": "CustomResourceDefinition",
  "spec": {
    "conversion": {
      "strategy": "None"
    },
    "group": "operator.openshift.io",
    "names": {
      "categories": [
        "coreoperators"
      ],
      "kind": "OpenShiftAPIServer",
      "listKind": "OpenShiftAPIServerList",
      "plural": "openshiftapiservers",
      "singular": "openshiftapiserver"
    },
    "scope": "Cluster",
    "subresources": {
      "status": {}
    },
    "validation": {
      "openAPIV3Schema": {
        "properties": {
          "apiVersion": {
            "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#resources",
            "type": "string"
          },
          "kind": {
            "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#types-kinds",
            "type": "string"
          },
          "metadata": {
            "type": "object"
          },
          "spec": {
            "properties": {
              "logLevel": {
                "description": "logLevel is an intent based logging for an overall component.  It does not give fine grained control, but it is a simple way to manage coarse grained logging choices that operators have to interpret for their operands.",
                "type": "string"
              },
              "managementState": {
                "description": "managementState indicates whether and how the operator should manage the component",
                "pattern": "^(Managed|Unmanaged|Force|Removed)$",
                "type": "string"
              },
              "observedConfig": {
                "description": "observedConfig holds a sparse config that controller has observed from the cluster state.  It exists in spec because it is an input to the level for the operator",
                "nullable": true,
                "type": "object"
              },
              "operatorLogLevel": {
                "description": "operatorLogLevel is an intent based logging for the operator itself.  It does not give fine grained control, but it is a simple way to manage coarse grained logging choices that operators have to interpret for themselves.",
                "type": "string"
              },
              "unsupportedConfigOverrides": {
                "description": "unsupportedConfigOverrides holds a sparse config that will override any previously set options.  It only needs to be the fields to override it will end up overlaying in the following order: 1. hardcoded defaults 2. observedConfig 3. unsupportedConfigOverrides",
                "nullable": true,
                "type": "object"
              }
            },
            "type": "object"
          },
          "status": {
            "properties": {
              "conditions": {
                "description": "conditions is a list of conditions and their status",
                "items": {
                  "properties": {
                    "lastTransitionTime": {
                      "format": "date-time",
                      "type": "string"
                    },
                    "message": {
                      "type": "string"
                    },
                    "reason": {
                      "type": "string"
                    },
                    "status": {
                      "type": "string"
                    },
                    "type": {
                      "type": "string"
                    }
                  },
                  "type": "object"
                },
                "type": "array"
              },
              "generations": {
                "description": "generations are used to determine when an item needs to be reconciled or has changed in a way that needs a reaction.",
                "items": {
                  "properties": {
                    "group": {
                      "description": "group is the group of the thing you're tracking",
                      "type": "string"
                    },
                    "hash": {
                      "description": "hash is an optional field set for resources without generation that are content sensitive like secrets and configmaps",
                      "type": "string"
                    },
                    "lastGeneration": {
                      "description": "lastGeneration is the last generation of the workload controller involved",
                      "format": "int64",
                      "type": "integer"
                    },
                    "name": {
                      "description": "name is the name of the thing you're tracking",
                      "type": "string"
                    },
                    "namespace": {
                      "description": "namespace is where the thing you're tracking is",
                      "type": "string"
                    },
                    "resource": {
                      "description": "resource is the resource type of the thing you're tracking",
                      "type": "string"
                    }
                  },
                  "type": "object"
                },
                "type": "array"
              },
              "observedGeneration": {
                "description": "observedGeneration is the last generation change you've dealt with",
                "format": "int64",
                "type": "integer"
              },
              "readyReplicas": {
                "description": "readyReplicas indicates how many replicas are ready and at the desired state",
                "format": "int32",
                "type": "integer"
              },
              "version": {
                "description": "version is the level this availability applies to",
                "type": "string"
              }
            },
            "type": "object"
          }
        },
        "required": [
          "spec"
        ]
      }
    },
    "version": "v1",
    "versions": [
      {
        "name": "v1",
        "served": true,
        "storage": true
      }
    ]
  }
}

---

{
  "metadata": {
    "name": "openshiftcontrollermanagers.operator.openshift.io"
  },
  "apiVersion": "apiextensions.k8s.io/v1beta1",
  "kind": "CustomResourceDefinition",
  "spec": {
    "conversion": {
      "strategy": "None"
    },
    "group": "operator.openshift.io",
    "names": {
      "categories": [
        "coreoperators"
      ],
      "kind": "OpenShiftControllerManager",
      "listKind": "OpenShiftControllerManagerList",
      "plural": "openshiftcontrollermanagers",
      "singular": "openshiftcontrollermanager"
    },
    "scope": "Cluster",
    "subresources": {
      "status": {}
    },
    "validation": {
      "openAPIV3Schema": {
        "properties": {
          "apiVersion": {
            "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#resources",
            "type": "string"
          },
          "kind": {
            "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#types-kinds",
            "type": "string"
          },
          "metadata": {
            "type": "object"
          },
          "spec": {
            "properties": {
              "logLevel": {
                "description": "logLevel is an intent based logging for an overall component.  It does not give fine grained control, but it is a simple way to manage coarse grained logging choices that operators have to interpret for their operands.",
                "type": "string"
              },
              "managementState": {
                "description": "managementState indicates whether and how the operator should manage the component",
                "pattern": "^(Managed|Unmanaged|Force|Removed)$",
                "type": "string"
              },
              "observedConfig": {
                "description": "observedConfig holds a sparse config that controller has observed from the cluster state.  It exists in spec because it is an input to the level for the operator",
                "nullable": true,
                "type": "object"
              },
              "operatorLogLevel": {
                "description": "operatorLogLevel is an intent based logging for the operator itself.  It does not give fine grained control, but it is a simple way to manage coarse grained logging choices that operators have to interpret for themselves.",
                "type": "string"
              },
              "unsupportedConfigOverrides": {
                "description": "unsupportedConfigOverrides holds a sparse config that will override any previously set options.  It only needs to be the fields to override it will end up overlaying in the following order: 1. hardcoded defaults 2. observedConfig 3. unsupportedConfigOverrides",
                "nullable": true,
                "type": "object"
              }
            },
            "type": "object"
          },
          "status": {
            "properties": {
              "conditions": {
                "description": "conditions is a list of conditions and their status",
                "items": {
                  "properties": {
                    "lastTransitionTime": {
                      "format": "date-time",
                      "type": "string"
                    },
                    "message": {
                      "type": "string"
                    },
                    "reason": {
                      "type": "string"
                    },
                    "status": {
                      "type": "string"
                    },
                    "type": {
                      "type": "string"
                    }
                  },
                  "type": "object"
                },
                "type": "array"
              },
              "generations": {
                "description": "generations are used to determine when an item needs to be reconciled or has changed in a way that needs a reaction.",
                "items": {
                  "properties": {
                    "group": {
                      "description": "group is the group of the thing you're tracking",
                      "type": "string"
                    },
                    "hash": {
                      "description": "hash is an optional field set for resources without generation that are content sensitive like secrets and configmaps",
                      "type": "string"
                    },
                    "lastGeneration": {
                      "description": "lastGeneration is the last generation of the workload controller involved",
                      "format": "int64",
                      "type": "integer"
                    },
                    "name": {
                      "description": "name is the name of the thing you're tracking",
                      "type": "string"
                    },
                    "namespace": {
                      "description": "namespace is where the thing you're tracking is",
                      "type": "string"
                    },
                    "resource": {
                      "description": "resource is the resource type of the thing you're tracking",
                      "type": "string"
                    }
                  },
                  "type": "object"
                },
                "type": "array"
              },
              "observedGeneration": {
                "description": "observedGeneration is the last generation change you've dealt with",
                "format": "int64",
                "type": "integer"
              },
              "readyReplicas": {
                "description": "readyReplicas indicates how many replicas are ready and at the desired state",
                "format": "int32",
                "type": "integer"
              },
              "version": {
                "description": "version is the level this availability applies to",
                "type": "string"
              }
            },
            "type": "object"
          }
        },
        "required": [
          "spec"
        ]
      }
    },
    "version": "v1",
    "versions": [
      {
        "name": "v1",
        "served": true,
        "storage": true
      }
    ]
  }
}

---

{
  "metadata": {
    "name": "operatorgroups.operators.coreos.com"
  },
  "apiVersion": "apiextensions.k8s.io/v1beta1",
  "kind": "CustomResourceDefinition",
  "spec": {
    "conversion": {
      "strategy": "None"
    },
    "group": "operators.coreos.com",
    "names": {
      "categories": [
        "olm"
      ],
      "kind": "OperatorGroup",
      "listKind": "OperatorGroupList",
      "plural": "operatorgroups",
      "shortNames": [
        "og"
      ],
      "singular": "operatorgroup"
    },
    "scope": "Namespaced",
    "subresources": {
      "status": {}
    },
    "validation": {
      "openAPIV3Schema": {
        "description": "A grouping of namespaces for usage with an operator.",
        "properties": {
          "spec": {
            "properties": {
              "selector": {
                "anyOf": [
                  {
                    "properties": {
                      "matchLabels": {
                        "description": "Label key:value pairs to match directly",
                        "type": "object"
                      }
                    },
                    "required": [
                      "matchLabels"
                    ]
                  },
                  {
                    "properties": {
                      "matchExpressions": {
                        "description": "A set of expressions to match against the resource.",
                        "items": {
                          "allOf": [
                            {
                              "properties": {
                                "key": {
                                  "description": "the key to match",
                                  "type": "string"
                                },
                                "operator": {
                                  "description": "the operator for the expression",
                                  "enum": [
                                    "In",
                                    "NotIn",
                                    "Exists",
                                    "DoesNotExist"
                                  ],
                                  "type": "string"
                                },
                                "values": {
                                  "description": "set of values for the expression",
                                  "type": "array"
                                }
                              },
                              "required": [
                                "key",
                                "operator",
                                "values"
                              ],
                              "type": "object"
                            }
                          ]
                        },
                        "type": "array"
                      }
                    },
                    "required": [
                      "matchExpressions"
                    ]
                  }
                ],
                "description": "Optional label selector to find resources associated with or managed by the operator",
                "type": "object"
              },
              "serviceAccountName": {
                "type": "string"
              },
              "staticProvidedAPIs": {
                "description": "If true, OLM will not modify the OperatorGroup's providedAPIs annotation.",
                "type": "boolean"
              },
              "targetNamespaces": {
                "description": "Optional list of target namespaces. If set, OLM will ignore selector.",
                "items": {
                  "pattern": "^\\S+$",
                  "type": "string"
                },
                "type": "array"
              }
            },
            "type": "object"
          },
          "status": {
            "properties": {
              "lastUpdated": {
                "format": "date-time",
                "type": "string"
              },
              "namespaces": {
                "items": {
                  "type": "string"
                },
                "type": "array"
              }
            },
            "required": [
              "namespaces",
              "lastUpdated"
            ],
            "type": "object"
          }
        },
        "required": [
          "metadata"
        ]
      }
    },
    "version": "v1",
    "versions": [
      {
        "name": "v1",
        "served": true,
        "storage": true
      },
      {
        "name": "v1alpha2",
        "served": true,
        "storage": false
      }
    ]
  }
}

---

{
  "metadata": {
    "name": "operatorsources.operators.coreos.com"
  },
  "apiVersion": "apiextensions.k8s.io/v1beta1",
  "kind": "CustomResourceDefinition",
  "spec": {
    "additionalPrinterColumns": [
      {
        "JSONPath": ".spec.type",
        "description": "The type of the OperatorSource",
        "name": "Type",
        "type": "string"
      },
      {
        "JSONPath": ".spec.endpoint",
        "description": "The endpoint of the OperatorSource",
        "name": "Endpoint",
        "type": "string"
      },
      {
        "JSONPath": ".spec.registryNamespace",
        "description": "App registry namespace",
        "name": "Registry",
        "type": "string"
      },
      {
        "JSONPath": ".spec.displayName",
        "description": "Display (pretty) name to indicate the OperatorSource's name",
        "name": "DisplayName",
        "type": "string"
      },
      {
        "JSONPath": ".spec.publisher",
        "description": "Publisher of the OperatorSource",
        "name": "Publisher",
        "type": "string"
      },
      {
        "JSONPath": ".status.currentPhase.phase.name",
        "description": "Current status of the OperatorSource",
        "name": "Status",
        "type": "string"
      },
      {
        "JSONPath": ".status.currentPhase.phase.message",
        "description": "Message associated with the current status",
        "name": "Message",
        "type": "string"
      },
      {
        "JSONPath": ".metadata.creationTimestamp",
        "name": "Age",
        "type": "date"
      }
    ],
    "conversion": {
      "strategy": "None"
    },
    "group": "operators.coreos.com",
    "names": {
      "kind": "OperatorSource",
      "listKind": "OperatorSourceList",
      "plural": "operatorsources",
      "shortNames": [
        "opsrc"
      ],
      "singular": "operatorsource"
    },
    "scope": "Namespaced",
    "validation": {
      "openAPIV3Schema": {
        "description": "OperatorSource is used to define the external datastore we are using to store operator bundles.",
        "properties": {
          "spec": {
            "description": "Spec for an OperatorSource.",
            "properties": {
              "authorizationToken": {
                "description": "This is where a user can specify an authorization token that can be used to access private repositories in the remote registry associated with the OperatorSource.",
                "properties": {
                  "secretName": {
                    "description": "It is the name of the kubernetes secret object that contains the authorization token to access private repositories.",
                    "type": "string"
                  }
                },
                "type": "object"
              },
              "displayName": {
                "description": "DisplayName is passed along to the CatalogSourceConfig to be used by the resulting CatalogSource to be used as a pretty name.",
                "type": "string"
              },
              "endpoint": {
                "description": "Points to the remote app registry server from where operator manifests can be fetched.",
                "type": "string"
              },
              "publisher": {
                "description": "It represents the entity that published the operator(s) associated with the OperatorSource.",
                "type": "string"
              },
              "registryNamespace": {
                "description": "The namespace in app registry.\nOnly operator manifests under this namespace will be visible.\nPlease note that this is not a k8s namespace.",
                "type": "string"
              },
              "type": {
                "description": "The type of the OperatorSource",
                "pattern": "appregistry",
                "type": "string"
              }
            },
            "required": [
              "type",
              "endpoint",
              "registryNamespace"
            ],
            "type": "object"
          },
          "status": {
            "type": "object"
          }
        }
      }
    },
    "version": "v1",
    "versions": [
      {
        "name": "v1",
        "served": true,
        "storage": true
      }
    ]
  }
}

---

{
  "metadata": {
    "name": "projects.config.openshift.io"
  },
  "apiVersion": "apiextensions.k8s.io/v1beta1",
  "kind": "CustomResourceDefinition",
  "spec": {
    "conversion": {
      "strategy": "None"
    },
    "group": "config.openshift.io",
    "names": {
      "kind": "Project",
      "listKind": "ProjectList",
      "plural": "projects",
      "singular": "project"
    },
    "scope": "Cluster",
    "validation": {
      "openAPIV3Schema": {
        "properties": {
          "apiVersion": {
            "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#resources",
            "type": "string"
          },
          "kind": {
            "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#types-kinds",
            "type": "string"
          },
          "metadata": {
            "description": "Standard object's metadata.",
            "type": "object"
          },
          "spec": {
            "description": "spec holds user settable values for configuration",
            "properties": {
              "projectRequestMessage": {
                "description": "projectRequestMessage is the string presented to a user if they are unable to request a project via the projectrequest api endpoint",
                "type": "string"
              },
              "projectRequestTemplate": {
                "description": "projectRequestTemplate is the template to use for creating projects in response to projectrequest. This must point to a template in 'openshift-config' namespace. It is optional. If it is not specified, a default template is used.",
                "properties": {
                  "name": {
                    "description": "name is the metadata.name of the referenced project request template",
                    "type": "string"
                  }
                },
                "type": "object"
              }
            },
            "type": "object"
          },
          "status": {
            "description": "status holds observed values from the cluster. They may not be overridden.",
            "type": "object"
          }
        },
        "required": [
          "spec"
        ]
      }
    },
    "version": "v1",
    "versions": [
      {
        "name": "v1",
        "served": true,
        "storage": true
      }
    ]
  }
}

---

{
  "metadata": {
    "name": "prometheuses.monitoring.coreos.com"
  },
  "apiVersion": "apiextensions.k8s.io/v1beta1",
  "kind": "CustomResourceDefinition",
  "spec": {
    "conversion": {
      "strategy": "None"
    },
    "group": "monitoring.coreos.com",
    "names": {
      "kind": "Prometheus",
      "listKind": "PrometheusList",
      "plural": "prometheuses",
      "singular": "prometheus"
    },
    "scope": "Namespaced",
    "validation": {
      "openAPIV3Schema": {
        "properties": {
          "apiVersion": {
            "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#resources",
            "type": "string"
          },
          "kind": {
            "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#types-kinds",
            "type": "string"
          },
          "spec": {
            "description": "PrometheusSpec is a specification of the desired behavior of the Prometheus cluster. More info: https://github.com/kubernetes/community/blob/master/contributors/devel/api-conventions.md#spec-and-status",
            "properties": {
              "additionalAlertManagerConfigs": {
                "description": "SecretKeySelector selects a key of a Secret.",
                "properties": {
                  "key": {
                    "description": "The key of the secret to select from.  Must be a valid secret key.",
                    "type": "string"
                  },
                  "name": {
                    "description": "Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names",
                    "type": "string"
                  },
                  "optional": {
                    "description": "Specify whether the Secret or it's key must be defined",
                    "type": "boolean"
                  }
                },
                "required": [
                  "key"
                ]
              },
              "additionalAlertRelabelConfigs": {
                "description": "SecretKeySelector selects a key of a Secret.",
                "properties": {
                  "key": {
                    "description": "The key of the secret to select from.  Must be a valid secret key.",
                    "type": "string"
                  },
                  "name": {
                    "description": "Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names",
                    "type": "string"
                  },
                  "optional": {
                    "description": "Specify whether the Secret or it's key must be defined",
                    "type": "boolean"
                  }
                },
                "required": [
                  "key"
                ]
              },
              "additionalScrapeConfigs": {
                "description": "SecretKeySelector selects a key of a Secret.",
                "properties": {
                  "key": {
                    "description": "The key of the secret to select from.  Must be a valid secret key.",
                    "type": "string"
                  },
                  "name": {
                    "description": "Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names",
                    "type": "string"
                  },
                  "optional": {
                    "description": "Specify whether the Secret or it's key must be defined",
                    "type": "boolean"
                  }
                },
                "required": [
                  "key"
                ]
              },
              "affinity": {
                "description": "Affinity is a group of affinity scheduling rules.",
                "properties": {
                  "nodeAffinity": {
                    "description": "Node affinity is a group of node affinity scheduling rules.",
                    "properties": {
                      "preferredDuringSchedulingIgnoredDuringExecution": {
                        "description": "The scheduler will prefer to schedule pods to nodes that satisfy the affinity expressions specified by this field, but it may choose a node that violates one or more of the expressions. The node that is most preferred is the one with the greatest sum of weights, i.e. for each node that meets all of the scheduling requirements (resource request, requiredDuringScheduling affinity expressions, etc.), compute a sum by iterating through the elements of this field and adding \"weight\" to the sum if the node matches the corresponding matchExpressions; the node(s) with the highest sum are the most preferred.",
                        "items": {
                          "description": "An empty preferred scheduling term matches all objects with implicit weight 0 (i.e. it's a no-op). A null preferred scheduling term matches no objects (i.e. is also a no-op).",
                          "properties": {
                            "preference": {
                              "description": "A null or empty node selector term matches no objects. The requirements of them are ANDed. The TopologySelectorTerm type implements a subset of the NodeSelectorTerm.",
                              "properties": {
                                "matchExpressions": {
                                  "description": "A list of node selector requirements by node's labels.",
                                  "items": {
                                    "description": "A node selector requirement is a selector that contains values, a key, and an operator that relates the key and values.",
                                    "properties": {
                                      "key": {
                                        "description": "The label key that the selector applies to.",
                                        "type": "string"
                                      },
                                      "operator": {
                                        "description": "Represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.",
                                        "type": "string"
                                      },
                                      "values": {
                                        "description": "An array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. If the operator is Gt or Lt, the values array must have a single element, which will be interpreted as an integer. This array is replaced during a strategic merge patch.",
                                        "items": {
                                          "type": "string"
                                        },
                                        "type": "array"
                                      }
                                    },
                                    "required": [
                                      "key",
                                      "operator"
                                    ]
                                  },
                                  "type": "array"
                                },
                                "matchFields": {
                                  "description": "A list of node selector requirements by node's fields.",
                                  "items": {
                                    "description": "A node selector requirement is a selector that contains values, a key, and an operator that relates the key and values.",
                                    "properties": {
                                      "key": {
                                        "description": "The label key that the selector applies to.",
                                        "type": "string"
                                      },
                                      "operator": {
                                        "description": "Represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.",
                                        "type": "string"
                                      },
                                      "values": {
                                        "description": "An array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. If the operator is Gt or Lt, the values array must have a single element, which will be interpreted as an integer. This array is replaced during a strategic merge patch.",
                                        "items": {
                                          "type": "string"
                                        },
                                        "type": "array"
                                      }
                                    },
                                    "required": [
                                      "key",
                                      "operator"
                                    ]
                                  },
                                  "type": "array"
                                }
                              }
                            },
                            "weight": {
                              "description": "Weight associated with matching the corresponding nodeSelectorTerm, in the range 1-100.",
                              "format": "int32",
                              "type": "integer"
                            }
                          },
                          "required": [
                            "weight",
                            "preference"
                          ]
                        },
                        "type": "array"
                      },
                      "requiredDuringSchedulingIgnoredDuringExecution": {
                        "description": "A node selector represents the union of the results of one or more label queries over a set of nodes; that is, it represents the OR of the selectors represented by the node selector terms.",
                        "properties": {
                          "nodeSelectorTerms": {
                            "description": "Required. A list of node selector terms. The terms are ORed.",
                            "items": {
                              "description": "A null or empty node selector term matches no objects. The requirements of them are ANDed. The TopologySelectorTerm type implements a subset of the NodeSelectorTerm.",
                              "properties": {
                                "matchExpressions": {
                                  "description": "A list of node selector requirements by node's labels.",
                                  "items": {
                                    "description": "A node selector requirement is a selector that contains values, a key, and an operator that relates the key and values.",
                                    "properties": {
                                      "key": {
                                        "description": "The label key that the selector applies to.",
                                        "type": "string"
                                      },
                                      "operator": {
                                        "description": "Represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.",
                                        "type": "string"
                                      },
                                      "values": {
                                        "description": "An array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. If the operator is Gt or Lt, the values array must have a single element, which will be interpreted as an integer. This array is replaced during a strategic merge patch.",
                                        "items": {
                                          "type": "string"
                                        },
                                        "type": "array"
                                      }
                                    },
                                    "required": [
                                      "key",
                                      "operator"
                                    ]
                                  },
                                  "type": "array"
                                },
                                "matchFields": {
                                  "description": "A list of node selector requirements by node's fields.",
                                  "items": {
                                    "description": "A node selector requirement is a selector that contains values, a key, and an operator that relates the key and values.",
                                    "properties": {
                                      "key": {
                                        "description": "The label key that the selector applies to.",
                                        "type": "string"
                                      },
                                      "operator": {
                                        "description": "Represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.",
                                        "type": "string"
                                      },
                                      "values": {
                                        "description": "An array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. If the operator is Gt or Lt, the values array must have a single element, which will be interpreted as an integer. This array is replaced during a strategic merge patch.",
                                        "items": {
                                          "type": "string"
                                        },
                                        "type": "array"
                                      }
                                    },
                                    "required": [
                                      "key",
                                      "operator"
                                    ]
                                  },
                                  "type": "array"
                                }
                              }
                            },
                            "type": "array"
                          }
                        },
                        "required": [
                          "nodeSelectorTerms"
                        ]
                      }
                    }
                  },
                  "podAffinity": {
                    "description": "Pod affinity is a group of inter pod affinity scheduling rules.",
                    "properties": {
                      "preferredDuringSchedulingIgnoredDuringExecution": {
                        "description": "The scheduler will prefer to schedule pods to nodes that satisfy the affinity expressions specified by this field, but it may choose a node that violates one or more of the expressions. The node that is most preferred is the one with the greatest sum of weights, i.e. for each node that meets all of the scheduling requirements (resource request, requiredDuringScheduling affinity expressions, etc.), compute a sum by iterating through the elements of this field and adding \"weight\" to the sum if the node has pods which matches the corresponding podAffinityTerm; the node(s) with the highest sum are the most preferred.",
                        "items": {
                          "description": "The weights of all of the matched WeightedPodAffinityTerm fields are added per-node to find the most preferred node(s)",
                          "properties": {
                            "podAffinityTerm": {
                              "description": "Defines a set of pods (namely those matching the labelSelector relative to the given namespace(s)) that this pod should be co-located (affinity) or not co-located (anti-affinity) with, where co-located is defined as running on a node whose value of the label with key <topologyKey> matches that of any node on which a pod of the set of pods is running",
                              "properties": {
                                "labelSelector": {
                                  "description": "A label selector is a label query over a set of resources. The result of matchLabels and matchExpressions are ANDed. An empty label selector matches all objects. A null label selector matches no objects.",
                                  "properties": {
                                    "matchExpressions": {
                                      "description": "matchExpressions is a list of label selector requirements. The requirements are ANDed.",
                                      "items": {
                                        "description": "A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.",
                                        "properties": {
                                          "key": {
                                            "description": "key is the label key that the selector applies to.",
                                            "type": "string"
                                          },
                                          "operator": {
                                            "description": "operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.",
                                            "type": "string"
                                          },
                                          "values": {
                                            "description": "values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.",
                                            "items": {
                                              "type": "string"
                                            },
                                            "type": "array"
                                          }
                                        },
                                        "required": [
                                          "key",
                                          "operator"
                                        ]
                                      },
                                      "type": "array"
                                    },
                                    "matchLabels": {
                                      "description": "matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is \"key\", the operator is \"In\", and the values array contains only \"value\". The requirements are ANDed.",
                                      "type": "object"
                                    }
                                  }
                                },
                                "namespaces": {
                                  "description": "namespaces specifies which namespaces the labelSelector applies to (matches against); null or empty list means \"this pod's namespace\"",
                                  "items": {
                                    "type": "string"
                                  },
                                  "type": "array"
                                },
                                "topologyKey": {
                                  "description": "This pod should be co-located (affinity) or not co-located (anti-affinity) with the pods matching the labelSelector in the specified namespaces, where co-located is defined as running on a node whose value of the label with key topologyKey matches that of any node on which any of the selected pods is running. Empty topologyKey is not allowed.",
                                  "type": "string"
                                }
                              },
                              "required": [
                                "topologyKey"
                              ]
                            },
                            "weight": {
                              "description": "weight associated with matching the corresponding podAffinityTerm, in the range 1-100.",
                              "format": "int32",
                              "type": "integer"
                            }
                          },
                          "required": [
                            "weight",
                            "podAffinityTerm"
                          ]
                        },
                        "type": "array"
                      },
                      "requiredDuringSchedulingIgnoredDuringExecution": {
                        "description": "If the affinity requirements specified by this field are not met at scheduling time, the pod will not be scheduled onto the node. If the affinity requirements specified by this field cease to be met at some point during pod execution (e.g. due to a pod label update), the system may or may not try to eventually evict the pod from its node. When there are multiple elements, the lists of nodes corresponding to each podAffinityTerm are intersected, i.e. all terms must be satisfied.",
                        "items": {
                          "description": "Defines a set of pods (namely those matching the labelSelector relative to the given namespace(s)) that this pod should be co-located (affinity) or not co-located (anti-affinity) with, where co-located is defined as running on a node whose value of the label with key <topologyKey> matches that of any node on which a pod of the set of pods is running",
                          "properties": {
                            "labelSelector": {
                              "description": "A label selector is a label query over a set of resources. The result of matchLabels and matchExpressions are ANDed. An empty label selector matches all objects. A null label selector matches no objects.",
                              "properties": {
                                "matchExpressions": {
                                  "description": "matchExpressions is a list of label selector requirements. The requirements are ANDed.",
                                  "items": {
                                    "description": "A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.",
                                    "properties": {
                                      "key": {
                                        "description": "key is the label key that the selector applies to.",
                                        "type": "string"
                                      },
                                      "operator": {
                                        "description": "operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.",
                                        "type": "string"
                                      },
                                      "values": {
                                        "description": "values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.",
                                        "items": {
                                          "type": "string"
                                        },
                                        "type": "array"
                                      }
                                    },
                                    "required": [
                                      "key",
                                      "operator"
                                    ]
                                  },
                                  "type": "array"
                                },
                                "matchLabels": {
                                  "description": "matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is \"key\", the operator is \"In\", and the values array contains only \"value\". The requirements are ANDed.",
                                  "type": "object"
                                }
                              }
                            },
                            "namespaces": {
                              "description": "namespaces specifies which namespaces the labelSelector applies to (matches against); null or empty list means \"this pod's namespace\"",
                              "items": {
                                "type": "string"
                              },
                              "type": "array"
                            },
                            "topologyKey": {
                              "description": "This pod should be co-located (affinity) or not co-located (anti-affinity) with the pods matching the labelSelector in the specified namespaces, where co-located is defined as running on a node whose value of the label with key topologyKey matches that of any node on which any of the selected pods is running. Empty topologyKey is not allowed.",
                              "type": "string"
                            }
                          },
                          "required": [
                            "topologyKey"
                          ]
                        },
                        "type": "array"
                      }
                    }
                  },
                  "podAntiAffinity": {
                    "description": "Pod anti affinity is a group of inter pod anti affinity scheduling rules.",
                    "properties": {
                      "preferredDuringSchedulingIgnoredDuringExecution": {
                        "description": "The scheduler will prefer to schedule pods to nodes that satisfy the anti-affinity expressions specified by this field, but it may choose a node that violates one or more of the expressions. The node that is most preferred is the one with the greatest sum of weights, i.e. for each node that meets all of the scheduling requirements (resource request, requiredDuringScheduling anti-affinity expressions, etc.), compute a sum by iterating through the elements of this field and adding \"weight\" to the sum if the node has pods which matches the corresponding podAffinityTerm; the node(s) with the highest sum are the most preferred.",
                        "items": {
                          "description": "The weights of all of the matched WeightedPodAffinityTerm fields are added per-node to find the most preferred node(s)",
                          "properties": {
                            "podAffinityTerm": {
                              "description": "Defines a set of pods (namely those matching the labelSelector relative to the given namespace(s)) that this pod should be co-located (affinity) or not co-located (anti-affinity) with, where co-located is defined as running on a node whose value of the label with key <topologyKey> matches that of any node on which a pod of the set of pods is running",
                              "properties": {
                                "labelSelector": {
                                  "description": "A label selector is a label query over a set of resources. The result of matchLabels and matchExpressions are ANDed. An empty label selector matches all objects. A null label selector matches no objects.",
                                  "properties": {
                                    "matchExpressions": {
                                      "description": "matchExpressions is a list of label selector requirements. The requirements are ANDed.",
                                      "items": {
                                        "description": "A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.",
                                        "properties": {
                                          "key": {
                                            "description": "key is the label key that the selector applies to.",
                                            "type": "string"
                                          },
                                          "operator": {
                                            "description": "operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.",
                                            "type": "string"
                                          },
                                          "values": {
                                            "description": "values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.",
                                            "items": {
                                              "type": "string"
                                            },
                                            "type": "array"
                                          }
                                        },
                                        "required": [
                                          "key",
                                          "operator"
                                        ]
                                      },
                                      "type": "array"
                                    },
                                    "matchLabels": {
                                      "description": "matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is \"key\", the operator is \"In\", and the values array contains only \"value\". The requirements are ANDed.",
                                      "type": "object"
                                    }
                                  }
                                },
                                "namespaces": {
                                  "description": "namespaces specifies which namespaces the labelSelector applies to (matches against); null or empty list means \"this pod's namespace\"",
                                  "items": {
                                    "type": "string"
                                  },
                                  "type": "array"
                                },
                                "topologyKey": {
                                  "description": "This pod should be co-located (affinity) or not co-located (anti-affinity) with the pods matching the labelSelector in the specified namespaces, where co-located is defined as running on a node whose value of the label with key topologyKey matches that of any node on which any of the selected pods is running. Empty topologyKey is not allowed.",
                                  "type": "string"
                                }
                              },
                              "required": [
                                "topologyKey"
                              ]
                            },
                            "weight": {
                              "description": "weight associated with matching the corresponding podAffinityTerm, in the range 1-100.",
                              "format": "int32",
                              "type": "integer"
                            }
                          },
                          "required": [
                            "weight",
                            "podAffinityTerm"
                          ]
                        },
                        "type": "array"
                      },
                      "requiredDuringSchedulingIgnoredDuringExecution": {
                        "description": "If the anti-affinity requirements specified by this field are not met at scheduling time, the pod will not be scheduled onto the node. If the anti-affinity requirements specified by this field cease to be met at some point during pod execution (e.g. due to a pod label update), the system may or may not try to eventually evict the pod from its node. When there are multiple elements, the lists of nodes corresponding to each podAffinityTerm are intersected, i.e. all terms must be satisfied.",
                        "items": {
                          "description": "Defines a set of pods (namely those matching the labelSelector relative to the given namespace(s)) that this pod should be co-located (affinity) or not co-located (anti-affinity) with, where co-located is defined as running on a node whose value of the label with key <topologyKey> matches that of any node on which a pod of the set of pods is running",
                          "properties": {
                            "labelSelector": {
                              "description": "A label selector is a label query over a set of resources. The result of matchLabels and matchExpressions are ANDed. An empty label selector matches all objects. A null label selector matches no objects.",
                              "properties": {
                                "matchExpressions": {
                                  "description": "matchExpressions is a list of label selector requirements. The requirements are ANDed.",
                                  "items": {
                                    "description": "A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.",
                                    "properties": {
                                      "key": {
                                        "description": "key is the label key that the selector applies to.",
                                        "type": "string"
                                      },
                                      "operator": {
                                        "description": "operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.",
                                        "type": "string"
                                      },
                                      "values": {
                                        "description": "values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.",
                                        "items": {
                                          "type": "string"
                                        },
                                        "type": "array"
                                      }
                                    },
                                    "required": [
                                      "key",
                                      "operator"
                                    ]
                                  },
                                  "type": "array"
                                },
                                "matchLabels": {
                                  "description": "matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is \"key\", the operator is \"In\", and the values array contains only \"value\". The requirements are ANDed.",
                                  "type": "object"
                                }
                              }
                            },
                            "namespaces": {
                              "description": "namespaces specifies which namespaces the labelSelector applies to (matches against); null or empty list means \"this pod's namespace\"",
                              "items": {
                                "type": "string"
                              },
                              "type": "array"
                            },
                            "topologyKey": {
                              "description": "This pod should be co-located (affinity) or not co-located (anti-affinity) with the pods matching the labelSelector in the specified namespaces, where co-located is defined as running on a node whose value of the label with key topologyKey matches that of any node on which any of the selected pods is running. Empty topologyKey is not allowed.",
                              "type": "string"
                            }
                          },
                          "required": [
                            "topologyKey"
                          ]
                        },
                        "type": "array"
                      }
                    }
                  }
                }
              },
              "alerting": {
                "description": "AlertingSpec defines parameters for alerting configuration of Prometheus servers.",
                "properties": {
                  "alertmanagers": {
                    "description": "AlertmanagerEndpoints Prometheus should fire alerts against.",
                    "items": {
                      "description": "AlertmanagerEndpoints defines a selection of a single Endpoints object containing alertmanager IPs to fire alerts against.",
                      "properties": {
                        "bearerTokenFile": {
                          "description": "BearerTokenFile to read from filesystem to use when authenticating to Alertmanager.",
                          "type": "string"
                        },
                        "name": {
                          "description": "Name of Endpoints object in Namespace.",
                          "type": "string"
                        },
                        "namespace": {
                          "description": "Namespace of Endpoints object.",
                          "type": "string"
                        },
                        "pathPrefix": {
                          "description": "Prefix for the HTTP path alerts are pushed to.",
                          "type": "string"
                        },
                        "port": {
                          "anyOf": [
                            {
                              "type": "string"
                            },
                            {
                              "type": "integer"
                            }
                          ]
                        },
                        "scheme": {
                          "description": "Scheme to use when firing alerts.",
                          "type": "string"
                        },
                        "tlsConfig": {
                          "description": "TLSConfig specifies TLS configuration parameters.",
                          "properties": {
                            "caFile": {
                              "description": "The CA cert to use for the targets.",
                              "type": "string"
                            },
                            "certFile": {
                              "description": "The client cert file for the targets.",
                              "type": "string"
                            },
                            "insecureSkipVerify": {
                              "description": "Disable target certificate validation.",
                              "type": "boolean"
                            },
                            "keyFile": {
                              "description": "The client key file for the targets.",
                              "type": "string"
                            },
                            "serverName": {
                              "description": "Used to verify the hostname for the targets.",
                              "type": "string"
                            }
                          }
                        }
                      },
                      "required": [
                        "namespace",
                        "name",
                        "port"
                      ]
                    },
                    "type": "array"
                  }
                },
                "required": [
                  "alertmanagers"
                ]
              },
              "apiserverConfig": {
                "description": "APIServerConfig defines a host and auth methods to access apiserver. More info: https://prometheus.io/docs/prometheus/latest/configuration/configuration/#kubernetes_sd_config",
                "properties": {
                  "basicAuth": {
                    "description": "BasicAuth allow an endpoint to authenticate over basic authentication More info: https://prometheus.io/docs/operating/configuration/#endpoints",
                    "properties": {
                      "password": {
                        "description": "SecretKeySelector selects a key of a Secret.",
                        "properties": {
                          "key": {
                            "description": "The key of the secret to select from.  Must be a valid secret key.",
                            "type": "string"
                          },
                          "name": {
                            "description": "Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names",
                            "type": "string"
                          },
                          "optional": {
                            "description": "Specify whether the Secret or it's key must be defined",
                            "type": "boolean"
                          }
                        },
                        "required": [
                          "key"
                        ]
                      },
                      "username": {
                        "description": "SecretKeySelector selects a key of a Secret.",
                        "properties": {
                          "key": {
                            "description": "The key of the secret to select from.  Must be a valid secret key.",
                            "type": "string"
                          },
                          "name": {
                            "description": "Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names",
                            "type": "string"
                          },
                          "optional": {
                            "description": "Specify whether the Secret or it's key must be defined",
                            "type": "boolean"
                          }
                        },
                        "required": [
                          "key"
                        ]
                      }
                    }
                  },
                  "bearerToken": {
                    "description": "Bearer token for accessing apiserver.",
                    "type": "string"
                  },
                  "bearerTokenFile": {
                    "description": "File to read bearer token for accessing apiserver.",
                    "type": "string"
                  },
                  "host": {
                    "description": "Host of apiserver. A valid string consisting of a hostname or IP followed by an optional port number",
                    "type": "string"
                  },
                  "tlsConfig": {
                    "description": "TLSConfig specifies TLS configuration parameters.",
                    "properties": {
                      "caFile": {
                        "description": "The CA cert to use for the targets.",
                        "type": "string"
                      },
                      "certFile": {
                        "description": "The client cert file for the targets.",
                        "type": "string"
                      },
                      "insecureSkipVerify": {
                        "description": "Disable target certificate validation.",
                        "type": "boolean"
                      },
                      "keyFile": {
                        "description": "The client key file for the targets.",
                        "type": "string"
                      },
                      "serverName": {
                        "description": "Used to verify the hostname for the targets.",
                        "type": "string"
                      }
                    }
                  }
                },
                "required": [
                  "host"
                ]
              },
              "baseImage": {
                "description": "Base image to use for a Prometheus deployment.",
                "type": "string"
              },
              "configMaps": {
                "description": "ConfigMaps is a list of ConfigMaps in the same namespace as the Prometheus object, which shall be mounted into the Prometheus Pods. The ConfigMaps are mounted into /etc/prometheus/configmaps/<configmap-name>.",
                "items": {
                  "type": "string"
                },
                "type": "array"
              },
              "containers": {
                "description": "Containers allows injecting additional containers. This is meant to allow adding an authentication proxy to a Prometheus pod.",
                "items": {
                  "description": "A single application container that you want to run within a pod.",
                  "properties": {
                    "args": {
                      "description": "Arguments to the entrypoint. The docker image's CMD is used if this is not provided. Variable references $(VAR_NAME) are expanded using the container's environment. If a variable cannot be resolved, the reference in the input string will be unchanged. The $(VAR_NAME) syntax can be escaped with a double $$, ie: $$(VAR_NAME). Escaped references will never be expanded, regardless of whether the variable exists or not. Cannot be updated. More info: https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell",
                      "items": {
                        "type": "string"
                      },
                      "type": "array"
                    },
                    "command": {
                      "description": "Entrypoint array. Not executed within a shell. The docker image's ENTRYPOINT is used if this is not provided. Variable references $(VAR_NAME) are expanded using the container's environment. If a variable cannot be resolved, the reference in the input string will be unchanged. The $(VAR_NAME) syntax can be escaped with a double $$, ie: $$(VAR_NAME). Escaped references will never be expanded, regardless of whether the variable exists or not. Cannot be updated. More info: https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell",
                      "items": {
                        "type": "string"
                      },
                      "type": "array"
                    },
                    "env": {
                      "description": "List of environment variables to set in the container. Cannot be updated.",
                      "items": {
                        "description": "EnvVar represents an environment variable present in a Container.",
                        "properties": {
                          "name": {
                            "description": "Name of the environment variable. Must be a C_IDENTIFIER.",
                            "type": "string"
                          },
                          "value": {
                            "description": "Variable references $(VAR_NAME) are expanded using the previous defined environment variables in the container and any service environment variables. If a variable cannot be resolved, the reference in the input string will be unchanged. The $(VAR_NAME) syntax can be escaped with a double $$, ie: $$(VAR_NAME). Escaped references will never be expanded, regardless of whether the variable exists or not. Defaults to \"\".",
                            "type": "string"
                          },
                          "valueFrom": {
                            "description": "EnvVarSource represents a source for the value of an EnvVar.",
                            "properties": {
                              "configMapKeyRef": {
                                "description": "Selects a key from a ConfigMap.",
                                "properties": {
                                  "key": {
                                    "description": "The key to select.",
                                    "type": "string"
                                  },
                                  "name": {
                                    "description": "Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names",
                                    "type": "string"
                                  },
                                  "optional": {
                                    "description": "Specify whether the ConfigMap or it's key must be defined",
                                    "type": "boolean"
                                  }
                                },
                                "required": [
                                  "key"
                                ]
                              },
                              "fieldRef": {
                                "description": "ObjectFieldSelector selects an APIVersioned field of an object.",
                                "properties": {
                                  "apiVersion": {
                                    "description": "Version of the schema the FieldPath is written in terms of, defaults to \"v1\".",
                                    "type": "string"
                                  },
                                  "fieldPath": {
                                    "description": "Path of the field to select in the specified API version.",
                                    "type": "string"
                                  }
                                },
                                "required": [
                                  "fieldPath"
                                ]
                              },
                              "resourceFieldRef": {
                                "description": "ResourceFieldSelector represents container resources (cpu, memory) and their output format",
                                "properties": {
                                  "containerName": {
                                    "description": "Container name: required for volumes, optional for env vars",
                                    "type": "string"
                                  },
                                  "divisor": {},
                                  "resource": {
                                    "description": "Required: resource to select",
                                    "type": "string"
                                  }
                                },
                                "required": [
                                  "resource"
                                ]
                              },
                              "secretKeyRef": {
                                "description": "SecretKeySelector selects a key of a Secret.",
                                "properties": {
                                  "key": {
                                    "description": "The key of the secret to select from.  Must be a valid secret key.",
                                    "type": "string"
                                  },
                                  "name": {
                                    "description": "Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names",
                                    "type": "string"
                                  },
                                  "optional": {
                                    "description": "Specify whether the Secret or it's key must be defined",
                                    "type": "boolean"
                                  }
                                },
                                "required": [
                                  "key"
                                ]
                              }
                            }
                          }
                        },
                        "required": [
                          "name"
                        ]
                      },
                      "type": "array"
                    },
                    "envFrom": {
                      "description": "List of sources to populate environment variables in the container. The keys defined within a source must be a C_IDENTIFIER. All invalid keys will be reported as an event when the container is starting. When a key exists in multiple sources, the value associated with the last source will take precedence. Values defined by an Env with a duplicate key will take precedence. Cannot be updated.",
                      "items": {
                        "description": "EnvFromSource represents the source of a set of ConfigMaps",
                        "properties": {
                          "configMapRef": {
                            "description": "ConfigMapEnvSource selects a ConfigMap to populate the environment variables with.\n\nThe contents of the target ConfigMap's Data field will represent the key-value pairs as environment variables.",
                            "properties": {
                              "name": {
                                "description": "Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names",
                                "type": "string"
                              },
                              "optional": {
                                "description": "Specify whether the ConfigMap must be defined",
                                "type": "boolean"
                              }
                            }
                          },
                          "prefix": {
                            "description": "An optional identifier to prepend to each key in the ConfigMap. Must be a C_IDENTIFIER.",
                            "type": "string"
                          },
                          "secretRef": {
                            "description": "SecretEnvSource selects a Secret to populate the environment variables with.\n\nThe contents of the target Secret's Data field will represent the key-value pairs as environment variables.",
                            "properties": {
                              "name": {
                                "description": "Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names",
                                "type": "string"
                              },
                              "optional": {
                                "description": "Specify whether the Secret must be defined",
                                "type": "boolean"
                              }
                            }
                          }
                        }
                      },
                      "type": "array"
                    },
                    "image": {
                      "description": "Docker image name. More info: https://kubernetes.io/docs/concepts/containers/images This field is optional to allow higher level config management to default or override container images in workload controllers like Deployments and StatefulSets.",
                      "type": "string"
                    },
                    "imagePullPolicy": {
                      "description": "Image pull policy. One of Always, Never, IfNotPresent. Defaults to Always if :latest tag is specified, or IfNotPresent otherwise. Cannot be updated. More info: https://kubernetes.io/docs/concepts/containers/images#updating-images",
                      "type": "string"
                    },
                    "lifecycle": {
                      "description": "Lifecycle describes actions that the management system should take in response to container lifecycle events. For the PostStart and PreStop lifecycle handlers, management of the container blocks until the action is complete, unless the container process fails, in which case the handler is aborted.",
                      "properties": {
                        "postStart": {
                          "description": "Handler defines a specific action that should be taken",
                          "properties": {
                            "exec": {
                              "description": "ExecAction describes a \"run in container\" action.",
                              "properties": {
                                "command": {
                                  "description": "Command is the command line to execute inside the container, the working directory for the command  is root ('/') in the container's filesystem. The command is simply exec'd, it is not run inside a shell, so traditional shell instructions ('|', etc) won't work. To use a shell, you need to explicitly call out to that shell. Exit status of 0 is treated as live/healthy and non-zero is unhealthy.",
                                  "items": {
                                    "type": "string"
                                  },
                                  "type": "array"
                                }
                              }
                            },
                            "httpGet": {
                              "description": "HTTPGetAction describes an action based on HTTP Get requests.",
                              "properties": {
                                "host": {
                                  "description": "Host name to connect to, defaults to the pod IP. You probably want to set \"Host\" in httpHeaders instead.",
                                  "type": "string"
                                },
                                "httpHeaders": {
                                  "description": "Custom headers to set in the request. HTTP allows repeated headers.",
                                  "items": {
                                    "description": "HTTPHeader describes a custom header to be used in HTTP probes",
                                    "properties": {
                                      "name": {
                                        "description": "The header field name",
                                        "type": "string"
                                      },
                                      "value": {
                                        "description": "The header field value",
                                        "type": "string"
                                      }
                                    },
                                    "required": [
                                      "name",
                                      "value"
                                    ]
                                  },
                                  "type": "array"
                                },
                                "path": {
                                  "description": "Path to access on the HTTP server.",
                                  "type": "string"
                                },
                                "port": {
                                  "anyOf": [
                                    {
                                      "type": "string"
                                    },
                                    {
                                      "type": "integer"
                                    }
                                  ]
                                },
                                "scheme": {
                                  "description": "Scheme to use for connecting to the host. Defaults to HTTP.",
                                  "type": "string"
                                }
                              },
                              "required": [
                                "port"
                              ]
                            },
                            "tcpSocket": {
                              "description": "TCPSocketAction describes an action based on opening a socket",
                              "properties": {
                                "host": {
                                  "description": "Optional: Host name to connect to, defaults to the pod IP.",
                                  "type": "string"
                                },
                                "port": {
                                  "anyOf": [
                                    {
                                      "type": "string"
                                    },
                                    {
                                      "type": "integer"
                                    }
                                  ]
                                }
                              },
                              "required": [
                                "port"
                              ]
                            }
                          }
                        },
                        "preStop": {
                          "description": "Handler defines a specific action that should be taken",
                          "properties": {
                            "exec": {
                              "description": "ExecAction describes a \"run in container\" action.",
                              "properties": {
                                "command": {
                                  "description": "Command is the command line to execute inside the container, the working directory for the command  is root ('/') in the container's filesystem. The command is simply exec'd, it is not run inside a shell, so traditional shell instructions ('|', etc) won't work. To use a shell, you need to explicitly call out to that shell. Exit status of 0 is treated as live/healthy and non-zero is unhealthy.",
                                  "items": {
                                    "type": "string"
                                  },
                                  "type": "array"
                                }
                              }
                            },
                            "httpGet": {
                              "description": "HTTPGetAction describes an action based on HTTP Get requests.",
                              "properties": {
                                "host": {
                                  "description": "Host name to connect to, defaults to the pod IP. You probably want to set \"Host\" in httpHeaders instead.",
                                  "type": "string"
                                },
                                "httpHeaders": {
                                  "description": "Custom headers to set in the request. HTTP allows repeated headers.",
                                  "items": {
                                    "description": "HTTPHeader describes a custom header to be used in HTTP probes",
                                    "properties": {
                                      "name": {
                                        "description": "The header field name",
                                        "type": "string"
                                      },
                                      "value": {
                                        "description": "The header field value",
                                        "type": "string"
                                      }
                                    },
                                    "required": [
                                      "name",
                                      "value"
                                    ]
                                  },
                                  "type": "array"
                                },
                                "path": {
                                  "description": "Path to access on the HTTP server.",
                                  "type": "string"
                                },
                                "port": {
                                  "anyOf": [
                                    {
                                      "type": "string"
                                    },
                                    {
                                      "type": "integer"
                                    }
                                  ]
                                },
                                "scheme": {
                                  "description": "Scheme to use for connecting to the host. Defaults to HTTP.",
                                  "type": "string"
                                }
                              },
                              "required": [
                                "port"
                              ]
                            },
                            "tcpSocket": {
                              "description": "TCPSocketAction describes an action based on opening a socket",
                              "properties": {
                                "host": {
                                  "description": "Optional: Host name to connect to, defaults to the pod IP.",
                                  "type": "string"
                                },
                                "port": {
                                  "anyOf": [
                                    {
                                      "type": "string"
                                    },
                                    {
                                      "type": "integer"
                                    }
                                  ]
                                }
                              },
                              "required": [
                                "port"
                              ]
                            }
                          }
                        }
                      }
                    },
                    "livenessProbe": {
                      "description": "Probe describes a health check to be performed against a container to determine whether it is alive or ready to receive traffic.",
                      "properties": {
                        "exec": {
                          "description": "ExecAction describes a \"run in container\" action.",
                          "properties": {
                            "command": {
                              "description": "Command is the command line to execute inside the container, the working directory for the command  is root ('/') in the container's filesystem. The command is simply exec'd, it is not run inside a shell, so traditional shell instructions ('|', etc) won't work. To use a shell, you need to explicitly call out to that shell. Exit status of 0 is treated as live/healthy and non-zero is unhealthy.",
                              "items": {
                                "type": "string"
                              },
                              "type": "array"
                            }
                          }
                        },
                        "failureThreshold": {
                          "description": "Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1.",
                          "format": "int32",
                          "type": "integer"
                        },
                        "httpGet": {
                          "description": "HTTPGetAction describes an action based on HTTP Get requests.",
                          "properties": {
                            "host": {
                              "description": "Host name to connect to, defaults to the pod IP. You probably want to set \"Host\" in httpHeaders instead.",
                              "type": "string"
                            },
                            "httpHeaders": {
                              "description": "Custom headers to set in the request. HTTP allows repeated headers.",
                              "items": {
                                "description": "HTTPHeader describes a custom header to be used in HTTP probes",
                                "properties": {
                                  "name": {
                                    "description": "The header field name",
                                    "type": "string"
                                  },
                                  "value": {
                                    "description": "The header field value",
                                    "type": "string"
                                  }
                                },
                                "required": [
                                  "name",
                                  "value"
                                ]
                              },
                              "type": "array"
                            },
                            "path": {
                              "description": "Path to access on the HTTP server.",
                              "type": "string"
                            },
                            "port": {
                              "anyOf": [
                                {
                                  "type": "string"
                                },
                                {
                                  "type": "integer"
                                }
                              ]
                            },
                            "scheme": {
                              "description": "Scheme to use for connecting to the host. Defaults to HTTP.",
                              "type": "string"
                            }
                          },
                          "required": [
                            "port"
                          ]
                        },
                        "initialDelaySeconds": {
                          "description": "Number of seconds after the container has started before liveness probes are initiated. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes",
                          "format": "int32",
                          "type": "integer"
                        },
                        "periodSeconds": {
                          "description": "How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1.",
                          "format": "int32",
                          "type": "integer"
                        },
                        "successThreshold": {
                          "description": "Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness. Minimum value is 1.",
                          "format": "int32",
                          "type": "integer"
                        },
                        "tcpSocket": {
                          "description": "TCPSocketAction describes an action based on opening a socket",
                          "properties": {
                            "host": {
                              "description": "Optional: Host name to connect to, defaults to the pod IP.",
                              "type": "string"
                            },
                            "port": {
                              "anyOf": [
                                {
                                  "type": "string"
                                },
                                {
                                  "type": "integer"
                                }
                              ]
                            }
                          },
                          "required": [
                            "port"
                          ]
                        },
                        "timeoutSeconds": {
                          "description": "Number of seconds after which the probe times out. Defaults to 1 second. Minimum value is 1. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes",
                          "format": "int32",
                          "type": "integer"
                        }
                      }
                    },
                    "name": {
                      "description": "Name of the container specified as a DNS_LABEL. Each container in a pod must have a unique name (DNS_LABEL). Cannot be updated.",
                      "type": "string"
                    },
                    "ports": {
                      "description": "List of ports to expose from the container. Exposing a port here gives the system additional information about the network connections a container uses, but is primarily informational. Not specifying a port here DOES NOT prevent that port from being exposed. Any port which is listening on the default \"0.0.0.0\" address inside a container will be accessible from the network. Cannot be updated.",
                      "items": {
                        "description": "ContainerPort represents a network port in a single container.",
                        "properties": {
                          "containerPort": {
                            "description": "Number of port to expose on the pod's IP address. This must be a valid port number, 0 < x < 65536.",
                            "format": "int32",
                            "type": "integer"
                          },
                          "hostIP": {
                            "description": "What host IP to bind the external port to.",
                            "type": "string"
                          },
                          "hostPort": {
                            "description": "Number of port to expose on the host. If specified, this must be a valid port number, 0 < x < 65536. If HostNetwork is specified, this must match ContainerPort. Most containers do not need this.",
                            "format": "int32",
                            "type": "integer"
                          },
                          "name": {
                            "description": "If specified, this must be an IANA_SVC_NAME and unique within the pod. Each named port in a pod must have a unique name. Name for the port that can be referred to by services.",
                            "type": "string"
                          },
                          "protocol": {
                            "description": "Protocol for port. Must be UDP, TCP, or SCTP. Defaults to \"TCP\".",
                            "type": "string"
                          }
                        },
                        "required": [
                          "containerPort"
                        ]
                      },
                      "type": "array"
                    },
                    "readinessProbe": {
                      "description": "Probe describes a health check to be performed against a container to determine whether it is alive or ready to receive traffic.",
                      "properties": {
                        "exec": {
                          "description": "ExecAction describes a \"run in container\" action.",
                          "properties": {
                            "command": {
                              "description": "Command is the command line to execute inside the container, the working directory for the command  is root ('/') in the container's filesystem. The command is simply exec'd, it is not run inside a shell, so traditional shell instructions ('|', etc) won't work. To use a shell, you need to explicitly call out to that shell. Exit status of 0 is treated as live/healthy and non-zero is unhealthy.",
                              "items": {
                                "type": "string"
                              },
                              "type": "array"
                            }
                          }
                        },
                        "failureThreshold": {
                          "description": "Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1.",
                          "format": "int32",
                          "type": "integer"
                        },
                        "httpGet": {
                          "description": "HTTPGetAction describes an action based on HTTP Get requests.",
                          "properties": {
                            "host": {
                              "description": "Host name to connect to, defaults to the pod IP. You probably want to set \"Host\" in httpHeaders instead.",
                              "type": "string"
                            },
                            "httpHeaders": {
                              "description": "Custom headers to set in the request. HTTP allows repeated headers.",
                              "items": {
                                "description": "HTTPHeader describes a custom header to be used in HTTP probes",
                                "properties": {
                                  "name": {
                                    "description": "The header field name",
                                    "type": "string"
                                  },
                                  "value": {
                                    "description": "The header field value",
                                    "type": "string"
                                  }
                                },
                                "required": [
                                  "name",
                                  "value"
                                ]
                              },
                              "type": "array"
                            },
                            "path": {
                              "description": "Path to access on the HTTP server.",
                              "type": "string"
                            },
                            "port": {
                              "anyOf": [
                                {
                                  "type": "string"
                                },
                                {
                                  "type": "integer"
                                }
                              ]
                            },
                            "scheme": {
                              "description": "Scheme to use for connecting to the host. Defaults to HTTP.",
                              "type": "string"
                            }
                          },
                          "required": [
                            "port"
                          ]
                        },
                        "initialDelaySeconds": {
                          "description": "Number of seconds after the container has started before liveness probes are initiated. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes",
                          "format": "int32",
                          "type": "integer"
                        },
                        "periodSeconds": {
                          "description": "How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1.",
                          "format": "int32",
                          "type": "integer"
                        },
                        "successThreshold": {
                          "description": "Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness. Minimum value is 1.",
                          "format": "int32",
                          "type": "integer"
                        },
                        "tcpSocket": {
                          "description": "TCPSocketAction describes an action based on opening a socket",
                          "properties": {
                            "host": {
                              "description": "Optional: Host name to connect to, defaults to the pod IP.",
                              "type": "string"
                            },
                            "port": {
                              "anyOf": [
                                {
                                  "type": "string"
                                },
                                {
                                  "type": "integer"
                                }
                              ]
                            }
                          },
                          "required": [
                            "port"
                          ]
                        },
                        "timeoutSeconds": {
                          "description": "Number of seconds after which the probe times out. Defaults to 1 second. Minimum value is 1. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes",
                          "format": "int32",
                          "type": "integer"
                        }
                      }
                    },
                    "resources": {
                      "description": "ResourceRequirements describes the compute resource requirements.",
                      "properties": {
                        "limits": {
                          "description": "Limits describes the maximum amount of compute resources allowed. More info: https://kubernetes.io/docs/concepts/configuration/manage-compute-resources-container/",
                          "type": "object"
                        },
                        "requests": {
                          "description": "Requests describes the minimum amount of compute resources required. If Requests is omitted for a container, it defaults to Limits if that is explicitly specified, otherwise to an implementation-defined value. More info: https://kubernetes.io/docs/concepts/configuration/manage-compute-resources-container/",
                          "type": "object"
                        }
                      }
                    },
                    "securityContext": {
                      "description": "SecurityContext holds security configuration that will be applied to a container. Some fields are present in both SecurityContext and PodSecurityContext.  When both are set, the values in SecurityContext take precedence.",
                      "properties": {
                        "allowPrivilegeEscalation": {
                          "description": "AllowPrivilegeEscalation controls whether a process can gain more privileges than its parent process. This bool directly controls if the no_new_privs flag will be set on the container process. AllowPrivilegeEscalation is true always when the container is: 1) run as Privileged 2) has CAP_SYS_ADMIN",
                          "type": "boolean"
                        },
                        "capabilities": {
                          "description": "Adds and removes POSIX capabilities from running containers.",
                          "properties": {
                            "add": {
                              "description": "Added capabilities",
                              "items": {
                                "type": "string"
                              },
                              "type": "array"
                            },
                            "drop": {
                              "description": "Removed capabilities",
                              "items": {
                                "type": "string"
                              },
                              "type": "array"
                            }
                          }
                        },
                        "privileged": {
                          "description": "Run container in privileged mode. Processes in privileged containers are essentially equivalent to root on the host. Defaults to false.",
                          "type": "boolean"
                        },
                        "procMount": {
                          "description": "procMount denotes the type of proc mount to use for the containers. The default is DefaultProcMount which uses the container runtime defaults for readonly paths and masked paths. This requires the ProcMountType feature flag to be enabled.",
                          "type": "string"
                        },
                        "readOnlyRootFilesystem": {
                          "description": "Whether this container has a read-only root filesystem. Default is false.",
                          "type": "boolean"
                        },
                        "runAsGroup": {
                          "description": "The GID to run the entrypoint of the container process. Uses runtime default if unset. May also be set in PodSecurityContext.  If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.",
                          "format": "int64",
                          "type": "integer"
                        },
                        "runAsNonRoot": {
                          "description": "Indicates that the container must run as a non-root user. If true, the Kubelet will validate the image at runtime to ensure that it does not run as UID 0 (root) and fail to start the container if it does. If unset or false, no such validation will be performed. May also be set in PodSecurityContext.  If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.",
                          "type": "boolean"
                        },
                        "runAsUser": {
                          "description": "The UID to run the entrypoint of the container process. Defaults to user specified in image metadata if unspecified. May also be set in PodSecurityContext.  If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.",
                          "format": "int64",
                          "type": "integer"
                        },
                        "seLinuxOptions": {
                          "description": "SELinuxOptions are the labels to be applied to the container",
                          "properties": {
                            "level": {
                              "description": "Level is SELinux level label that applies to the container.",
                              "type": "string"
                            },
                            "role": {
                              "description": "Role is a SELinux role label that applies to the container.",
                              "type": "string"
                            },
                            "type": {
                              "description": "Type is a SELinux type label that applies to the container.",
                              "type": "string"
                            },
                            "user": {
                              "description": "User is a SELinux user label that applies to the container.",
                              "type": "string"
                            }
                          }
                        }
                      }
                    },
                    "stdin": {
                      "description": "Whether this container should allocate a buffer for stdin in the container runtime. If this is not set, reads from stdin in the container will always result in EOF. Default is false.",
                      "type": "boolean"
                    },
                    "stdinOnce": {
                      "description": "Whether the container runtime should close the stdin channel after it has been opened by a single attach. When stdin is true the stdin stream will remain open across multiple attach sessions. If stdinOnce is set to true, stdin is opened on container start, is empty until the first client attaches to stdin, and then remains open and accepts data until the client disconnects, at which time stdin is closed and remains closed until the container is restarted. If this flag is false, a container processes that reads from stdin will never receive an EOF. Default is false",
                      "type": "boolean"
                    },
                    "terminationMessagePath": {
                      "description": "Optional: Path at which the file to which the container's termination message will be written is mounted into the container's filesystem. Message written is intended to be brief final status, such as an assertion failure message. Will be truncated by the node if greater than 4096 bytes. The total message length across all containers will be limited to 12kb. Defaults to /dev/termination-log. Cannot be updated.",
                      "type": "string"
                    },
                    "terminationMessagePolicy": {
                      "description": "Indicate how the termination message should be populated. File will use the contents of terminationMessagePath to populate the container status message on both success and failure. FallbackToLogsOnError will use the last chunk of container log output if the termination message file is empty and the container exited with an error. The log output is limited to 2048 bytes or 80 lines, whichever is smaller. Defaults to File. Cannot be updated.",
                      "type": "string"
                    },
                    "tty": {
                      "description": "Whether this container should allocate a TTY for itself, also requires 'stdin' to be true. Default is false.",
                      "type": "boolean"
                    },
                    "volumeDevices": {
                      "description": "volumeDevices is the list of block devices to be used by the container. This is an alpha feature and may change in the future.",
                      "items": {
                        "description": "volumeDevice describes a mapping of a raw block device within a container.",
                        "properties": {
                          "devicePath": {
                            "description": "devicePath is the path inside of the container that the device will be mapped to.",
                            "type": "string"
                          },
                          "name": {
                            "description": "name must match the name of a persistentVolumeClaim in the pod",
                            "type": "string"
                          }
                        },
                        "required": [
                          "name",
                          "devicePath"
                        ]
                      },
                      "type": "array"
                    },
                    "volumeMounts": {
                      "description": "Pod volumes to mount into the container's filesystem. Cannot be updated.",
                      "items": {
                        "description": "VolumeMount describes a mounting of a Volume within a container.",
                        "properties": {
                          "mountPath": {
                            "description": "Path within the container at which the volume should be mounted.  Must not contain ':'.",
                            "type": "string"
                          },
                          "mountPropagation": {
                            "description": "mountPropagation determines how mounts are propagated from the host to container and the other way around. When not set, MountPropagationNone is used. This field is beta in 1.10.",
                            "type": "string"
                          },
                          "name": {
                            "description": "This must match the Name of a Volume.",
                            "type": "string"
                          },
                          "readOnly": {
                            "description": "Mounted read-only if true, read-write otherwise (false or unspecified). Defaults to false.",
                            "type": "boolean"
                          },
                          "subPath": {
                            "description": "Path within the volume from which the container's volume should be mounted. Defaults to \"\" (volume's root).",
                            "type": "string"
                          }
                        },
                        "required": [
                          "name",
                          "mountPath"
                        ]
                      },
                      "type": "array"
                    },
                    "workingDir": {
                      "description": "Container's working directory. If not specified, the container runtime's default will be used, which might be configured in the container image. Cannot be updated.",
                      "type": "string"
                    }
                  },
                  "required": [
                    "name"
                  ]
                },
                "type": "array"
              },
              "evaluationInterval": {
                "description": "Interval between consecutive evaluations.",
                "type": "string"
              },
              "externalLabels": {
                "description": "The labels to add to any time series or alerts when communicating with external systems (federation, remote storage, Alertmanager).",
                "type": "object"
              },
              "externalUrl": {
                "description": "The external URL the Prometheus instances will be available under. This is necessary to generate correct URLs. This is necessary if Prometheus is not served from root of a DNS name.",
                "type": "string"
              },
              "image": {
                "description": "Image if specified has precedence over baseImage, tag and sha combinations. Specifying the version is still necessary to ensure the Prometheus Operator knows what version of Prometheus is being configured.",
                "type": "string"
              },
              "imagePullSecrets": {
                "description": "An optional list of references to secrets in the same namespace to use for pulling prometheus and alertmanager images from registries see http://kubernetes.io/docs/user-guide/images#specifying-imagepullsecrets-on-a-pod",
                "items": {
                  "description": "LocalObjectReference contains enough information to let you locate the referenced object inside the same namespace.",
                  "properties": {
                    "name": {
                      "description": "Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names",
                      "type": "string"
                    }
                  }
                },
                "type": "array"
              },
              "listenLocal": {
                "description": "ListenLocal makes the Prometheus server listen on loopback, so that it does not bind against the Pod IP.",
                "type": "boolean"
              },
              "logLevel": {
                "description": "Log level for Prometheus to be configured with.",
                "type": "string"
              },
              "nodeSelector": {
                "description": "Define which Nodes the Pods are scheduled on.",
                "type": "object"
              },
              "paused": {
                "description": "When a Prometheus deployment is paused, no actions except for deletion will be performed on the underlying objects.",
                "type": "boolean"
              },
              "podMetadata": {
                "description": "ObjectMeta is metadata that all persisted resources must have, which includes all objects users must create.",
                "properties": {
                  "annotations": {
                    "description": "Annotations is an unstructured key value map stored with a resource that may be set by external tools to store and retrieve arbitrary metadata. They are not queryable and should be preserved when modifying objects. More info: http://kubernetes.io/docs/user-guide/annotations",
                    "type": "object"
                  },
                  "clusterName": {
                    "description": "The name of the cluster which the object belongs to. This is used to distinguish resources with same name and namespace in different clusters. This field is not set anywhere right now and apiserver is going to ignore it if set in create or update request.",
                    "type": "string"
                  },
                  "creationTimestamp": {
                    "description": "Time is a wrapper around time.Time which supports correct marshaling to YAML and JSON.  Wrappers are provided for many of the factory methods that the time package offers.",
                    "format": "date-time",
                    "type": "string"
                  },
                  "deletionGracePeriodSeconds": {
                    "description": "Number of seconds allowed for this object to gracefully terminate before it will be removed from the system. Only set when deletionTimestamp is also set. May only be shortened. Read-only.",
                    "format": "int64",
                    "type": "integer"
                  },
                  "deletionTimestamp": {
                    "description": "Time is a wrapper around time.Time which supports correct marshaling to YAML and JSON.  Wrappers are provided for many of the factory methods that the time package offers.",
                    "format": "date-time",
                    "type": "string"
                  },
                  "finalizers": {
                    "description": "Must be empty before the object is deleted from the registry. Each entry is an identifier for the responsible component that will remove the entry from the list. If the deletionTimestamp of the object is non-nil, entries in this list can only be removed.",
                    "items": {
                      "type": "string"
                    },
                    "type": "array"
                  },
                  "generateName": {
                    "description": "GenerateName is an optional prefix, used by the server, to generate a unique name ONLY IF the Name field has not been provided. If this field is used, the name returned to the client will be different than the name passed. This value will also be combined with a unique suffix. The provided value has the same validation rules as the Name field, and may be truncated by the length of the suffix required to make the value unique on the server.\n\nIf this field is specified and the generated name exists, the server will NOT return a 409 - instead, it will either return 201 Created or 500 with Reason ServerTimeout indicating a unique name could not be found in the time allotted, and the client should retry (optionally after the time indicated in the Retry-After header).\n\nApplied only if Name is not specified. More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#idempotency",
                    "type": "string"
                  },
                  "generation": {
                    "description": "A sequence number representing a specific generation of the desired state. Populated by the system. Read-only.",
                    "format": "int64",
                    "type": "integer"
                  },
                  "initializers": {
                    "description": "Initializers tracks the progress of initialization.",
                    "properties": {
                      "pending": {
                        "description": "Pending is a list of initializers that must execute in order before this object is visible. When the last pending initializer is removed, and no failing result is set, the initializers struct will be set to nil and the object is considered as initialized and visible to all clients.",
                        "items": {
                          "description": "Initializer is information about an initializer that has not yet completed.",
                          "properties": {
                            "name": {
                              "description": "name of the process that is responsible for initializing this object.",
                              "type": "string"
                            }
                          },
                          "required": [
                            "name"
                          ]
                        },
                        "type": "array"
                      },
                      "result": {
                        "description": "Status is a return value for calls that don't return other objects.",
                        "properties": {
                          "apiVersion": {
                            "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#resources",
                            "type": "string"
                          },
                          "code": {
                            "description": "Suggested HTTP return code for this status, 0 if not set.",
                            "format": "int32",
                            "type": "integer"
                          },
                          "details": {
                            "description": "StatusDetails is a set of additional properties that MAY be set by the server to provide additional information about a response. The Reason field of a Status object defines what attributes will be set. Clients must ignore fields that do not match the defined type of each attribute, and should assume that any attribute may be empty, invalid, or under defined.",
                            "properties": {
                              "causes": {
                                "description": "The Causes array includes more details associated with the StatusReason failure. Not all StatusReasons may provide detailed causes.",
                                "items": {
                                  "description": "StatusCause provides more information about an api.Status failure, including cases when multiple errors are encountered.",
                                  "properties": {
                                    "field": {
                                      "description": "The field of the resource that has caused this error, as named by its JSON serialization. May include dot and postfix notation for nested attributes. Arrays are zero-indexed.  Fields may appear more than once in an array of causes due to fields having multiple errors. Optional.\n\nExamples:\n  \"name\" - the field \"name\" on the current resource\n  \"items[0].name\" - the field \"name\" on the first array entry in \"items\"",
                                      "type": "string"
                                    },
                                    "message": {
                                      "description": "A human-readable description of the cause of the error.  This field may be presented as-is to a reader.",
                                      "type": "string"
                                    },
                                    "reason": {
                                      "description": "A machine-readable description of the cause of the error. If this value is empty there is no information available.",
                                      "type": "string"
                                    }
                                  }
                                },
                                "type": "array"
                              },
                              "group": {
                                "description": "The group attribute of the resource associated with the status StatusReason.",
                                "type": "string"
                              },
                              "kind": {
                                "description": "The kind attribute of the resource associated with the status StatusReason. On some operations may differ from the requested resource Kind. More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#types-kinds",
                                "type": "string"
                              },
                              "name": {
                                "description": "The name attribute of the resource associated with the status StatusReason (when there is a single name which can be described).",
                                "type": "string"
                              },
                              "retryAfterSeconds": {
                                "description": "If specified, the time in seconds before the operation should be retried. Some errors may indicate the client must take an alternate action - for those errors this field may indicate how long to wait before taking the alternate action.",
                                "format": "int32",
                                "type": "integer"
                              },
                              "uid": {
                                "description": "UID of the resource. (when there is a single resource which can be described). More info: http://kubernetes.io/docs/user-guide/identifiers#uids",
                                "type": "string"
                              }
                            }
                          },
                          "kind": {
                            "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#types-kinds",
                            "type": "string"
                          },
                          "message": {
                            "description": "A human-readable description of the status of this operation.",
                            "type": "string"
                          },
                          "metadata": {
                            "description": "ListMeta describes metadata that synthetic resources must have, including lists and various status objects. A resource may have only one of {ObjectMeta, ListMeta}.",
                            "properties": {
                              "continue": {
                                "description": "continue may be set if the user set a limit on the number of items returned, and indicates that the server has more data available. The value is opaque and may be used to issue another request to the endpoint that served this list to retrieve the next set of available objects. Continuing a consistent list may not be possible if the server configuration has changed or more than a few minutes have passed. The resourceVersion field returned when using this continue value will be identical to the value in the first response, unless you have received this token from an error message.",
                                "type": "string"
                              },
                              "resourceVersion": {
                                "description": "String that identifies the server's internal version of this object that can be used by clients to determine when objects have changed. Value must be treated as opaque by clients and passed unmodified back to the server. Populated by the system. Read-only. More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#concurrency-control-and-consistency",
                                "type": "string"
                              },
                              "selfLink": {
                                "description": "selfLink is a URL representing this object. Populated by the system. Read-only.",
                                "type": "string"
                              }
                            }
                          },
                          "reason": {
                            "description": "A machine-readable description of why this operation is in the \"Failure\" status. If this value is empty there is no information available. A Reason clarifies an HTTP status code but does not override it.",
                            "type": "string"
                          },
                          "status": {
                            "description": "Status of the operation. One of: \"Success\" or \"Failure\". More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#spec-and-status",
                            "type": "string"
                          }
                        }
                      }
                    },
                    "required": [
                      "pending"
                    ]
                  },
                  "labels": {
                    "description": "Map of string keys and values that can be used to organize and categorize (scope and select) objects. May match selectors of replication controllers and services. More info: http://kubernetes.io/docs/user-guide/labels",
                    "type": "object"
                  },
                  "name": {
                    "description": "Name must be unique within a namespace. Is required when creating resources, although some resources may allow a client to request the generation of an appropriate name automatically. Name is primarily intended for creation idempotence and configuration definition. Cannot be updated. More info: http://kubernetes.io/docs/user-guide/identifiers#names",
                    "type": "string"
                  },
                  "namespace": {
                    "description": "Namespace defines the space within each name must be unique. An empty namespace is equivalent to the \"default\" namespace, but \"default\" is the canonical representation. Not all objects are required to be scoped to a namespace - the value of this field for those objects will be empty.\n\nMust be a DNS_LABEL. Cannot be updated. More info: http://kubernetes.io/docs/user-guide/namespaces",
                    "type": "string"
                  },
                  "ownerReferences": {
                    "description": "List of objects depended by this object. If ALL objects in the list have been deleted, this object will be garbage collected. If this object is managed by a controller, then an entry in this list will point to this controller, with the controller field set to true. There cannot be more than one managing controller.",
                    "items": {
                      "description": "OwnerReference contains enough information to let you identify an owning object. Currently, an owning object must be in the same namespace, so there is no namespace field.",
                      "properties": {
                        "apiVersion": {
                          "description": "API version of the referent.",
                          "type": "string"
                        },
                        "blockOwnerDeletion": {
                          "description": "If true, AND if the owner has the \"foregroundDeletion\" finalizer, then the owner cannot be deleted from the key-value store until this reference is removed. Defaults to false. To set this field, a user needs \"delete\" permission of the owner, otherwise 422 (Unprocessable Entity) will be returned.",
                          "type": "boolean"
                        },
                        "controller": {
                          "description": "If true, this reference points to the managing controller.",
                          "type": "boolean"
                        },
                        "kind": {
                          "description": "Kind of the referent. More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#types-kinds",
                          "type": "string"
                        },
                        "name": {
                          "description": "Name of the referent. More info: http://kubernetes.io/docs/user-guide/identifiers#names",
                          "type": "string"
                        },
                        "uid": {
                          "description": "UID of the referent. More info: http://kubernetes.io/docs/user-guide/identifiers#uids",
                          "type": "string"
                        }
                      },
                      "required": [
                        "apiVersion",
                        "kind",
                        "name",
                        "uid"
                      ]
                    },
                    "type": "array"
                  },
                  "resourceVersion": {
                    "description": "An opaque value that represents the internal version of this object that can be used by clients to determine when objects have changed. May be used for optimistic concurrency, change detection, and the watch operation on a resource or set of resources. Clients must treat these values as opaque and passed unmodified back to the server. They may only be valid for a particular resource or set of resources.\n\nPopulated by the system. Read-only. Value must be treated as opaque by clients and . More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#concurrency-control-and-consistency",
                    "type": "string"
                  },
                  "selfLink": {
                    "description": "SelfLink is a URL representing this object. Populated by the system. Read-only.",
                    "type": "string"
                  },
                  "uid": {
                    "description": "UID is the unique in time and space value for this object. It is typically generated by the server on successful creation of a resource and is not allowed to change on PUT operations.\n\nPopulated by the system. Read-only. More info: http://kubernetes.io/docs/user-guide/identifiers#uids",
                    "type": "string"
                  }
                }
              },
              "priorityClassName": {
                "description": "Priority class assigned to the Pods",
                "type": "string"
              },
              "query": {
                "description": "QuerySpec defines the query command line flags when starting Prometheus.",
                "properties": {
                  "lookbackDelta": {
                    "description": "The delta difference allowed for retrieving metrics during expression evaluations.",
                    "type": "string"
                  },
                  "maxConcurrency": {
                    "description": "Number of concurrent queries that can be run at once.",
                    "format": "int32",
                    "type": "integer"
                  },
                  "timeout": {
                    "description": "Maximum time a query may take before being aborted.",
                    "type": "string"
                  }
                }
              },
              "remoteRead": {
                "description": "If specified, the remote_read spec. This is an experimental feature, it may change in any upcoming release in a breaking way.",
                "items": {
                  "description": "RemoteReadSpec defines the remote_read configuration for prometheus.",
                  "properties": {
                    "basicAuth": {
                      "description": "BasicAuth allow an endpoint to authenticate over basic authentication More info: https://prometheus.io/docs/operating/configuration/#endpoints",
                      "properties": {
                        "password": {
                          "description": "SecretKeySelector selects a key of a Secret.",
                          "properties": {
                            "key": {
                              "description": "The key of the secret to select from.  Must be a valid secret key.",
                              "type": "string"
                            },
                            "name": {
                              "description": "Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names",
                              "type": "string"
                            },
                            "optional": {
                              "description": "Specify whether the Secret or it's key must be defined",
                              "type": "boolean"
                            }
                          },
                          "required": [
                            "key"
                          ]
                        },
                        "username": {
                          "description": "SecretKeySelector selects a key of a Secret.",
                          "properties": {
                            "key": {
                              "description": "The key of the secret to select from.  Must be a valid secret key.",
                              "type": "string"
                            },
                            "name": {
                              "description": "Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names",
                              "type": "string"
                            },
                            "optional": {
                              "description": "Specify whether the Secret or it's key must be defined",
                              "type": "boolean"
                            }
                          },
                          "required": [
                            "key"
                          ]
                        }
                      }
                    },
                    "bearerToken": {
                      "description": "bearer token for remote read.",
                      "type": "string"
                    },
                    "bearerTokenFile": {
                      "description": "File to read bearer token for remote read.",
                      "type": "string"
                    },
                    "proxyUrl": {
                      "description": "Optional ProxyURL",
                      "type": "string"
                    },
                    "readRecent": {
                      "description": "Whether reads should be made for queries for time ranges that the local storage should have complete data for.",
                      "type": "boolean"
                    },
                    "remoteTimeout": {
                      "description": "Timeout for requests to the remote read endpoint.",
                      "type": "string"
                    },
                    "requiredMatchers": {
                      "description": "An optional list of equality matchers which have to be present in a selector to query the remote read endpoint.",
                      "type": "object"
                    },
                    "tlsConfig": {
                      "description": "TLSConfig specifies TLS configuration parameters.",
                      "properties": {
                        "caFile": {
                          "description": "The CA cert to use for the targets.",
                          "type": "string"
                        },
                        "certFile": {
                          "description": "The client cert file for the targets.",
                          "type": "string"
                        },
                        "insecureSkipVerify": {
                          "description": "Disable target certificate validation.",
                          "type": "boolean"
                        },
                        "keyFile": {
                          "description": "The client key file for the targets.",
                          "type": "string"
                        },
                        "serverName": {
                          "description": "Used to verify the hostname for the targets.",
                          "type": "string"
                        }
                      }
                    },
                    "url": {
                      "description": "The URL of the endpoint to send samples to.",
                      "type": "string"
                    }
                  },
                  "required": [
                    "url"
                  ]
                },
                "type": "array"
              },
              "remoteWrite": {
                "description": "If specified, the remote_write spec. This is an experimental feature, it may change in any upcoming release in a breaking way.",
                "items": {
                  "description": "RemoteWriteSpec defines the remote_write configuration for prometheus.",
                  "properties": {
                    "basicAuth": {
                      "description": "BasicAuth allow an endpoint to authenticate over basic authentication More info: https://prometheus.io/docs/operating/configuration/#endpoints",
                      "properties": {
                        "password": {
                          "description": "SecretKeySelector selects a key of a Secret.",
                          "properties": {
                            "key": {
                              "description": "The key of the secret to select from.  Must be a valid secret key.",
                              "type": "string"
                            },
                            "name": {
                              "description": "Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names",
                              "type": "string"
                            },
                            "optional": {
                              "description": "Specify whether the Secret or it's key must be defined",
                              "type": "boolean"
                            }
                          },
                          "required": [
                            "key"
                          ]
                        },
                        "username": {
                          "description": "SecretKeySelector selects a key of a Secret.",
                          "properties": {
                            "key": {
                              "description": "The key of the secret to select from.  Must be a valid secret key.",
                              "type": "string"
                            },
                            "name": {
                              "description": "Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names",
                              "type": "string"
                            },
                            "optional": {
                              "description": "Specify whether the Secret or it's key must be defined",
                              "type": "boolean"
                            }
                          },
                          "required": [
                            "key"
                          ]
                        }
                      }
                    },
                    "bearerToken": {
                      "description": "File to read bearer token for remote write.",
                      "type": "string"
                    },
                    "bearerTokenFile": {
                      "description": "File to read bearer token for remote write.",
                      "type": "string"
                    },
                    "proxyUrl": {
                      "description": "Optional ProxyURL",
                      "type": "string"
                    },
                    "queueConfig": {
                      "description": "QueueConfig allows the tuning of remote_write queue_config parameters. This object is referenced in the RemoteWriteSpec object.",
                      "properties": {
                        "batchSendDeadline": {
                          "description": "BatchSendDeadline is the maximum time a sample will wait in buffer.",
                          "type": "string"
                        },
                        "capacity": {
                          "description": "Capacity is the number of samples to buffer per shard before we start dropping them.",
                          "format": "int32",
                          "type": "integer"
                        },
                        "maxBackoff": {
                          "description": "MaxBackoff is the maximum retry delay.",
                          "type": "string"
                        },
                        "maxRetries": {
                          "description": "MaxRetries is the maximum number of times to retry a batch on recoverable errors.",
                          "format": "int32",
                          "type": "integer"
                        },
                        "maxSamplesPerSend": {
                          "description": "MaxSamplesPerSend is the maximum number of samples per send.",
                          "format": "int32",
                          "type": "integer"
                        },
                        "maxShards": {
                          "description": "MaxShards is the maximum number of shards, i.e. amount of concurrency.",
                          "format": "int32",
                          "type": "integer"
                        },
                        "minBackoff": {
                          "description": "MinBackoff is the initial retry delay. Gets doubled for every retry.",
                          "type": "string"
                        }
                      }
                    },
                    "remoteTimeout": {
                      "description": "Timeout for requests to the remote write endpoint.",
                      "type": "string"
                    },
                    "tlsConfig": {
                      "description": "TLSConfig specifies TLS configuration parameters.",
                      "properties": {
                        "caFile": {
                          "description": "The CA cert to use for the targets.",
                          "type": "string"
                        },
                        "certFile": {
                          "description": "The client cert file for the targets.",
                          "type": "string"
                        },
                        "insecureSkipVerify": {
                          "description": "Disable target certificate validation.",
                          "type": "boolean"
                        },
                        "keyFile": {
                          "description": "The client key file for the targets.",
                          "type": "string"
                        },
                        "serverName": {
                          "description": "Used to verify the hostname for the targets.",
                          "type": "string"
                        }
                      }
                    },
                    "url": {
                      "description": "The URL of the endpoint to send samples to.",
                      "type": "string"
                    },
                    "writeRelabelConfigs": {
                      "description": "The list of remote write relabel configurations.",
                      "items": {
                        "description": "RelabelConfig allows dynamic rewriting of the label set, being applied to samples before ingestion. It defines `<metric_relabel_configs>`-section of Prometheus configuration. More info: https://prometheus.io/docs/prometheus/latest/configuration/configuration/#metric_relabel_configs",
                        "properties": {
                          "action": {
                            "description": "Action to perform based on regex matching. Default is 'replace'",
                            "type": "string"
                          },
                          "modulus": {
                            "description": "Modulus to take of the hash of the source label values.",
                            "format": "int64",
                            "type": "integer"
                          },
                          "regex": {
                            "description": "Regular expression against which the extracted value is matched. default is '(.*)'",
                            "type": "string"
                          },
                          "replacement": {
                            "description": "Replacement value against which a regex replace is performed if the regular expression matches. Regex capture groups are available. Default is '$1'",
                            "type": "string"
                          },
                          "separator": {
                            "description": "Separator placed between concatenated source label values. default is ';'.",
                            "type": "string"
                          },
                          "sourceLabels": {
                            "description": "The source labels select values from existing labels. Their content is concatenated using the configured separator and matched against the configured regular expression for the replace, keep, and drop actions.",
                            "items": {
                              "type": "string"
                            },
                            "type": "array"
                          },
                          "targetLabel": {
                            "description": "Label to which the resulting value is written in a replace action. It is mandatory for replace actions. Regex capture groups are available.",
                            "type": "string"
                          }
                        }
                      },
                      "type": "array"
                    }
                  },
                  "required": [
                    "url"
                  ]
                },
                "type": "array"
              },
              "replicas": {
                "description": "Number of instances to deploy for a Prometheus deployment.",
                "format": "int32",
                "type": "integer"
              },
              "resources": {
                "description": "ResourceRequirements describes the compute resource requirements.",
                "properties": {
                  "limits": {
                    "description": "Limits describes the maximum amount of compute resources allowed. More info: https://kubernetes.io/docs/concepts/configuration/manage-compute-resources-container/",
                    "type": "object"
                  },
                  "requests": {
                    "description": "Requests describes the minimum amount of compute resources required. If Requests is omitted for a container, it defaults to Limits if that is explicitly specified, otherwise to an implementation-defined value. More info: https://kubernetes.io/docs/concepts/configuration/manage-compute-resources-container/",
                    "type": "object"
                  }
                }
              },
              "retention": {
                "description": "Time duration Prometheus shall retain data for. Default is '24h', and must match the regular expression `[0-9]+(ms|s|m|h|d|w|y)` (milliseconds seconds minutes hours days weeks years).",
                "type": "string"
              },
              "routePrefix": {
                "description": "The route prefix Prometheus registers HTTP handlers for. This is useful, if using ExternalURL and a proxy is rewriting HTTP routes of a request, and the actual ExternalURL is still true, but the server serves requests under a different route prefix. For example for use with `kubectl proxy`.",
                "type": "string"
              },
              "ruleNamespaceSelector": {
                "description": "A label selector is a label query over a set of resources. The result of matchLabels and matchExpressions are ANDed. An empty label selector matches all objects. A null label selector matches no objects.",
                "properties": {
                  "matchExpressions": {
                    "description": "matchExpressions is a list of label selector requirements. The requirements are ANDed.",
                    "items": {
                      "description": "A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.",
                      "properties": {
                        "key": {
                          "description": "key is the label key that the selector applies to.",
                          "type": "string"
                        },
                        "operator": {
                          "description": "operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.",
                          "type": "string"
                        },
                        "values": {
                          "description": "values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.",
                          "items": {
                            "type": "string"
                          },
                          "type": "array"
                        }
                      },
                      "required": [
                        "key",
                        "operator"
                      ]
                    },
                    "type": "array"
                  },
                  "matchLabels": {
                    "description": "matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is \"key\", the operator is \"In\", and the values array contains only \"value\". The requirements are ANDed.",
                    "type": "object"
                  }
                }
              },
              "ruleSelector": {
                "description": "A label selector is a label query over a set of resources. The result of matchLabels and matchExpressions are ANDed. An empty label selector matches all objects. A null label selector matches no objects.",
                "properties": {
                  "matchExpressions": {
                    "description": "matchExpressions is a list of label selector requirements. The requirements are ANDed.",
                    "items": {
                      "description": "A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.",
                      "properties": {
                        "key": {
                          "description": "key is the label key that the selector applies to.",
                          "type": "string"
                        },
                        "operator": {
                          "description": "operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.",
                          "type": "string"
                        },
                        "values": {
                          "description": "values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.",
                          "items": {
                            "type": "string"
                          },
                          "type": "array"
                        }
                      },
                      "required": [
                        "key",
                        "operator"
                      ]
                    },
                    "type": "array"
                  },
                  "matchLabels": {
                    "description": "matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is \"key\", the operator is \"In\", and the values array contains only \"value\". The requirements are ANDed.",
                    "type": "object"
                  }
                }
              },
              "scrapeInterval": {
                "description": "Interval between consecutive scrapes.",
                "type": "string"
              },
              "secrets": {
                "description": "Secrets is a list of Secrets in the same namespace as the Prometheus object, which shall be mounted into the Prometheus Pods. The Secrets are mounted into /etc/prometheus/secrets/<secret-name>.",
                "items": {
                  "type": "string"
                },
                "type": "array"
              },
              "securityContext": {
                "description": "PodSecurityContext holds pod-level security attributes and common container settings. Some fields are also present in container.securityContext.  Field values of container.securityContext take precedence over field values of PodSecurityContext.",
                "properties": {
                  "fsGroup": {
                    "description": "A special supplemental group that applies to all containers in a pod. Some volume types allow the Kubelet to change the ownership of that volume to be owned by the pod:\n\n1. The owning GID will be the FSGroup 2. The setgid bit is set (new files created in the volume will be owned by FSGroup) 3. The permission bits are OR'd with rw-rw----\n\nIf unset, the Kubelet will not modify the ownership and permissions of any volume.",
                    "format": "int64",
                    "type": "integer"
                  },
                  "runAsGroup": {
                    "description": "The GID to run the entrypoint of the container process. Uses runtime default if unset. May also be set in SecurityContext.  If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence for that container.",
                    "format": "int64",
                    "type": "integer"
                  },
                  "runAsNonRoot": {
                    "description": "Indicates that the container must run as a non-root user. If true, the Kubelet will validate the image at runtime to ensure that it does not run as UID 0 (root) and fail to start the container if it does. If unset or false, no such validation will be performed. May also be set in SecurityContext.  If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.",
                    "type": "boolean"
                  },
                  "runAsUser": {
                    "description": "The UID to run the entrypoint of the container process. Defaults to user specified in image metadata if unspecified. May also be set in SecurityContext.  If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence for that container.",
                    "format": "int64",
                    "type": "integer"
                  },
                  "seLinuxOptions": {
                    "description": "SELinuxOptions are the labels to be applied to the container",
                    "properties": {
                      "level": {
                        "description": "Level is SELinux level label that applies to the container.",
                        "type": "string"
                      },
                      "role": {
                        "description": "Role is a SELinux role label that applies to the container.",
                        "type": "string"
                      },
                      "type": {
                        "description": "Type is a SELinux type label that applies to the container.",
                        "type": "string"
                      },
                      "user": {
                        "description": "User is a SELinux user label that applies to the container.",
                        "type": "string"
                      }
                    }
                  },
                  "supplementalGroups": {
                    "description": "A list of groups applied to the first process run in each container, in addition to the container's primary GID.  If unspecified, no groups will be added to any container.",
                    "items": {
                      "format": "int64",
                      "type": "integer"
                    },
                    "type": "array"
                  },
                  "sysctls": {
                    "description": "Sysctls hold a list of namespaced sysctls used for the pod. Pods with unsupported sysctls (by the container runtime) might fail to launch.",
                    "items": {
                      "description": "Sysctl defines a kernel parameter to be set",
                      "properties": {
                        "name": {
                          "description": "Name of a property to set",
                          "type": "string"
                        },
                        "value": {
                          "description": "Value of a property to set",
                          "type": "string"
                        }
                      },
                      "required": [
                        "name",
                        "value"
                      ]
                    },
                    "type": "array"
                  }
                }
              },
              "serviceAccountName": {
                "description": "ServiceAccountName is the name of the ServiceAccount to use to run the Prometheus Pods.",
                "type": "string"
              },
              "serviceMonitorNamespaceSelector": {
                "description": "A label selector is a label query over a set of resources. The result of matchLabels and matchExpressions are ANDed. An empty label selector matches all objects. A null label selector matches no objects.",
                "properties": {
                  "matchExpressions": {
                    "description": "matchExpressions is a list of label selector requirements. The requirements are ANDed.",
                    "items": {
                      "description": "A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.",
                      "properties": {
                        "key": {
                          "description": "key is the label key that the selector applies to.",
                          "type": "string"
                        },
                        "operator": {
                          "description": "operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.",
                          "type": "string"
                        },
                        "values": {
                          "description": "values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.",
                          "items": {
                            "type": "string"
                          },
                          "type": "array"
                        }
                      },
                      "required": [
                        "key",
                        "operator"
                      ]
                    },
                    "type": "array"
                  },
                  "matchLabels": {
                    "description": "matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is \"key\", the operator is \"In\", and the values array contains only \"value\". The requirements are ANDed.",
                    "type": "object"
                  }
                }
              },
              "serviceMonitorSelector": {
                "description": "A label selector is a label query over a set of resources. The result of matchLabels and matchExpressions are ANDed. An empty label selector matches all objects. A null label selector matches no objects.",
                "properties": {
                  "matchExpressions": {
                    "description": "matchExpressions is a list of label selector requirements. The requirements are ANDed.",
                    "items": {
                      "description": "A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.",
                      "properties": {
                        "key": {
                          "description": "key is the label key that the selector applies to.",
                          "type": "string"
                        },
                        "operator": {
                          "description": "operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.",
                          "type": "string"
                        },
                        "values": {
                          "description": "values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.",
                          "items": {
                            "type": "string"
                          },
                          "type": "array"
                        }
                      },
                      "required": [
                        "key",
                        "operator"
                      ]
                    },
                    "type": "array"
                  },
                  "matchLabels": {
                    "description": "matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is \"key\", the operator is \"In\", and the values array contains only \"value\". The requirements are ANDed.",
                    "type": "object"
                  }
                }
              },
              "sha": {
                "description": "SHA of Prometheus container image to be deployed. Defaults to the value of `version`. Similar to a tag, but the SHA explicitly deploys an immutable container image. Version and Tag are ignored if SHA is set.",
                "type": "string"
              },
              "storage": {
                "description": "StorageSpec defines the configured storage for a group Prometheus servers. If neither `emptyDir` nor `volumeClaimTemplate` is specified, then by default an [EmptyDir](https://kubernetes.io/docs/concepts/storage/volumes/#emptydir) will be used.",
                "properties": {
                  "emptyDir": {
                    "description": "Represents an empty directory for a pod. Empty directory volumes support ownership management and SELinux relabeling.",
                    "properties": {
                      "medium": {
                        "description": "What type of storage medium should back this directory. The default is \"\" which means to use the node's default medium. Must be an empty string (default) or Memory. More info: https://kubernetes.io/docs/concepts/storage/volumes#emptydir",
                        "type": "string"
                      },
                      "sizeLimit": {}
                    }
                  },
                  "volumeClaimTemplate": {
                    "description": "PersistentVolumeClaim is a user's request for and claim to a persistent volume",
                    "properties": {
                      "apiVersion": {
                        "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#resources",
                        "type": "string"
                      },
                      "kind": {
                        "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#types-kinds",
                        "type": "string"
                      },
                      "metadata": {
                        "description": "ObjectMeta is metadata that all persisted resources must have, which includes all objects users must create.",
                        "properties": {
                          "annotations": {
                            "description": "Annotations is an unstructured key value map stored with a resource that may be set by external tools to store and retrieve arbitrary metadata. They are not queryable and should be preserved when modifying objects. More info: http://kubernetes.io/docs/user-guide/annotations",
                            "type": "object"
                          },
                          "clusterName": {
                            "description": "The name of the cluster which the object belongs to. This is used to distinguish resources with same name and namespace in different clusters. This field is not set anywhere right now and apiserver is going to ignore it if set in create or update request.",
                            "type": "string"
                          },
                          "creationTimestamp": {
                            "description": "Time is a wrapper around time.Time which supports correct marshaling to YAML and JSON.  Wrappers are provided for many of the factory methods that the time package offers.",
                            "format": "date-time",
                            "type": "string"
                          },
                          "deletionGracePeriodSeconds": {
                            "description": "Number of seconds allowed for this object to gracefully terminate before it will be removed from the system. Only set when deletionTimestamp is also set. May only be shortened. Read-only.",
                            "format": "int64",
                            "type": "integer"
                          },
                          "deletionTimestamp": {
                            "description": "Time is a wrapper around time.Time which supports correct marshaling to YAML and JSON.  Wrappers are provided for many of the factory methods that the time package offers.",
                            "format": "date-time",
                            "type": "string"
                          },
                          "finalizers": {
                            "description": "Must be empty before the object is deleted from the registry. Each entry is an identifier for the responsible component that will remove the entry from the list. If the deletionTimestamp of the object is non-nil, entries in this list can only be removed.",
                            "items": {
                              "type": "string"
                            },
                            "type": "array"
                          },
                          "generateName": {
                            "description": "GenerateName is an optional prefix, used by the server, to generate a unique name ONLY IF the Name field has not been provided. If this field is used, the name returned to the client will be different than the name passed. This value will also be combined with a unique suffix. The provided value has the same validation rules as the Name field, and may be truncated by the length of the suffix required to make the value unique on the server.\n\nIf this field is specified and the generated name exists, the server will NOT return a 409 - instead, it will either return 201 Created or 500 with Reason ServerTimeout indicating a unique name could not be found in the time allotted, and the client should retry (optionally after the time indicated in the Retry-After header).\n\nApplied only if Name is not specified. More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#idempotency",
                            "type": "string"
                          },
                          "generation": {
                            "description": "A sequence number representing a specific generation of the desired state. Populated by the system. Read-only.",
                            "format": "int64",
                            "type": "integer"
                          },
                          "initializers": {
                            "description": "Initializers tracks the progress of initialization.",
                            "properties": {
                              "pending": {
                                "description": "Pending is a list of initializers that must execute in order before this object is visible. When the last pending initializer is removed, and no failing result is set, the initializers struct will be set to nil and the object is considered as initialized and visible to all clients.",
                                "items": {
                                  "description": "Initializer is information about an initializer that has not yet completed.",
                                  "properties": {
                                    "name": {
                                      "description": "name of the process that is responsible for initializing this object.",
                                      "type": "string"
                                    }
                                  },
                                  "required": [
                                    "name"
                                  ]
                                },
                                "type": "array"
                              },
                              "result": {
                                "description": "Status is a return value for calls that don't return other objects.",
                                "properties": {
                                  "apiVersion": {
                                    "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#resources",
                                    "type": "string"
                                  },
                                  "code": {
                                    "description": "Suggested HTTP return code for this status, 0 if not set.",
                                    "format": "int32",
                                    "type": "integer"
                                  },
                                  "details": {
                                    "description": "StatusDetails is a set of additional properties that MAY be set by the server to provide additional information about a response. The Reason field of a Status object defines what attributes will be set. Clients must ignore fields that do not match the defined type of each attribute, and should assume that any attribute may be empty, invalid, or under defined.",
                                    "properties": {
                                      "causes": {
                                        "description": "The Causes array includes more details associated with the StatusReason failure. Not all StatusReasons may provide detailed causes.",
                                        "items": {
                                          "description": "StatusCause provides more information about an api.Status failure, including cases when multiple errors are encountered.",
                                          "properties": {
                                            "field": {
                                              "description": "The field of the resource that has caused this error, as named by its JSON serialization. May include dot and postfix notation for nested attributes. Arrays are zero-indexed.  Fields may appear more than once in an array of causes due to fields having multiple errors. Optional.\n\nExamples:\n  \"name\" - the field \"name\" on the current resource\n  \"items[0].name\" - the field \"name\" on the first array entry in \"items\"",
                                              "type": "string"
                                            },
                                            "message": {
                                              "description": "A human-readable description of the cause of the error.  This field may be presented as-is to a reader.",
                                              "type": "string"
                                            },
                                            "reason": {
                                              "description": "A machine-readable description of the cause of the error. If this value is empty there is no information available.",
                                              "type": "string"
                                            }
                                          }
                                        },
                                        "type": "array"
                                      },
                                      "group": {
                                        "description": "The group attribute of the resource associated with the status StatusReason.",
                                        "type": "string"
                                      },
                                      "kind": {
                                        "description": "The kind attribute of the resource associated with the status StatusReason. On some operations may differ from the requested resource Kind. More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#types-kinds",
                                        "type": "string"
                                      },
                                      "name": {
                                        "description": "The name attribute of the resource associated with the status StatusReason (when there is a single name which can be described).",
                                        "type": "string"
                                      },
                                      "retryAfterSeconds": {
                                        "description": "If specified, the time in seconds before the operation should be retried. Some errors may indicate the client must take an alternate action - for those errors this field may indicate how long to wait before taking the alternate action.",
                                        "format": "int32",
                                        "type": "integer"
                                      },
                                      "uid": {
                                        "description": "UID of the resource. (when there is a single resource which can be described). More info: http://kubernetes.io/docs/user-guide/identifiers#uids",
                                        "type": "string"
                                      }
                                    }
                                  },
                                  "kind": {
                                    "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#types-kinds",
                                    "type": "string"
                                  },
                                  "message": {
                                    "description": "A human-readable description of the status of this operation.",
                                    "type": "string"
                                  },
                                  "metadata": {
                                    "description": "ListMeta describes metadata that synthetic resources must have, including lists and various status objects. A resource may have only one of {ObjectMeta, ListMeta}.",
                                    "properties": {
                                      "continue": {
                                        "description": "continue may be set if the user set a limit on the number of items returned, and indicates that the server has more data available. The value is opaque and may be used to issue another request to the endpoint that served this list to retrieve the next set of available objects. Continuing a consistent list may not be possible if the server configuration has changed or more than a few minutes have passed. The resourceVersion field returned when using this continue value will be identical to the value in the first response, unless you have received this token from an error message.",
                                        "type": "string"
                                      },
                                      "resourceVersion": {
                                        "description": "String that identifies the server's internal version of this object that can be used by clients to determine when objects have changed. Value must be treated as opaque by clients and passed unmodified back to the server. Populated by the system. Read-only. More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#concurrency-control-and-consistency",
                                        "type": "string"
                                      },
                                      "selfLink": {
                                        "description": "selfLink is a URL representing this object. Populated by the system. Read-only.",
                                        "type": "string"
                                      }
                                    }
                                  },
                                  "reason": {
                                    "description": "A machine-readable description of why this operation is in the \"Failure\" status. If this value is empty there is no information available. A Reason clarifies an HTTP status code but does not override it.",
                                    "type": "string"
                                  },
                                  "status": {
                                    "description": "Status of the operation. One of: \"Success\" or \"Failure\". More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#spec-and-status",
                                    "type": "string"
                                  }
                                }
                              }
                            },
                            "required": [
                              "pending"
                            ]
                          },
                          "labels": {
                            "description": "Map of string keys and values that can be used to organize and categorize (scope and select) objects. May match selectors of replication controllers and services. More info: http://kubernetes.io/docs/user-guide/labels",
                            "type": "object"
                          },
                          "name": {
                            "description": "Name must be unique within a namespace. Is required when creating resources, although some resources may allow a client to request the generation of an appropriate name automatically. Name is primarily intended for creation idempotence and configuration definition. Cannot be updated. More info: http://kubernetes.io/docs/user-guide/identifiers#names",
                            "type": "string"
                          },
                          "namespace": {
                            "description": "Namespace defines the space within each name must be unique. An empty namespace is equivalent to the \"default\" namespace, but \"default\" is the canonical representation. Not all objects are required to be scoped to a namespace - the value of this field for those objects will be empty.\n\nMust be a DNS_LABEL. Cannot be updated. More info: http://kubernetes.io/docs/user-guide/namespaces",
                            "type": "string"
                          },
                          "ownerReferences": {
                            "description": "List of objects depended by this object. If ALL objects in the list have been deleted, this object will be garbage collected. If this object is managed by a controller, then an entry in this list will point to this controller, with the controller field set to true. There cannot be more than one managing controller.",
                            "items": {
                              "description": "OwnerReference contains enough information to let you identify an owning object. Currently, an owning object must be in the same namespace, so there is no namespace field.",
                              "properties": {
                                "apiVersion": {
                                  "description": "API version of the referent.",
                                  "type": "string"
                                },
                                "blockOwnerDeletion": {
                                  "description": "If true, AND if the owner has the \"foregroundDeletion\" finalizer, then the owner cannot be deleted from the key-value store until this reference is removed. Defaults to false. To set this field, a user needs \"delete\" permission of the owner, otherwise 422 (Unprocessable Entity) will be returned.",
                                  "type": "boolean"
                                },
                                "controller": {
                                  "description": "If true, this reference points to the managing controller.",
                                  "type": "boolean"
                                },
                                "kind": {
                                  "description": "Kind of the referent. More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#types-kinds",
                                  "type": "string"
                                },
                                "name": {
                                  "description": "Name of the referent. More info: http://kubernetes.io/docs/user-guide/identifiers#names",
                                  "type": "string"
                                },
                                "uid": {
                                  "description": "UID of the referent. More info: http://kubernetes.io/docs/user-guide/identifiers#uids",
                                  "type": "string"
                                }
                              },
                              "required": [
                                "apiVersion",
                                "kind",
                                "name",
                                "uid"
                              ]
                            },
                            "type": "array"
                          },
                          "resourceVersion": {
                            "description": "An opaque value that represents the internal version of this object that can be used by clients to determine when objects have changed. May be used for optimistic concurrency, change detection, and the watch operation on a resource or set of resources. Clients must treat these values as opaque and passed unmodified back to the server. They may only be valid for a particular resource or set of resources.\n\nPopulated by the system. Read-only. Value must be treated as opaque by clients and . More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#concurrency-control-and-consistency",
                            "type": "string"
                          },
                          "selfLink": {
                            "description": "SelfLink is a URL representing this object. Populated by the system. Read-only.",
                            "type": "string"
                          },
                          "uid": {
                            "description": "UID is the unique in time and space value for this object. It is typically generated by the server on successful creation of a resource and is not allowed to change on PUT operations.\n\nPopulated by the system. Read-only. More info: http://kubernetes.io/docs/user-guide/identifiers#uids",
                            "type": "string"
                          }
                        }
                      },
                      "spec": {
                        "description": "PersistentVolumeClaimSpec describes the common attributes of storage devices and allows a Source for provider-specific attributes",
                        "properties": {
                          "accessModes": {
                            "description": "AccessModes contains the desired access modes the volume should have. More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#access-modes-1",
                            "items": {
                              "type": "string"
                            },
                            "type": "array"
                          },
                          "dataSource": {
                            "description": "TypedLocalObjectReference contains enough information to let you locate the typed referenced object inside the same namespace.",
                            "properties": {
                              "apiGroup": {
                                "description": "APIGroup is the group for the resource being referenced. If APIGroup is not specified, the specified Kind must be in the core API group. For any other third-party types, APIGroup is required.",
                                "type": "string"
                              },
                              "kind": {
                                "description": "Kind is the type of resource being referenced",
                                "type": "string"
                              },
                              "name": {
                                "description": "Name is the name of resource being referenced",
                                "type": "string"
                              }
                            },
                            "required": [
                              "kind",
                              "name"
                            ]
                          },
                          "resources": {
                            "description": "ResourceRequirements describes the compute resource requirements.",
                            "properties": {
                              "limits": {
                                "description": "Limits describes the maximum amount of compute resources allowed. More info: https://kubernetes.io/docs/concepts/configuration/manage-compute-resources-container/",
                                "type": "object"
                              },
                              "requests": {
                                "description": "Requests describes the minimum amount of compute resources required. If Requests is omitted for a container, it defaults to Limits if that is explicitly specified, otherwise to an implementation-defined value. More info: https://kubernetes.io/docs/concepts/configuration/manage-compute-resources-container/",
                                "type": "object"
                              }
                            }
                          },
                          "selector": {
                            "description": "A label selector is a label query over a set of resources. The result of matchLabels and matchExpressions are ANDed. An empty label selector matches all objects. A null label selector matches no objects.",
                            "properties": {
                              "matchExpressions": {
                                "description": "matchExpressions is a list of label selector requirements. The requirements are ANDed.",
                                "items": {
                                  "description": "A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.",
                                  "properties": {
                                    "key": {
                                      "description": "key is the label key that the selector applies to.",
                                      "type": "string"
                                    },
                                    "operator": {
                                      "description": "operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.",
                                      "type": "string"
                                    },
                                    "values": {
                                      "description": "values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.",
                                      "items": {
                                        "type": "string"
                                      },
                                      "type": "array"
                                    }
                                  },
                                  "required": [
                                    "key",
                                    "operator"
                                  ]
                                },
                                "type": "array"
                              },
                              "matchLabels": {
                                "description": "matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is \"key\", the operator is \"In\", and the values array contains only \"value\". The requirements are ANDed.",
                                "type": "object"
                              }
                            }
                          },
                          "storageClassName": {
                            "description": "Name of the StorageClass required by the claim. More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#class-1",
                            "type": "string"
                          },
                          "volumeMode": {
                            "description": "volumeMode defines what type of volume is required by the claim. Value of Filesystem is implied when not included in claim spec. This is an alpha feature and may change in the future.",
                            "type": "string"
                          },
                          "volumeName": {
                            "description": "VolumeName is the binding reference to the PersistentVolume backing this claim.",
                            "type": "string"
                          }
                        }
                      },
                      "status": {
                        "description": "PersistentVolumeClaimStatus is the current status of a persistent volume claim.",
                        "properties": {
                          "accessModes": {
                            "description": "AccessModes contains the actual access modes the volume backing the PVC has. More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#access-modes-1",
                            "items": {
                              "type": "string"
                            },
                            "type": "array"
                          },
                          "capacity": {
                            "description": "Represents the actual resources of the underlying volume.",
                            "type": "object"
                          },
                          "conditions": {
                            "description": "Current Condition of persistent volume claim. If underlying persistent volume is being resized then the Condition will be set to 'ResizeStarted'.",
                            "items": {
                              "description": "PersistentVolumeClaimCondition contails details about state of pvc",
                              "properties": {
                                "lastProbeTime": {
                                  "description": "Time is a wrapper around time.Time which supports correct marshaling to YAML and JSON.  Wrappers are provided for many of the factory methods that the time package offers.",
                                  "format": "date-time",
                                  "type": "string"
                                },
                                "lastTransitionTime": {
                                  "description": "Time is a wrapper around time.Time which supports correct marshaling to YAML and JSON.  Wrappers are provided for many of the factory methods that the time package offers.",
                                  "format": "date-time",
                                  "type": "string"
                                },
                                "message": {
                                  "description": "Human-readable message indicating details about last transition.",
                                  "type": "string"
                                },
                                "reason": {
                                  "description": "Unique, this should be a short, machine understandable string that gives the reason for condition's last transition. If it reports \"ResizeStarted\" that means the underlying persistent volume is being resized.",
                                  "type": "string"
                                },
                                "status": {
                                  "type": "string"
                                },
                                "type": {
                                  "type": "string"
                                }
                              },
                              "required": [
                                "type",
                                "status"
                              ]
                            },
                            "type": "array"
                          },
                          "phase": {
                            "description": "Phase represents the current phase of PersistentVolumeClaim.",
                            "type": "string"
                          }
                        }
                      }
                    }
                  }
                }
              },
              "tag": {
                "description": "Tag of Prometheus container image to be deployed. Defaults to the value of `version`. Version is ignored if Tag is set.",
                "type": "string"
              },
              "thanos": {
                "description": "ThanosSpec defines parameters for a Prometheus server within a Thanos deployment.",
                "properties": {
                  "baseImage": {
                    "description": "Thanos base image if other than default.",
                    "type": "string"
                  },
                  "gcs": {
                    "description": "ThanosGCSSpec defines parameters for use of Google Cloud Storage (GCS) with Thanos.",
                    "properties": {
                      "bucket": {
                        "description": "Google Cloud Storage bucket name for stored blocks. If empty it won't store any block inside Google Cloud Storage.",
                        "type": "string"
                      },
                      "credentials": {
                        "description": "SecretKeySelector selects a key of a Secret.",
                        "properties": {
                          "key": {
                            "description": "The key of the secret to select from.  Must be a valid secret key.",
                            "type": "string"
                          },
                          "name": {
                            "description": "Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names",
                            "type": "string"
                          },
                          "optional": {
                            "description": "Specify whether the Secret or it's key must be defined",
                            "type": "boolean"
                          }
                        },
                        "required": [
                          "key"
                        ]
                      }
                    }
                  },
                  "image": {
                    "description": "Image if specified has precedence over baseImage, tag and sha combinations. Specifying the version is still necessary to ensure the Prometheus Operator knows what version of Thanos is being configured.",
                    "type": "string"
                  },
                  "peers": {
                    "description": "Peers is a DNS name for Thanos to discover peers through.",
                    "type": "string"
                  },
                  "resources": {
                    "description": "ResourceRequirements describes the compute resource requirements.",
                    "properties": {
                      "limits": {
                        "description": "Limits describes the maximum amount of compute resources allowed. More info: https://kubernetes.io/docs/concepts/configuration/manage-compute-resources-container/",
                        "type": "object"
                      },
                      "requests": {
                        "description": "Requests describes the minimum amount of compute resources required. If Requests is omitted for a container, it defaults to Limits if that is explicitly specified, otherwise to an implementation-defined value. More info: https://kubernetes.io/docs/concepts/configuration/manage-compute-resources-container/",
                        "type": "object"
                      }
                    }
                  },
                  "s3": {
                    "description": "ThanosS3Spec defines parameters for of AWS Simple Storage Service (S3) with Thanos. (S3 compatible services apply as well)",
                    "properties": {
                      "accessKey": {
                        "description": "SecretKeySelector selects a key of a Secret.",
                        "properties": {
                          "key": {
                            "description": "The key of the secret to select from.  Must be a valid secret key.",
                            "type": "string"
                          },
                          "name": {
                            "description": "Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names",
                            "type": "string"
                          },
                          "optional": {
                            "description": "Specify whether the Secret or it's key must be defined",
                            "type": "boolean"
                          }
                        },
                        "required": [
                          "key"
                        ]
                      },
                      "bucket": {
                        "description": "S3-Compatible API bucket name for stored blocks.",
                        "type": "string"
                      },
                      "encryptsse": {
                        "description": "Whether to use Server Side Encryption",
                        "type": "boolean"
                      },
                      "endpoint": {
                        "description": "S3-Compatible API endpoint for stored blocks.",
                        "type": "string"
                      },
                      "insecure": {
                        "description": "Whether to use an insecure connection with an S3-Compatible API.",
                        "type": "boolean"
                      },
                      "secretKey": {
                        "description": "SecretKeySelector selects a key of a Secret.",
                        "properties": {
                          "key": {
                            "description": "The key of the secret to select from.  Must be a valid secret key.",
                            "type": "string"
                          },
                          "name": {
                            "description": "Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names",
                            "type": "string"
                          },
                          "optional": {
                            "description": "Specify whether the Secret or it's key must be defined",
                            "type": "boolean"
                          }
                        },
                        "required": [
                          "key"
                        ]
                      },
                      "signatureVersion2": {
                        "description": "Whether to use S3 Signature Version 2; otherwise Signature Version 4 will be used.",
                        "type": "boolean"
                      }
                    }
                  },
                  "sha": {
                    "description": "SHA of Thanos container image to be deployed. Defaults to the value of `version`. Similar to a tag, but the SHA explicitly deploys an immutable container image. Version and Tag are ignored if SHA is set.",
                    "type": "string"
                  },
                  "tag": {
                    "description": "Tag of Thanos sidecar container image to be deployed. Defaults to the value of `version`. Version is ignored if Tag is set.",
                    "type": "string"
                  },
                  "version": {
                    "description": "Version describes the version of Thanos to use.",
                    "type": "string"
                  }
                }
              },
              "tolerations": {
                "description": "If specified, the pod's tolerations.",
                "items": {
                  "description": "The pod this Toleration is attached to tolerates any taint that matches the triple <key,value,effect> using the matching operator <operator>.",
                  "properties": {
                    "effect": {
                      "description": "Effect indicates the taint effect to match. Empty means match all taint effects. When specified, allowed values are NoSchedule, PreferNoSchedule and NoExecute.",
                      "type": "string"
                    },
                    "key": {
                      "description": "Key is the taint key that the toleration applies to. Empty means match all taint keys. If the key is empty, operator must be Exists; this combination means to match all values and all keys.",
                      "type": "string"
                    },
                    "operator": {
                      "description": "Operator represents a key's relationship to the value. Valid operators are Exists and Equal. Defaults to Equal. Exists is equivalent to wildcard for value, so that a pod can tolerate all taints of a particular category.",
                      "type": "string"
                    },
                    "tolerationSeconds": {
                      "description": "TolerationSeconds represents the period of time the toleration (which must be of effect NoExecute, otherwise this field is ignored) tolerates the taint. By default, it is not set, which means tolerate the taint forever (do not evict). Zero and negative values will be treated as 0 (evict immediately) by the system.",
                      "format": "int64",
                      "type": "integer"
                    },
                    "value": {
                      "description": "Value is the taint value the toleration matches to. If the operator is Exists, the value should be empty, otherwise just a regular string.",
                      "type": "string"
                    }
                  }
                },
                "type": "array"
              },
              "version": {
                "description": "Version of Prometheus to be deployed.",
                "type": "string"
              }
            }
          },
          "status": {
            "description": "PrometheusStatus is the most recent observed status of the Prometheus cluster. Read-only. Not included when requesting from the apiserver, only from the Prometheus Operator API itself. More info: https://github.com/kubernetes/community/blob/master/contributors/devel/api-conventions.md#spec-and-status",
            "properties": {
              "availableReplicas": {
                "description": "Total number of available pods (ready for at least minReadySeconds) targeted by this Prometheus deployment.",
                "format": "int32",
                "type": "integer"
              },
              "paused": {
                "description": "Represents whether any actions on the underlying managed objects are being performed. Only delete actions will be performed.",
                "type": "boolean"
              },
              "replicas": {
                "description": "Total number of non-terminated pods targeted by this Prometheus deployment (their labels match the selector).",
                "format": "int32",
                "type": "integer"
              },
              "unavailableReplicas": {
                "description": "Total number of unavailable pods targeted by this Prometheus deployment.",
                "format": "int32",
                "type": "integer"
              },
              "updatedReplicas": {
                "description": "Total number of non-terminated pods targeted by this Prometheus deployment that have the desired version spec.",
                "format": "int32",
                "type": "integer"
              }
            },
            "required": [
              "paused",
              "replicas",
              "updatedReplicas",
              "availableReplicas",
              "unavailableReplicas"
            ]
          }
        }
      }
    },
    "version": "v1",
    "versions": [
      {
        "name": "v1",
        "served": true,
        "storage": true
      }
    ]
  }
}

---

{
  "metadata": {
    "name": "prometheusrules.monitoring.coreos.com"
  },
  "apiVersion": "apiextensions.k8s.io/v1beta1",
  "kind": "CustomResourceDefinition",
  "spec": {
    "conversion": {
      "strategy": "None"
    },
    "group": "monitoring.coreos.com",
    "names": {
      "kind": "PrometheusRule",
      "listKind": "PrometheusRuleList",
      "plural": "prometheusrules",
      "singular": "prometheusrule"
    },
    "scope": "Namespaced",
    "validation": {
      "openAPIV3Schema": {
        "properties": {
          "apiVersion": {
            "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#resources",
            "type": "string"
          },
          "kind": {
            "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#types-kinds",
            "type": "string"
          },
          "metadata": {
            "description": "ObjectMeta is metadata that all persisted resources must have, which includes all objects users must create.",
            "properties": {
              "annotations": {
                "description": "Annotations is an unstructured key value map stored with a resource that may be set by external tools to store and retrieve arbitrary metadata. They are not queryable and should be preserved when modifying objects. More info: http://kubernetes.io/docs/user-guide/annotations",
                "type": "object"
              },
              "clusterName": {
                "description": "The name of the cluster which the object belongs to. This is used to distinguish resources with same name and namespace in different clusters. This field is not set anywhere right now and apiserver is going to ignore it if set in create or update request.",
                "type": "string"
              },
              "creationTimestamp": {
                "description": "Time is a wrapper around time.Time which supports correct marshaling to YAML and JSON.  Wrappers are provided for many of the factory methods that the time package offers.",
                "format": "date-time",
                "type": "string"
              },
              "deletionGracePeriodSeconds": {
                "description": "Number of seconds allowed for this object to gracefully terminate before it will be removed from the system. Only set when deletionTimestamp is also set. May only be shortened. Read-only.",
                "format": "int64",
                "type": "integer"
              },
              "deletionTimestamp": {
                "description": "Time is a wrapper around time.Time which supports correct marshaling to YAML and JSON.  Wrappers are provided for many of the factory methods that the time package offers.",
                "format": "date-time",
                "type": "string"
              },
              "finalizers": {
                "description": "Must be empty before the object is deleted from the registry. Each entry is an identifier for the responsible component that will remove the entry from the list. If the deletionTimestamp of the object is non-nil, entries in this list can only be removed.",
                "items": {
                  "type": "string"
                },
                "type": "array"
              },
              "generateName": {
                "description": "GenerateName is an optional prefix, used by the server, to generate a unique name ONLY IF the Name field has not been provided. If this field is used, the name returned to the client will be different than the name passed. This value will also be combined with a unique suffix. The provided value has the same validation rules as the Name field, and may be truncated by the length of the suffix required to make the value unique on the server.\n\nIf this field is specified and the generated name exists, the server will NOT return a 409 - instead, it will either return 201 Created or 500 with Reason ServerTimeout indicating a unique name could not be found in the time allotted, and the client should retry (optionally after the time indicated in the Retry-After header).\n\nApplied only if Name is not specified. More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#idempotency",
                "type": "string"
              },
              "generation": {
                "description": "A sequence number representing a specific generation of the desired state. Populated by the system. Read-only.",
                "format": "int64",
                "type": "integer"
              },
              "initializers": {
                "description": "Initializers tracks the progress of initialization.",
                "properties": {
                  "pending": {
                    "description": "Pending is a list of initializers that must execute in order before this object is visible. When the last pending initializer is removed, and no failing result is set, the initializers struct will be set to nil and the object is considered as initialized and visible to all clients.",
                    "items": {
                      "description": "Initializer is information about an initializer that has not yet completed.",
                      "properties": {
                        "name": {
                          "description": "name of the process that is responsible for initializing this object.",
                          "type": "string"
                        }
                      },
                      "required": [
                        "name"
                      ]
                    },
                    "type": "array"
                  },
                  "result": {
                    "description": "Status is a return value for calls that don't return other objects.",
                    "properties": {
                      "apiVersion": {
                        "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#resources",
                        "type": "string"
                      },
                      "code": {
                        "description": "Suggested HTTP return code for this status, 0 if not set.",
                        "format": "int32",
                        "type": "integer"
                      },
                      "details": {
                        "description": "StatusDetails is a set of additional properties that MAY be set by the server to provide additional information about a response. The Reason field of a Status object defines what attributes will be set. Clients must ignore fields that do not match the defined type of each attribute, and should assume that any attribute may be empty, invalid, or under defined.",
                        "properties": {
                          "causes": {
                            "description": "The Causes array includes more details associated with the StatusReason failure. Not all StatusReasons may provide detailed causes.",
                            "items": {
                              "description": "StatusCause provides more information about an api.Status failure, including cases when multiple errors are encountered.",
                              "properties": {
                                "field": {
                                  "description": "The field of the resource that has caused this error, as named by its JSON serialization. May include dot and postfix notation for nested attributes. Arrays are zero-indexed.  Fields may appear more than once in an array of causes due to fields having multiple errors. Optional.\n\nExamples:\n  \"name\" - the field \"name\" on the current resource\n  \"items[0].name\" - the field \"name\" on the first array entry in \"items\"",
                                  "type": "string"
                                },
                                "message": {
                                  "description": "A human-readable description of the cause of the error.  This field may be presented as-is to a reader.",
                                  "type": "string"
                                },
                                "reason": {
                                  "description": "A machine-readable description of the cause of the error. If this value is empty there is no information available.",
                                  "type": "string"
                                }
                              }
                            },
                            "type": "array"
                          },
                          "group": {
                            "description": "The group attribute of the resource associated with the status StatusReason.",
                            "type": "string"
                          },
                          "kind": {
                            "description": "The kind attribute of the resource associated with the status StatusReason. On some operations may differ from the requested resource Kind. More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#types-kinds",
                            "type": "string"
                          },
                          "name": {
                            "description": "The name attribute of the resource associated with the status StatusReason (when there is a single name which can be described).",
                            "type": "string"
                          },
                          "retryAfterSeconds": {
                            "description": "If specified, the time in seconds before the operation should be retried. Some errors may indicate the client must take an alternate action - for those errors this field may indicate how long to wait before taking the alternate action.",
                            "format": "int32",
                            "type": "integer"
                          },
                          "uid": {
                            "description": "UID of the resource. (when there is a single resource which can be described). More info: http://kubernetes.io/docs/user-guide/identifiers#uids",
                            "type": "string"
                          }
                        }
                      },
                      "kind": {
                        "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#types-kinds",
                        "type": "string"
                      },
                      "message": {
                        "description": "A human-readable description of the status of this operation.",
                        "type": "string"
                      },
                      "metadata": {
                        "description": "ListMeta describes metadata that synthetic resources must have, including lists and various status objects. A resource may have only one of {ObjectMeta, ListMeta}.",
                        "properties": {
                          "continue": {
                            "description": "continue may be set if the user set a limit on the number of items returned, and indicates that the server has more data available. The value is opaque and may be used to issue another request to the endpoint that served this list to retrieve the next set of available objects. Continuing a consistent list may not be possible if the server configuration has changed or more than a few minutes have passed. The resourceVersion field returned when using this continue value will be identical to the value in the first response, unless you have received this token from an error message.",
                            "type": "string"
                          },
                          "resourceVersion": {
                            "description": "String that identifies the server's internal version of this object that can be used by clients to determine when objects have changed. Value must be treated as opaque by clients and passed unmodified back to the server. Populated by the system. Read-only. More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#concurrency-control-and-consistency",
                            "type": "string"
                          },
                          "selfLink": {
                            "description": "selfLink is a URL representing this object. Populated by the system. Read-only.",
                            "type": "string"
                          }
                        }
                      },
                      "reason": {
                        "description": "A machine-readable description of why this operation is in the \"Failure\" status. If this value is empty there is no information available. A Reason clarifies an HTTP status code but does not override it.",
                        "type": "string"
                      },
                      "status": {
                        "description": "Status of the operation. One of: \"Success\" or \"Failure\". More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#spec-and-status",
                        "type": "string"
                      }
                    }
                  }
                },
                "required": [
                  "pending"
                ]
              },
              "labels": {
                "description": "Map of string keys and values that can be used to organize and categorize (scope and select) objects. May match selectors of replication controllers and services. More info: http://kubernetes.io/docs/user-guide/labels",
                "type": "object"
              },
              "name": {
                "description": "Name must be unique within a namespace. Is required when creating resources, although some resources may allow a client to request the generation of an appropriate name automatically. Name is primarily intended for creation idempotence and configuration definition. Cannot be updated. More info: http://kubernetes.io/docs/user-guide/identifiers#names",
                "type": "string"
              },
              "namespace": {
                "description": "Namespace defines the space within each name must be unique. An empty namespace is equivalent to the \"default\" namespace, but \"default\" is the canonical representation. Not all objects are required to be scoped to a namespace - the value of this field for those objects will be empty.\n\nMust be a DNS_LABEL. Cannot be updated. More info: http://kubernetes.io/docs/user-guide/namespaces",
                "type": "string"
              },
              "ownerReferences": {
                "description": "List of objects depended by this object. If ALL objects in the list have been deleted, this object will be garbage collected. If this object is managed by a controller, then an entry in this list will point to this controller, with the controller field set to true. There cannot be more than one managing controller.",
                "items": {
                  "description": "OwnerReference contains enough information to let you identify an owning object. Currently, an owning object must be in the same namespace, so there is no namespace field.",
                  "properties": {
                    "apiVersion": {
                      "description": "API version of the referent.",
                      "type": "string"
                    },
                    "blockOwnerDeletion": {
                      "description": "If true, AND if the owner has the \"foregroundDeletion\" finalizer, then the owner cannot be deleted from the key-value store until this reference is removed. Defaults to false. To set this field, a user needs \"delete\" permission of the owner, otherwise 422 (Unprocessable Entity) will be returned.",
                      "type": "boolean"
                    },
                    "controller": {
                      "description": "If true, this reference points to the managing controller.",
                      "type": "boolean"
                    },
                    "kind": {
                      "description": "Kind of the referent. More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#types-kinds",
                      "type": "string"
                    },
                    "name": {
                      "description": "Name of the referent. More info: http://kubernetes.io/docs/user-guide/identifiers#names",
                      "type": "string"
                    },
                    "uid": {
                      "description": "UID of the referent. More info: http://kubernetes.io/docs/user-guide/identifiers#uids",
                      "type": "string"
                    }
                  },
                  "required": [
                    "apiVersion",
                    "kind",
                    "name",
                    "uid"
                  ]
                },
                "type": "array"
              },
              "resourceVersion": {
                "description": "An opaque value that represents the internal version of this object that can be used by clients to determine when objects have changed. May be used for optimistic concurrency, change detection, and the watch operation on a resource or set of resources. Clients must treat these values as opaque and passed unmodified back to the server. They may only be valid for a particular resource or set of resources.\n\nPopulated by the system. Read-only. Value must be treated as opaque by clients and . More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#concurrency-control-and-consistency",
                "type": "string"
              },
              "selfLink": {
                "description": "SelfLink is a URL representing this object. Populated by the system. Read-only.",
                "type": "string"
              },
              "uid": {
                "description": "UID is the unique in time and space value for this object. It is typically generated by the server on successful creation of a resource and is not allowed to change on PUT operations.\n\nPopulated by the system. Read-only. More info: http://kubernetes.io/docs/user-guide/identifiers#uids",
                "type": "string"
              }
            }
          },
          "spec": {
            "description": "PrometheusRuleSpec contains specification parameters for a Rule.",
            "properties": {
              "groups": {
                "description": "Content of Prometheus rule file",
                "items": {
                  "description": "RuleGroup is a list of sequentially evaluated recording and alerting rules.",
                  "properties": {
                    "interval": {
                      "type": "string"
                    },
                    "name": {
                      "type": "string"
                    },
                    "rules": {
                      "items": {
                        "description": "Rule describes an alerting or recording rule.",
                        "properties": {
                          "alert": {
                            "type": "string"
                          },
                          "annotations": {
                            "type": "object"
                          },
                          "expr": {
                            "anyOf": [
                              {
                                "type": "string"
                              },
                              {
                                "type": "integer"
                              }
                            ]
                          },
                          "for": {
                            "type": "string"
                          },
                          "labels": {
                            "type": "object"
                          },
                          "record": {
                            "type": "string"
                          }
                        },
                        "required": [
                          "expr"
                        ]
                      },
                      "type": "array"
                    }
                  },
                  "required": [
                    "name",
                    "rules"
                  ]
                },
                "type": "array"
              }
            }
          }
        }
      }
    },
    "version": "v1",
    "versions": [
      {
        "name": "v1",
        "served": true,
        "storage": true
      }
    ]
  }
}

---

{
  "metadata": {
    "name": "rolebindingrestrictions.authorization.openshift.io"
  },
  "apiVersion": "apiextensions.k8s.io/v1beta1",
  "kind": "CustomResourceDefinition",
  "spec": {
    "conversion": {
      "strategy": "None"
    },
    "group": "authorization.openshift.io",
    "names": {
      "kind": "RoleBindingRestriction",
      "listKind": "RoleBindingRestrictionList",
      "plural": "rolebindingrestrictions",
      "singular": "rolebindingrestriction"
    },
    "scope": "Namespaced",
    "validation": {
      "openAPIV3Schema": {
        "properties": {
          "apiVersion": {
            "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#resources",
            "type": "string"
          },
          "kind": {
            "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#types-kinds",
            "type": "string"
          },
          "metadata": {
            "description": "Standard object's metadata.",
            "type": "object"
          },
          "spec": {
            "description": "Spec defines the matcher.",
            "properties": {
              "grouprestriction": {
                "description": "GroupRestriction matches against group subjects.",
                "nullable": true,
                "properties": {
                  "groups": {
                    "description": "Groups is a list of groups used to match against an individual user's groups. If the user is a member of one of the whitelisted groups, the user is allowed to be bound to a role.",
                    "items": {
                      "type": "string"
                    },
                    "nullable": true,
                    "type": "array"
                  },
                  "labels": {
                    "description": "Selectors specifies a list of label selectors over group labels.",
                    "items": {
                      "type": "object"
                    },
                    "nullable": true,
                    "type": "array"
                  }
                },
                "type": "object"
              },
              "serviceaccountrestriction": {
                "description": "ServiceAccountRestriction matches against service-account subjects.",
                "nullable": true,
                "properties": {
                  "namespaces": {
                    "description": "Namespaces specifies a list of literal namespace names.",
                    "items": {
                      "type": "string"
                    },
                    "type": "array"
                  },
                  "serviceaccounts": {
                    "description": "ServiceAccounts specifies a list of literal service-account names.",
                    "items": {
                      "properties": {
                        "name": {
                          "description": "Name is the name of the service account.",
                          "type": "string"
                        },
                        "namespace": {
                          "description": "Namespace is the namespace of the service account.  Service accounts from inside the whitelisted namespaces are allowed to be bound to roles.  If Namespace is empty, then the namespace of the RoleBindingRestriction in which the ServiceAccountReference is embedded is used.",
                          "type": "string"
                        }
                      },
                      "type": "object"
                    },
                    "type": "array"
                  }
                },
                "type": "object"
              },
              "userrestriction": {
                "description": "UserRestriction matches against user subjects.",
                "nullable": true,
                "properties": {
                  "groups": {
                    "description": "Groups specifies a list of literal group names.",
                    "items": {
                      "type": "string"
                    },
                    "nullable": true,
                    "type": "array"
                  },
                  "labels": {
                    "description": "Selectors specifies a list of label selectors over user labels.",
                    "items": {
                      "type": "object"
                    },
                    "nullable": true,
                    "type": "array"
                  },
                  "users": {
                    "description": "Users specifies a list of literal user names.",
                    "items": {
                      "type": "string"
                    },
                    "type": "array"
                  }
                },
                "type": "object"
              }
            },
            "type": "object"
          }
        }
      }
    },
    "version": "v1",
    "versions": [
      {
        "name": "v1",
        "served": true,
        "storage": true
      }
    ]
  }
}

---

{
  "metadata": {
    "name": "schedulers.config.openshift.io"
  },
  "apiVersion": "apiextensions.k8s.io/v1beta1",
  "kind": "CustomResourceDefinition",
  "spec": {
    "conversion": {
      "strategy": "None"
    },
    "group": "config.openshift.io",
    "names": {
      "kind": "Scheduler",
      "listKind": "SchedulerList",
      "plural": "schedulers",
      "singular": "scheduler"
    },
    "scope": "Cluster",
    "validation": {
      "openAPIV3Schema": {
        "properties": {
          "apiVersion": {
            "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#resources",
            "type": "string"
          },
          "kind": {
            "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#types-kinds",
            "type": "string"
          },
          "metadata": {
            "description": "Standard object's metadata.",
            "type": "object"
          },
          "spec": {
            "description": "spec holds user settable values for configuration",
            "properties": {
              "defaultNodeSelector": {
                "description": "defaultNodeSelector helps set the cluster-wide default node selector to restrict pod placement to specific nodes. This is applied to the pods created in all namespaces without a specified nodeSelector value. For example, defaultNodeSelector: \"type=user-node,region=east\" would set nodeSelector field in pod spec to \"type=user-node,region=east\" to all pods created in all namespaces. Namespaces having project-wide node selectors won't be impacted even if this field is set. This adds an annotation section to the namespace. For example, if a new namespace is created with node-selector='type=user-node,region=east', the annotation openshift.io/node-selector: type=user-node,region=east gets added to the project. When the openshift.io/node-selector annotation is set on the project the value is used in preference to the value we are setting for defaultNodeSelector field. For instance, openshift.io/node-selector: \"type=user-node,region=west\" means that the default of \"type=user-node,region=east\" set in defaultNodeSelector would not be applied.",
                "type": "string"
              },
              "policy": {
                "description": "policy is a reference to a ConfigMap containing scheduler policy which has user specified predicates and priorities. If this ConfigMap is not available scheduler will default to use DefaultAlgorithmProvider. The namespace for this configmap is openshift-config.",
                "properties": {
                  "name": {
                    "description": "name is the metadata.name of the referenced config map",
                    "type": "string"
                  }
                },
                "type": "object"
              }
            },
            "type": "object"
          },
          "status": {
            "description": "status holds observed values from the cluster. They may not be overridden.",
            "type": "object"
          }
        },
        "required": [
          "spec"
        ]
      }
    },
    "version": "v1",
    "versions": [
      {
        "name": "v1",
        "served": true,
        "storage": true
      }
    ]
  }
}

---

{
  "metadata": {
    "name": "securitycontextconstraints.security.openshift.io"
  },
  "apiVersion": "apiextensions.k8s.io/v1beta1",
  "kind": "CustomResourceDefinition",
  "spec": {
    "conversion": {
      "strategy": "None"
    },
    "group": "security.openshift.io",
    "names": {
      "kind": "SecurityContextConstraints",
      "listKind": "SecurityContextConstraintsList",
      "plural": "securitycontextconstraints",
      "singular": "securitycontextconstraints"
    },
    "scope": "Cluster",
    "validation": {
      "openAPIV3Schema": {
        "properties": {
          "allowHostDirVolumePlugin": {
            "description": "AllowHostDirVolumePlugin determines if the policy allow containers to use the HostDir volume plugin +k8s:conversion-gen=false",
            "type": "boolean"
          },
          "allowHostIPC": {
            "description": "AllowHostIPC determines if the policy allows host ipc in the containers.",
            "type": "boolean"
          },
          "allowHostNetwork": {
            "description": "AllowHostNetwork determines if the policy allows the use of HostNetwork in the pod spec.",
            "type": "boolean"
          },
          "allowHostPID": {
            "description": "AllowHostPID determines if the policy allows host pid in the containers.",
            "type": "boolean"
          },
          "allowHostPorts": {
            "description": "AllowHostPorts determines if the policy allows host ports in the containers.",
            "type": "boolean"
          },
          "allowPrivilegeEscalation": {
            "description": "AllowPrivilegeEscalation determines if a pod can request to allow privilege escalation. If unspecified, defaults to true.",
            "nullable": true,
            "type": "boolean"
          },
          "allowPrivilegedContainer": {
            "description": "AllowPrivilegedContainer determines if a container can request to be run as privileged.",
            "type": "boolean"
          },
          "allowedCapabilities": {
            "description": "AllowedCapabilities is a list of capabilities that can be requested to add to the container. Capabilities in this field maybe added at the pod author's discretion. You must not list a capability in both AllowedCapabilities and RequiredDropCapabilities. To allow all capabilities you may use '*'.",
            "items": {
              "type": "string"
            },
            "nullable": true,
            "type": "array"
          },
          "allowedFlexVolumes": {
            "description": "AllowedFlexVolumes is a whitelist of allowed Flexvolumes.  Empty or nil indicates that all Flexvolumes may be used.  This parameter is effective only when the usage of the Flexvolumes is allowed in the \"Volumes\" field.",
            "items": {
              "properties": {
                "driver": {
                  "description": "Driver is the name of the Flexvolume driver.",
                  "type": "string"
                }
              },
              "type": "object"
            },
            "nullable": true,
            "type": "array"
          },
          "allowedUnsafeSysctls": {
            "description": "AllowedUnsafeSysctls is a list of explicitly allowed unsafe sysctls, defaults to none. Each entry is either a plain sysctl name or ends in \"*\" in which case it is considered as a prefix of allowed sysctls. Single * means all unsafe sysctls are allowed. Kubelet has to whitelist all allowed unsafe sysctls explicitly to avoid rejection.  Examples: e.g. \"foo/*\" allows \"foo/bar\", \"foo/baz\", etc. e.g. \"foo.*\" allows \"foo.bar\", \"foo.baz\", etc.",
            "items": {
              "type": "string"
            },
            "nullable": true,
            "type": "array"
          },
          "apiVersion": {
            "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#resources",
            "type": "string"
          },
          "defaultAddCapabilities": {
            "description": "DefaultAddCapabilities is the default set of capabilities that will be added to the container unless the pod spec specifically drops the capability.  You may not list a capabiility in both DefaultAddCapabilities and RequiredDropCapabilities.",
            "items": {
              "type": "string"
            },
            "nullable": true,
            "type": "array"
          },
          "defaultAllowPrivilegeEscalation": {
            "description": "DefaultAllowPrivilegeEscalation controls the default setting for whether a process can gain more privileges than its parent process.",
            "nullable": true,
            "type": "boolean"
          },
          "forbiddenSysctls": {
            "description": "ForbiddenSysctls is a list of explicitly forbidden sysctls, defaults to none. Each entry is either a plain sysctl name or ends in \"*\" in which case it is considered as a prefix of forbidden sysctls. Single * means all sysctls are forbidden.  Examples: e.g. \"foo/*\" forbids \"foo/bar\", \"foo/baz\", etc. e.g. \"foo.*\" forbids \"foo.bar\", \"foo.baz\", etc.",
            "items": {
              "type": "string"
            },
            "nullable": true,
            "type": "array"
          },
          "fsGroup": {
            "description": "FSGroup is the strategy that will dictate what fs group is used by the SecurityContext.",
            "nullable": true,
            "properties": {
              "ranges": {
                "description": "Ranges are the allowed ranges of fs groups.  If you would like to force a single fs group then supply a single range with the same start and end.",
                "items": {
                  "properties": {
                    "max": {
                      "description": "Max is the end of the range, inclusive.",
                      "format": "int64",
                      "type": "integer"
                    },
                    "min": {
                      "description": "Min is the start of the range, inclusive.",
                      "format": "int64",
                      "type": "integer"
                    }
                  },
                  "type": "object"
                },
                "type": "array"
              },
              "type": {
                "description": "Type is the strategy that will dictate what FSGroup is used in the SecurityContext.",
                "type": "string"
              }
            },
            "type": "object"
          },
          "groups": {
            "description": "The groups that have permission to use this security context constraints",
            "items": {
              "type": "string"
            },
            "nullable": true,
            "type": "array"
          },
          "kind": {
            "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#types-kinds",
            "type": "string"
          },
          "metadata": {
            "description": "Standard object's metadata. More info: http://releases.k8s.io/HEAD/docs/devel/api-conventions.md#metadata",
            "type": "object"
          },
          "priority": {
            "description": "Priority influences the sort order of SCCs when evaluating which SCCs to try first for a given pod request based on access in the Users and Groups fields.  The higher the int, the higher priority. An unset value is considered a 0 priority. If scores for multiple SCCs are equal they will be sorted from most restrictive to least restrictive. If both priorities and restrictions are equal the SCCs will be sorted by name.",
            "format": "int32",
            "nullable": true,
            "type": "integer"
          },
          "readOnlyRootFilesystem": {
            "description": "ReadOnlyRootFilesystem when set to true will force containers to run with a read only root file system.  If the container specifically requests to run with a non-read only root file system the SCC should deny the pod. If set to false the container may run with a read only root file system if it wishes but it will not be forced to.",
            "type": "boolean"
          },
          "requiredDropCapabilities": {
            "description": "RequiredDropCapabilities are the capabilities that will be dropped from the container.  These are required to be dropped and cannot be added.",
            "items": {
              "type": "string"
            },
            "nullable": true,
            "type": "array"
          },
          "runAsUser": {
            "description": "RunAsUser is the strategy that will dictate what RunAsUser is used in the SecurityContext.",
            "nullable": true,
            "properties": {
              "type": {
                "description": "Type is the strategy that will dictate what RunAsUser is used in the SecurityContext.",
                "type": "string"
              },
              "uid": {
                "description": "UID is the user id that containers must run as.  Required for the MustRunAs strategy if not using namespace/service account allocated uids.",
                "format": "int64",
                "type": "integer"
              },
              "uidRangeMax": {
                "description": "UIDRangeMax defines the max value for a strategy that allocates by range.",
                "format": "int64",
                "type": "integer"
              },
              "uidRangeMin": {
                "description": "UIDRangeMin defines the min value for a strategy that allocates by range.",
                "format": "int64",
                "type": "integer"
              }
            },
            "type": "object"
          },
          "seLinuxContext": {
            "description": "SELinuxContext is the strategy that will dictate what labels will be set in the SecurityContext.",
            "nullable": true,
            "properties": {
              "seLinuxOptions": {
                "description": "seLinuxOptions required to run as; required for MustRunAs",
                "type": "object"
              },
              "type": {
                "description": "Type is the strategy that will dictate what SELinux context is used in the SecurityContext.",
                "type": "string"
              }
            },
            "type": "object"
          },
          "seccompProfiles": {
            "description": "SeccompProfiles lists the allowed profiles that may be set for the pod or container's seccomp annotations.  An unset (nil) or empty value means that no profiles may be specified by the pod or container.\the wildcard '*' may be used to allow all profiles.  When used to generate a value for a pod the first non-wildcard profile will be used as the default.",
            "items": {
              "type": "string"
            },
            "nullable": true,
            "type": "array"
          },
          "supplementalGroups": {
            "description": "SupplementalGroups is the strategy that will dictate what supplemental groups are used by the SecurityContext.",
            "nullable": true,
            "properties": {
              "ranges": {
                "description": "Ranges are the allowed ranges of supplemental groups.  If you would like to force a single supplemental group then supply a single range with the same start and end.",
                "items": {
                  "properties": {
                    "max": {
                      "description": "Max is the end of the range, inclusive.",
                      "format": "int64",
                      "type": "integer"
                    },
                    "min": {
                      "description": "Min is the start of the range, inclusive.",
                      "format": "int64",
                      "type": "integer"
                    }
                  },
                  "type": "object"
                },
                "type": "array"
              },
              "type": {
                "description": "Type is the strategy that will dictate what supplemental groups is used in the SecurityContext.",
                "type": "string"
              }
            },
            "type": "object"
          },
          "users": {
            "description": "The users who have permissions to use this security context constraints",
            "items": {
              "type": "string"
            },
            "nullable": true,
            "type": "array"
          },
          "volumes": {
            "description": "Volumes is a white list of allowed volume plugins.  FSType corresponds directly with the field names of a VolumeSource (azureFile, configMap, emptyDir).  To allow all volumes you may use \"*\". To allow no volumes, set to [\"none\"].",
            "items": {
              "type": "string"
            },
            "nullable": true,
            "type": "array"
          }
        }
      }
    },
    "version": "v1",
    "versions": [
      {
        "name": "v1",
        "served": true,
        "storage": true
      }
    ]
  }
}

---

{
  "metadata": {
    "name": "servicecas.operator.openshift.io"
  },
  "apiVersion": "apiextensions.k8s.io/v1beta1",
  "kind": "CustomResourceDefinition",
  "spec": {
    "conversion": {
      "strategy": "None"
    },
    "group": "operator.openshift.io",
    "names": {
      "kind": "ServiceCA",
      "listKind": "ServiceCAList",
      "plural": "servicecas",
      "singular": "serviceca"
    },
    "scope": "Cluster",
    "subresources": {
      "status": {}
    },
    "validation": {
      "openAPIV3Schema": {
        "properties": {
          "apiVersion": {
            "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#resources",
            "type": "string"
          },
          "kind": {
            "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#types-kinds",
            "type": "string"
          },
          "metadata": {
            "type": "object"
          },
          "spec": {
            "properties": {
              "logLevel": {
                "description": "logLevel is an intent based logging for an overall component.  It does not give fine grained control, but it is a simple way to manage coarse grained logging choices that operators have to interpret for their operands.",
                "type": "string"
              },
              "managementState": {
                "description": "managementState indicates whether and how the operator should manage the component",
                "pattern": "^(Managed|Unmanaged|Force|Removed)$",
                "type": "string"
              },
              "observedConfig": {
                "description": "observedConfig holds a sparse config that controller has observed from the cluster state.  It exists in spec because it is an input to the level for the operator",
                "nullable": true,
                "type": "object"
              },
              "operandSpecs": {
                "description": "operandSpecs provide customization for functional units within the component",
                "items": {
                  "properties": {
                    "name": {
                      "description": "name is the name of this unit.  The operator must be aware of it.",
                      "type": "string"
                    },
                    "operandContainerSpecs": {
                      "description": "operandContainerSpecs are per-container options",
                      "items": {
                        "properties": {
                          "name": {
                            "description": "name is the name of the container to modify",
                            "type": "string"
                          },
                          "resources": {
                            "description": "resources are the requests and limits to place in the container.  Nil means to accept the defaults.",
                            "type": "object"
                          }
                        },
                        "type": "object"
                      },
                      "type": "array"
                    },
                    "unsupportedResourcePatches": {
                      "description": "unsupportedResourcePatches are applied to the workload resource for this unit. This is an unsupported workaround if anything needs to be modified on the workload that is not otherwise configurable. TODO Decide: alternatively, we could simply include a RawExtension which is used in place of the \"normal\" default manifest",
                      "items": {
                        "properties": {
                          "patch": {
                            "description": "patch the patch itself",
                            "type": "string"
                          },
                          "type": {
                            "description": "type is the type of patch to apply: jsonmerge, strategicmerge",
                            "type": "string"
                          }
                        },
                        "type": "object"
                      },
                      "type": "array"
                    }
                  },
                  "type": "object"
                },
                "type": "array"
              },
              "unsupportedConfigOverrides": {
                "description": "unsupportedConfigOverrides holds a sparse config that will override any previously set options.  It only needs to be the fields to override it will end up overlaying in the following order: 1. hardcoded defaults 2. observedConfig 3. unsupportedConfigOverrides",
                "nullable": true,
                "type": "object"
              }
            },
            "type": "object"
          },
          "status": {
            "properties": {
              "conditions": {
                "description": "conditions is a list of conditions and their status",
                "items": {
                  "properties": {
                    "lastTransitionTime": {
                      "format": "date-time",
                      "type": "string"
                    },
                    "message": {
                      "type": "string"
                    },
                    "reason": {
                      "type": "string"
                    },
                    "status": {
                      "type": "string"
                    },
                    "type": {
                      "type": "string"
                    }
                  },
                  "type": "object"
                },
                "type": "array"
              },
              "generations": {
                "description": "generations are used to determine when an item needs to be reconciled or has changed in a way that needs a reaction.",
                "items": {
                  "properties": {
                    "group": {
                      "description": "group is the group of the thing you're tracking",
                      "type": "string"
                    },
                    "hash": {
                      "description": "hash is an optional field set for resources without generation that are content sensitive like secrets and configmaps",
                      "type": "string"
                    },
                    "lastGeneration": {
                      "description": "lastGeneration is the last generation of the workload controller involved",
                      "format": "int64",
                      "type": "integer"
                    },
                    "name": {
                      "description": "name is the name of the thing you're tracking",
                      "type": "string"
                    },
                    "namespace": {
                      "description": "namespace is where the thing you're tracking is",
                      "type": "string"
                    },
                    "resource": {
                      "description": "resource is the resource type of the thing you're tracking",
                      "type": "string"
                    }
                  },
                  "type": "object"
                },
                "type": "array"
              },
              "observedGeneration": {
                "description": "observedGeneration is the last generation change you've dealt with",
                "format": "int64",
                "type": "integer"
              },
              "readyReplicas": {
                "description": "readyReplicas indicates how many replicas are ready and at the desired state",
                "format": "int32",
                "type": "integer"
              },
              "version": {
                "description": "version is the level this availability applies to",
                "type": "string"
              }
            },
            "type": "object"
          }
        },
        "required": [
          "spec"
        ]
      }
    },
    "version": "v1",
    "versions": [
      {
        "name": "v1",
        "served": true,
        "storage": true
      }
    ]
  }
}

---

{
  "metadata": {
    "name": "servicecatalogapiservers.operator.openshift.io"
  },
  "apiVersion": "apiextensions.k8s.io/v1beta1",
  "kind": "CustomResourceDefinition",
  "spec": {
    "conversion": {
      "strategy": "None"
    },
    "group": "operator.openshift.io",
    "names": {
      "categories": [
        "coreoperators"
      ],
      "kind": "ServiceCatalogAPIServer",
      "listKind": "ServiceCatalogAPIServerList",
      "plural": "servicecatalogapiservers",
      "singular": "servicecatalogapiserver"
    },
    "scope": "Cluster",
    "subresources": {
      "status": {}
    },
    "validation": {
      "openAPIV3Schema": {
        "properties": {
          "apiVersion": {
            "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#resources",
            "type": "string"
          },
          "kind": {
            "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#types-kinds",
            "type": "string"
          },
          "metadata": {
            "type": "object"
          },
          "spec": {
            "properties": {
              "logLevel": {
                "description": "logLevel is an intent based logging for an overall component.  It does not give fine grained control, but it is a simple way to manage coarse grained logging choices that operators have to interpret for their operands.",
                "type": "string"
              },
              "managementState": {
                "description": "managementState indicates whether and how the operator should manage the component",
                "pattern": "^(Managed|Unmanaged|Force|Removed)$",
                "type": "string"
              },
              "observedConfig": {
                "description": "observedConfig holds a sparse config that controller has observed from the cluster state.  It exists in spec because it is an input to the level for the operator",
                "nullable": true,
                "type": "object"
              },
              "operatorLogLevel": {
                "description": "operatorLogLevel is an intent based logging for the operator itself.  It does not give fine grained control, but it is a simple way to manage coarse grained logging choices that operators have to interpret for themselves.",
                "type": "string"
              },
              "unsupportedConfigOverrides": {
                "description": "unsupportedConfigOverrides holds a sparse config that will override any previously set options.  It only needs to be the fields to override it will end up overlaying in the following order: 1. hardcoded defaults 2. observedConfig 3. unsupportedConfigOverrides",
                "nullable": true,
                "type": "object"
              }
            },
            "type": "object"
          },
          "status": {
            "properties": {
              "conditions": {
                "description": "conditions is a list of conditions and their status",
                "items": {
                  "properties": {
                    "lastTransitionTime": {
                      "format": "date-time",
                      "type": "string"
                    },
                    "message": {
                      "type": "string"
                    },
                    "reason": {
                      "type": "string"
                    },
                    "status": {
                      "type": "string"
                    },
                    "type": {
                      "type": "string"
                    }
                  },
                  "type": "object"
                },
                "type": "array"
              },
              "generations": {
                "description": "generations are used to determine when an item needs to be reconciled or has changed in a way that needs a reaction.",
                "items": {
                  "properties": {
                    "group": {
                      "description": "group is the group of the thing you're tracking",
                      "type": "string"
                    },
                    "hash": {
                      "description": "hash is an optional field set for resources without generation that are content sensitive like secrets and configmaps",
                      "type": "string"
                    },
                    "lastGeneration": {
                      "description": "lastGeneration is the last generation of the workload controller involved",
                      "format": "int64",
                      "type": "integer"
                    },
                    "name": {
                      "description": "name is the name of the thing you're tracking",
                      "type": "string"
                    },
                    "namespace": {
                      "description": "namespace is where the thing you're tracking is",
                      "type": "string"
                    },
                    "resource": {
                      "description": "resource is the resource type of the thing you're tracking",
                      "type": "string"
                    }
                  },
                  "type": "object"
                },
                "type": "array"
              },
              "observedGeneration": {
                "description": "observedGeneration is the last generation change you've dealt with",
                "format": "int64",
                "type": "integer"
              },
              "readyReplicas": {
                "description": "readyReplicas indicates how many replicas are ready and at the desired state",
                "format": "int32",
                "type": "integer"
              },
              "version": {
                "description": "version is the level this availability applies to",
                "type": "string"
              }
            },
            "type": "object"
          }
        },
        "required": [
          "spec"
        ]
      }
    },
    "version": "v1",
    "versions": [
      {
        "name": "v1",
        "served": true,
        "storage": true
      }
    ]
  }
}

---

{
  "metadata": {
    "name": "servicecatalogcontrollermanagers.operator.openshift.io"
  },
  "apiVersion": "apiextensions.k8s.io/v1beta1",
  "kind": "CustomResourceDefinition",
  "spec": {
    "conversion": {
      "strategy": "None"
    },
    "group": "operator.openshift.io",
    "names": {
      "categories": [
        "coreoperators"
      ],
      "kind": "ServiceCatalogControllerManager",
      "listKind": "ServiceCatalogControllerManagerList",
      "plural": "servicecatalogcontrollermanagers",
      "singular": "servicecatalogcontrollermanager"
    },
    "scope": "Cluster",
    "subresources": {
      "status": {}
    },
    "validation": {
      "openAPIV3Schema": {
        "properties": {
          "apiVersion": {
            "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#resources",
            "type": "string"
          },
          "kind": {
            "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#types-kinds",
            "type": "string"
          },
          "metadata": {
            "type": "object"
          },
          "spec": {
            "properties": {
              "logLevel": {
                "description": "logLevel is an intent based logging for an overall component.  It does not give fine grained control, but it is a simple way to manage coarse grained logging choices that operators have to interpret for their operands.",
                "type": "string"
              },
              "managementState": {
                "description": "managementState indicates whether and how the operator should manage the component",
                "pattern": "^(Managed|Unmanaged|Force|Removed)$",
                "type": "string"
              },
              "observedConfig": {
                "description": "observedConfig holds a sparse config that controller has observed from the cluster state.  It exists in spec because it is an input to the level for the operator",
                "nullable": true,
                "type": "object"
              },
              "operatorLogLevel": {
                "description": "operatorLogLevel is an intent based logging for the operator itself.  It does not give fine grained control, but it is a simple way to manage coarse grained logging choices that operators have to interpret for themselves.",
                "type": "string"
              },
              "unsupportedConfigOverrides": {
                "description": "unsupportedConfigOverrides holds a sparse config that will override any previously set options.  It only needs to be the fields to override it will end up overlaying in the following order: 1. hardcoded defaults 2. observedConfig 3. unsupportedConfigOverrides",
                "nullable": true,
                "type": "object"
              }
            },
            "type": "object"
          },
          "status": {
            "properties": {
              "conditions": {
                "description": "conditions is a list of conditions and their status",
                "items": {
                  "properties": {
                    "lastTransitionTime": {
                      "format": "date-time",
                      "type": "string"
                    },
                    "message": {
                      "type": "string"
                    },
                    "reason": {
                      "type": "string"
                    },
                    "status": {
                      "type": "string"
                    },
                    "type": {
                      "type": "string"
                    }
                  },
                  "type": "object"
                },
                "type": "array"
              },
              "generations": {
                "description": "generations are used to determine when an item needs to be reconciled or has changed in a way that needs a reaction.",
                "items": {
                  "properties": {
                    "group": {
                      "description": "group is the group of the thing you're tracking",
                      "type": "string"
                    },
                    "hash": {
                      "description": "hash is an optional field set for resources without generation that are content sensitive like secrets and configmaps",
                      "type": "string"
                    },
                    "lastGeneration": {
                      "description": "lastGeneration is the last generation of the workload controller involved",
                      "format": "int64",
                      "type": "integer"
                    },
                    "name": {
                      "description": "name is the name of the thing you're tracking",
                      "type": "string"
                    },
                    "namespace": {
                      "description": "namespace is where the thing you're tracking is",
                      "type": "string"
                    },
                    "resource": {
                      "description": "resource is the resource type of the thing you're tracking",
                      "type": "string"
                    }
                  },
                  "type": "object"
                },
                "type": "array"
              },
              "observedGeneration": {
                "description": "observedGeneration is the last generation change you've dealt with",
                "format": "int64",
                "type": "integer"
              },
              "readyReplicas": {
                "description": "readyReplicas indicates how many replicas are ready and at the desired state",
                "format": "int32",
                "type": "integer"
              },
              "version": {
                "description": "version is the level this availability applies to",
                "type": "string"
              }
            },
            "type": "object"
          }
        },
        "required": [
          "spec"
        ]
      }
    },
    "version": "v1",
    "versions": [
      {
        "name": "v1",
        "served": true,
        "storage": true
      }
    ]
  }
}

---

{
  "metadata": {
    "name": "servicemonitors.monitoring.coreos.com"
  },
  "apiVersion": "apiextensions.k8s.io/v1beta1",
  "kind": "CustomResourceDefinition",
  "spec": {
    "conversion": {
      "strategy": "None"
    },
    "group": "monitoring.coreos.com",
    "names": {
      "kind": "ServiceMonitor",
      "listKind": "ServiceMonitorList",
      "plural": "servicemonitors",
      "singular": "servicemonitor"
    },
    "scope": "Namespaced",
    "validation": {
      "openAPIV3Schema": {
        "properties": {
          "apiVersion": {
            "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#resources",
            "type": "string"
          },
          "kind": {
            "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#types-kinds",
            "type": "string"
          },
          "spec": {
            "description": "ServiceMonitorSpec contains specification parameters for a ServiceMonitor.",
            "properties": {
              "endpoints": {
                "description": "A list of endpoints allowed as part of this ServiceMonitor.",
                "items": {
                  "description": "Endpoint defines a scrapeable endpoint serving Prometheus metrics.",
                  "properties": {
                    "basicAuth": {
                      "description": "BasicAuth allow an endpoint to authenticate over basic authentication More info: https://prometheus.io/docs/operating/configuration/#endpoints",
                      "properties": {
                        "password": {
                          "description": "SecretKeySelector selects a key of a Secret.",
                          "properties": {
                            "key": {
                              "description": "The key of the secret to select from.  Must be a valid secret key.",
                              "type": "string"
                            },
                            "name": {
                              "description": "Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names",
                              "type": "string"
                            },
                            "optional": {
                              "description": "Specify whether the Secret or it's key must be defined",
                              "type": "boolean"
                            }
                          },
                          "required": [
                            "key"
                          ]
                        },
                        "username": {
                          "description": "SecretKeySelector selects a key of a Secret.",
                          "properties": {
                            "key": {
                              "description": "The key of the secret to select from.  Must be a valid secret key.",
                              "type": "string"
                            },
                            "name": {
                              "description": "Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names",
                              "type": "string"
                            },
                            "optional": {
                              "description": "Specify whether the Secret or it's key must be defined",
                              "type": "boolean"
                            }
                          },
                          "required": [
                            "key"
                          ]
                        }
                      }
                    },
                    "bearerTokenFile": {
                      "description": "File to read bearer token for scraping targets.",
                      "type": "string"
                    },
                    "honorLabels": {
                      "description": "HonorLabels chooses the metric's labels on collisions with target labels.",
                      "type": "boolean"
                    },
                    "interval": {
                      "description": "Interval at which metrics should be scraped",
                      "type": "string"
                    },
                    "metricRelabelings": {
                      "description": "MetricRelabelConfigs to apply to samples before ingestion.",
                      "items": {
                        "description": "RelabelConfig allows dynamic rewriting of the label set, being applied to samples before ingestion. It defines `<metric_relabel_configs>`-section of Prometheus configuration. More info: https://prometheus.io/docs/prometheus/latest/configuration/configuration/#metric_relabel_configs",
                        "properties": {
                          "action": {
                            "description": "Action to perform based on regex matching. Default is 'replace'",
                            "type": "string"
                          },
                          "modulus": {
                            "description": "Modulus to take of the hash of the source label values.",
                            "format": "int64",
                            "type": "integer"
                          },
                          "regex": {
                            "description": "Regular expression against which the extracted value is matched. default is '(.*)'",
                            "type": "string"
                          },
                          "replacement": {
                            "description": "Replacement value against which a regex replace is performed if the regular expression matches. Regex capture groups are available. Default is '$1'",
                            "type": "string"
                          },
                          "separator": {
                            "description": "Separator placed between concatenated source label values. default is ';'.",
                            "type": "string"
                          },
                          "sourceLabels": {
                            "description": "The source labels select values from existing labels. Their content is concatenated using the configured separator and matched against the configured regular expression for the replace, keep, and drop actions.",
                            "items": {
                              "type": "string"
                            },
                            "type": "array"
                          },
                          "targetLabel": {
                            "description": "Label to which the resulting value is written in a replace action. It is mandatory for replace actions. Regex capture groups are available.",
                            "type": "string"
                          }
                        }
                      },
                      "type": "array"
                    },
                    "params": {
                      "description": "Optional HTTP URL parameters",
                      "type": "object"
                    },
                    "path": {
                      "description": "HTTP path to scrape for metrics.",
                      "type": "string"
                    },
                    "port": {
                      "description": "Name of the service port this endpoint refers to. Mutually exclusive with targetPort.",
                      "type": "string"
                    },
                    "proxyUrl": {
                      "description": "ProxyURL eg http://proxyserver:2195 Directs scrapes to proxy through this endpoint.",
                      "type": "string"
                    },
                    "relabelings": {
                      "description": "RelabelConfigs to apply to samples before ingestion. More info: https://prometheus.io/docs/prometheus/latest/configuration/configuration/#<relabel_config>",
                      "items": {
                        "description": "RelabelConfig allows dynamic rewriting of the label set, being applied to samples before ingestion. It defines `<metric_relabel_configs>`-section of Prometheus configuration. More info: https://prometheus.io/docs/prometheus/latest/configuration/configuration/#metric_relabel_configs",
                        "properties": {
                          "action": {
                            "description": "Action to perform based on regex matching. Default is 'replace'",
                            "type": "string"
                          },
                          "modulus": {
                            "description": "Modulus to take of the hash of the source label values.",
                            "format": "int64",
                            "type": "integer"
                          },
                          "regex": {
                            "description": "Regular expression against which the extracted value is matched. default is '(.*)'",
                            "type": "string"
                          },
                          "replacement": {
                            "description": "Replacement value against which a regex replace is performed if the regular expression matches. Regex capture groups are available. Default is '$1'",
                            "type": "string"
                          },
                          "separator": {
                            "description": "Separator placed between concatenated source label values. default is ';'.",
                            "type": "string"
                          },
                          "sourceLabels": {
                            "description": "The source labels select values from existing labels. Their content is concatenated using the configured separator and matched against the configured regular expression for the replace, keep, and drop actions.",
                            "items": {
                              "type": "string"
                            },
                            "type": "array"
                          },
                          "targetLabel": {
                            "description": "Label to which the resulting value is written in a replace action. It is mandatory for replace actions. Regex capture groups are available.",
                            "type": "string"
                          }
                        }
                      },
                      "type": "array"
                    },
                    "scheme": {
                      "description": "HTTP scheme to use for scraping.",
                      "type": "string"
                    },
                    "scrapeTimeout": {
                      "description": "Timeout after which the scrape is ended",
                      "type": "string"
                    },
                    "targetPort": {
                      "anyOf": [
                        {
                          "type": "string"
                        },
                        {
                          "type": "integer"
                        }
                      ]
                    },
                    "tlsConfig": {
                      "description": "TLSConfig specifies TLS configuration parameters.",
                      "properties": {
                        "caFile": {
                          "description": "The CA cert to use for the targets.",
                          "type": "string"
                        },
                        "certFile": {
                          "description": "The client cert file for the targets.",
                          "type": "string"
                        },
                        "insecureSkipVerify": {
                          "description": "Disable target certificate validation.",
                          "type": "boolean"
                        },
                        "keyFile": {
                          "description": "The client key file for the targets.",
                          "type": "string"
                        },
                        "serverName": {
                          "description": "Used to verify the hostname for the targets.",
                          "type": "string"
                        }
                      }
                    }
                  }
                },
                "type": "array"
              },
              "jobLabel": {
                "description": "The label to use to retrieve the job name from.",
                "type": "string"
              },
              "namespaceSelector": {
                "description": "NamespaceSelector is a selector for selecting either all namespaces or a list of namespaces.",
                "properties": {
                  "any": {
                    "description": "Boolean describing whether all namespaces are selected in contrast to a list restricting them.",
                    "type": "boolean"
                  },
                  "matchNames": {
                    "description": "List of namespace names.",
                    "items": {
                      "type": "string"
                    },
                    "type": "array"
                  }
                }
              },
              "podTargetLabels": {
                "description": "PodTargetLabels transfers labels on the Kubernetes Pod onto the target.",
                "items": {
                  "type": "string"
                },
                "type": "array"
              },
              "sampleLimit": {
                "description": "SampleLimit defines per-scrape limit on number of scraped samples that will be accepted.",
                "format": "int64",
                "type": "integer"
              },
              "selector": {
                "description": "A label selector is a label query over a set of resources. The result of matchLabels and matchExpressions are ANDed. An empty label selector matches all objects. A null label selector matches no objects.",
                "properties": {
                  "matchExpressions": {
                    "description": "matchExpressions is a list of label selector requirements. The requirements are ANDed.",
                    "items": {
                      "description": "A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.",
                      "properties": {
                        "key": {
                          "description": "key is the label key that the selector applies to.",
                          "type": "string"
                        },
                        "operator": {
                          "description": "operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.",
                          "type": "string"
                        },
                        "values": {
                          "description": "values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.",
                          "items": {
                            "type": "string"
                          },
                          "type": "array"
                        }
                      },
                      "required": [
                        "key",
                        "operator"
                      ]
                    },
                    "type": "array"
                  },
                  "matchLabels": {
                    "description": "matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is \"key\", the operator is \"In\", and the values array contains only \"value\". The requirements are ANDed.",
                    "type": "object"
                  }
                }
              },
              "targetLabels": {
                "description": "TargetLabels transfers labels on the Kubernetes Service onto the target.",
                "items": {
                  "type": "string"
                },
                "type": "array"
              }
            },
            "required": [
              "endpoints",
              "selector"
            ]
          }
        }
      }
    },
    "version": "v1",
    "versions": [
      {
        "name": "v1",
        "served": true,
        "storage": true
      }
    ]
  }
}

---

{
  "metadata": {
    "name": "subscriptions.operators.coreos.com"
  },
  "apiVersion": "apiextensions.k8s.io/v1beta1",
  "kind": "CustomResourceDefinition",
  "spec": {
    "additionalPrinterColumns": [
      {
        "JSONPath": ".spec.name",
        "description": "The package subscribed to",
        "name": "Package",
        "type": "string"
      },
      {
        "JSONPath": ".spec.source",
        "description": "The catalog source for the specified package",
        "name": "Source",
        "type": "string"
      },
      {
        "JSONPath": ".spec.channel",
        "description": "The channel of updates to subscribe to",
        "name": "Channel",
        "type": "string"
      }
    ],
    "conversion": {
      "strategy": "None"
    },
    "group": "operators.coreos.com",
    "names": {
      "categories": [
        "olm"
      ],
      "kind": "Subscription",
      "listKind": "SubscriptionList",
      "plural": "subscriptions",
      "shortNames": [
        "sub",
        "subs"
      ],
      "singular": "subscription"
    },
    "scope": "Namespaced",
    "subresources": {
      "status": {}
    },
    "validation": {
      "openAPIV3Schema": {
        "description": "Subscribes service catalog to a source and channel to receive updates for packages.",
        "properties": {
          "spec": {
            "description": "Spec for a Subscription",
            "properties": {
              "channel": {
                "description": "Name of the channel to track",
                "type": "string"
              },
              "installPlanApproval": {
                "description": "Approval mode for emitted InstallPlans",
                "enum": [
                  "Manual",
                  "Automatic"
                ],
                "type": "string"
              },
              "name": {
                "description": "Name of the package that defines the application",
                "type": "string"
              },
              "source": {
                "description": "Name of a CatalogSource that defines where and how to find the channel",
                "type": "string"
              },
              "sourceNamespace": {
                "description": "The Kubernetes namespace where the CatalogSource used is located",
                "type": "string"
              },
              "startingCSV": {
                "description": "Name of the AppType that this subscription tracks",
                "type": "string"
              }
            },
            "required": [
              "source",
              "name"
            ],
            "type": "object"
          }
        }
      }
    },
    "version": "v1alpha1",
    "versions": [
      {
        "name": "v1alpha1",
        "served": true,
        "storage": true
      }
    ]
  }
}

---

{
  "metadata": {
    "name": "tuneds.tuned.openshift.io"
  },
  "apiVersion": "apiextensions.k8s.io/v1beta1",
  "kind": "CustomResourceDefinition",
  "spec": {
    "conversion": {
      "strategy": "None"
    },
    "group": "tuned.openshift.io",
    "names": {
      "kind": "Tuned",
      "listKind": "TunedList",
      "plural": "tuneds",
      "singular": "tuned"
    },
    "scope": "Namespaced",
    "validation": {
      "openAPIV3Schema": {
        "description": "Tuned is a collection of rules that allows cluster-wide deployment of node-level sysctls and more flexibility to add custom tuning specified by user needs. These rules are translated and passed to all containerized tuned daemons running in the cluster in the format that the daemons understand. The responsibility for applying the node-level tuning then lies with the containerized tuned daemons. More info: https://github.com/openshift/cluster-node-tuning-operator",
        "properties": {
          "apiVersion": {
            "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info2: https://git.k8s.io/community/contributors/devel/api-conventions.md#resources",
            "type": "string"
          },
          "kind": {
            "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#types-kinds",
            "type": "string"
          },
          "metadata": {
            "type": "object"
          },
          "spec": {
            "description": "spec is the specification of the desired behavior of Tuned. More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#spec-and-status",
            "type": "object"
          },
          "status": {
            "description": "Status is the current state of Tuned.  This cannot be overridden.",
            "type": "object"
          }
        }
      }
    },
    "version": "v1",
    "versions": [
      {
        "name": "v1",
        "served": true,
        "storage": true
      }
    ]
  }
}
