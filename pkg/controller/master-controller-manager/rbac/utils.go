/*
Copyright 2023 The Kubermatic Kubernetes Platform contributors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package rbac

import (
	"fmt"

	kubermaticv1 "k8c.io/kubermatic/sdk/v2/apis/kubermatic/v1"
	"k8c.io/kubermatic/v2/pkg/crd"

	corev1 "k8s.io/api/core/v1"
	rbacv1 "k8s.io/api/rbac/v1"
	"k8s.io/apimachinery/pkg/api/meta"
	ctrlruntimeclient "sigs.k8s.io/controller-runtime/pkg/client"
)

const kubermaticGroup = "kubermatic.k8c.io"

// getPluralResourceName returns the plural resource name we require to generate RBAC in rbac-controller.
// If the resource type is part of our CRDs, it will be read from the compiled-in CRD definitions; otherwise
// we try to dynamically discover it (e.g. for corev1 resources).
// Relying on the compile-time CRDs allows this function to work even if the CRDs are not installed in the
// cluster, which is the case for example for Clusters, which live on seeds, but for which RBAC has to be
// generated by the master-ctrl-mgr on the master cluster.
func getPluralResourceName(restMapper meta.RESTMapper, obj ctrlruntimeclient.Object) (string, error) {
	gvk := obj.GetObjectKind().GroupVersionKind()
	// In controller-runtime >= v0.22 fake client may not set GVK on Get; fall back to Go type
	if gvk.Kind == "" {
		switch obj.(type) {
		case *kubermaticv1.Cluster:
			gvk.Kind = "Cluster"
			gvk.Group = kubermaticGroup
		case *kubermaticv1.UserSSHKey:
			gvk.Kind = "UserSSHKey"
			gvk.Group = kubermaticGroup
		case *kubermaticv1.UserProjectBinding:
			gvk.Kind = "UserProjectBinding"
			gvk.Group = kubermaticGroup
		case *kubermaticv1.ExternalCluster:
			gvk.Kind = "ExternalCluster"
			gvk.Group = kubermaticGroup
		case *kubermaticv1.GroupProjectBinding:
			gvk.Kind = "GroupProjectBinding"
			gvk.Group = kubermaticGroup
		case *kubermaticv1.ResourceQuota:
			gvk.Kind = "ResourceQuota"
			gvk.Group = kubermaticGroup
		case *corev1.Secret:
			gvk.Kind = "Secret"
		case *rbacv1.Role:
			gvk.Kind = "Role"
		case *rbacv1.RoleBinding:
			gvk.Kind = "RoleBinding"
		case *rbacv1.ClusterRole:
			gvk.Kind = "ClusterRole"
		case *rbacv1.ClusterRoleBinding:
			gvk.Kind = "ClusterRoleBinding"
		}
		gvk.Version = "v1"
	}

	groups, err := crd.Groups()
	if err != nil {
		return "", fmt.Errorf("failed to get CRD groups: %w", err)
	}

	crdAvailable := false
	for _, value := range groups {
		if gvk.Group == value {
			crdAvailable = true
			break
		}
	}

	// this is static information we can discover from our CRDs.
	if crdAvailable {
		objCrd, err := crd.CRDForGVK(gvk)
		if err != nil {
			return "", fmt.Errorf("failed to get CRD for GroupVersionKind: %w", err)
		}

		return objCrd.Spec.Names.Plural, nil
	}

	// if we don't have the CRD stored, we will try to discover this dynamically.

	rmapping, err := restMapper.RESTMapping(gvk.GroupKind(), gvk.Version)
	if err != nil {
		return "", fmt.Errorf("failed to get REST Mapping for '%s': %w", gvk.GroupKind().String(), err)
	}

	return rmapping.Resource.Resource, nil
}
