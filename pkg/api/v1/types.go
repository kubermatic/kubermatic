/*
Copyright 2020 The Kubermatic Kubernetes Platform contributors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package v1

import (
	"encoding/json"
	"fmt"
	"strings"

	"github.com/Masterminds/semver/v3"

	"github.com/kubermatic/machine-controller/pkg/apis/cluster/v1alpha1"
	"github.com/kubermatic/machine-controller/pkg/userdata/flatcar"
	"k8c.io/kubermatic/v2/pkg/controller/master-controller-manager/rbac"
	kubermaticv1 "k8c.io/kubermatic/v2/pkg/crd/kubermatic/v1"
	ksemver "k8c.io/kubermatic/v2/pkg/semver"

	corev1 "k8s.io/api/core/v1"
	rbacv1 "k8s.io/api/rbac/v1"
)

// ObjectMeta defines the set of fields that objects returned from the API have
// swagger:model ObjectMeta
type ObjectMeta struct {
	// ID unique value that identifies the resource generated by the server. Read-Only.
	ID string `json:"id,omitempty"`

	// Name represents human readable name for the resource
	Name string `json:"name"`

	// DeletionTimestamp is a timestamp representing the server time when this object was deleted.
	// swagger:strfmt date-time
	DeletionTimestamp *Time `json:"deletionTimestamp,omitempty"`

	// CreationTimestamp is a timestamp representing the server time when this object was created.
	// swagger:strfmt date-time
	CreationTimestamp Time `json:"creationTimestamp,omitempty"`
}

// DatacenterSpec specifies the data for a datacenter.
type DatacenterSpec struct {
	// Name of the seed this datacenter belongs to.
	Seed string `json:"seed,omitempty"`
	// Optional: Country of the seed as ISO-3166 two-letter code, e.g. DE or UK.
	// It is used for informational purposes.
	Country string `json:"country,omitempty"`
	// Optional: Detailed location of the cluster, like "Hamburg" or "Datacenter 7".
	// It is used for informational purposes.
	Location string `json:"location,omitempty"`
	// Name of the datacenter provider. Extracted based on which provider is defined in the spec.
	// It is used for informational purposes.
	Provider     string                                   `json:"provider,omitempty"`
	Digitalocean *kubermaticv1.DatacenterSpecDigitalocean `json:"digitalocean,omitempty"`
	BringYourOwn *kubermaticv1.DatacenterSpecBringYourOwn `json:"bringyourown,omitempty"`
	AWS          *kubermaticv1.DatacenterSpecAWS          `json:"aws,omitempty"`
	Azure        *kubermaticv1.DatacenterSpecAzure        `json:"azure,omitempty"`
	Openstack    *kubermaticv1.DatacenterSpecOpenstack    `json:"openstack,omitempty"`
	Packet       *kubermaticv1.DatacenterSpecPacket       `json:"packet,omitempty"`
	GCP          *kubermaticv1.DatacenterSpecGCP          `json:"gcp,omitempty"`
	Hetzner      *kubermaticv1.DatacenterSpecHetzner      `json:"hetzner,omitempty"`
	VSphere      *kubermaticv1.DatacenterSpecVSphere      `json:"vsphere,omitempty"`
	Kubevirt     *kubermaticv1.DatacenterSpecKubevirt     `json:"kubevirt,omitempty"`
	Alibaba      *kubermaticv1.DatacenterSpecAlibaba      `json:"alibaba,omitempty"`
	Anexia       *kubermaticv1.DatacenterSpecAnexia       `json:"anexia,omitempty"`

	//nolint:staticcheck
	//lint:ignore SA5008 omitgenyaml is used by the example-yaml-generator
	Fake *kubermaticv1.DatacenterSpecFake `json:"fake,omitempty,omitgenyaml"`

	// Node holds node-specific settings, like e.g. HTTP proxy, Docker
	// registries and the like. Proxy settings are inherited from the seed if
	// not specified here.
	Node kubermaticv1.NodeSettings `json:"node"`

	// Deprecated. Automatically migrated to the RequiredEmailDomains field.
	RequiredEmailDomain  string   `json:"requiredEmailDomain,omitempty"`
	RequiredEmailDomains []string `json:"requiredEmailDomains,omitempty"`

	// EnforceAuditLogging enforces audit logging on every cluster within the DC,
	// ignoring cluster-specific settings.
	EnforceAuditLogging bool `json:"enforceAuditLogging"`

	// EnforcePodSecurityPolicy enforces pod security policy plugin on every clusters within the DC,
	// ignoring cluster-specific settings
	EnforcePodSecurityPolicy bool `json:"enforcePodSecurityPolicy"`
}

// DatacenterList represents a list of datacenters
// swagger:model DatacenterList
type DatacenterList []Datacenter

// Datacenter is the object representing a Kubernetes infra datacenter.
// swagger:model Datacenter
type Datacenter struct {
	Metadata DatacenterMeta `json:"metadata,omitempty"`
	Spec     DatacenterSpec `json:"spec,omitempty"`
}

// DatacenterMeta holds datacenter metadata information.
type DatacenterMeta struct {
	Name string `json:"name"`
}

// AWSSize represents a object of AWS size.
// swagger:model AWSSize
type AWSSize struct {
	Name       string  `json:"name"`
	PrettyName string  `json:"pretty_name"`
	Memory     float32 `json:"memory"`
	VCPUs      int     `json:"vcpus"`
	GPUs       int     `json:"gpus"`
	Price      float64 `json:"price"`
}

// AWSSizeList represents an array of AWS sizes.
// swagger:model AWSSizeList
type AWSSizeList []AWSSize

// AWSSubnetList represents an array of AWS availability subnets.
// swagger:model AWSSubnetList
type AWSSubnetList []AWSSubnet

// AWSSubnet represents a object of AWS availability subnet.
// swagger:model AWSSubnet
type AWSSubnet struct {
	Name                    string   `json:"name"`
	ID                      string   `json:"id"`
	AvailabilityZone        string   `json:"availability_zone"`
	AvailabilityZoneID      string   `json:"availability_zone_id"`
	IPv4CIDR                string   `json:"ipv4cidr"`
	IPv6CIDR                string   `json:"ipv6cidr"`
	Tags                    []AWSTag `json:"tags,omitempty"`
	State                   string   `json:"state"`
	AvailableIPAddressCount int64    `json:"available_ip_address_count"`
	DefaultForAz            bool     `json:"default"`
	IsDefaultSubnet         bool     `json:"isDefaultSubnet"`
}

// AWSTag represents a object of AWS tags.
// swagger:model AWSTag
type AWSTag struct {
	Key   string `json:"key"`
	Value string `json:"value"`
}

// AWSSecurityGroupList represents an array of AWS Security Group.
// swagger:model AWSSecurityGroupList
type AWSSecurityGroupList struct {
	IDs []string `json:"ids,omitempty"`
}

// AWSVPCList represents an array of AWS VPC's.
// swagger:model AWSVPCList
type AWSVPCList []AWSVPC

// AWSVPC represents a object of AWS VPC.
// swagger:model AWSVPC
type AWSVPC struct {
	// The primary IPv4 CIDR block for the VPC.
	CidrBlock string `json:"cidrBlock"`

	// Information about the IPv4 CIDR blocks associated with the VPC.
	CidrBlockAssociationSet []AWSVpcCidrBlockAssociation `json:"cidrBlockAssociationSet,omitempty"`

	// The ID of the set of DHCP options you've associated with the VPC (or default
	// if the default options are associated with the VPC).
	DhcpOptionsID string `json:"dhcpOptionsId"`

	// The allowed tenancy of instances launched into the VPC.
	InstanceTenancy string `json:"instanceTenancy"`

	// Information about the IPv6 CIDR blocks associated with the VPC.
	Ipv6CidrBlockAssociationSet []AWSVpcIpv6CidrBlockAssociation `json:"ipv6CidrBlockAssociationSet,omitempty"`

	// Indicates whether the VPC is the default VPC.
	IsDefault bool `json:"isDefault"`

	// The ID of the AWS account that owns the VPC.
	OwnerID string `json:"ownerId"`

	// The current state of the VPC.
	State string `json:"state"`

	// Any tags assigned to the VPC.
	Tags []AWSTag `json:"tags,omitempty"`

	Name string `json:"name"`

	// The ID of the VPC.
	VpcID string `json:"vpcId"`
}

// AWSVpcCidrBlockAssociation describes an IPv4 CIDR block associated with a VPC.
// swagger:model AWSVpcCidrBlockAssociation
type AWSVpcCidrBlockAssociation struct {
	// The association ID for the IPv4 CIDR block.
	AssociationID string `json:"associationId"`

	// The IPv4 CIDR block.
	CidrBlock string `json:"cidrBlock"`

	// The state of the CIDR block.
	State string `json:"state"`

	// A message about the status of the CIDR block, if applicable.
	StatusMessage string `json:"statusMessage"`
}

// AWSVpcIpv6CidrBlockAssociation describes an IPv6 CIDR block associated with a VPC.
// swagger:model AWSVpcIpv6CidrBlockAssociation
type AWSVpcIpv6CidrBlockAssociation struct {
	AWSVpcCidrBlockAssociation
}

// GCPDiskTypeList represents an array of GCP disk types.
// swagger:model GCPDiskTypeList
type GCPDiskTypeList []GCPDiskType

// GCPDiskType represents a object of GCP disk type.
// swagger:model GCPDiskType
type GCPDiskType struct {
	Name        string `json:"name"`
	Description string `json:"description"`
}

// GCPMachineSizeList represents an array of GCP machine sizes.
// swagger:model GCPMachineSizeList
type GCPMachineSizeList []GCPMachineSize

// GCPMachineSize represents a object of GCP machine size.
// swagger:model GCPMachineSize
type GCPMachineSize struct {
	Name        string `json:"name"`
	Description string `json:"description"`
	Memory      int64  `json:"memory"`
	VCPUs       int64  `json:"vcpus"`
}

// GCPZone represents a object of GCP zone.
// swagger:model GCPZone
type GCPZone struct {
	Name string `json:"name"`
}

// GCPZoneList represents an array of GCP zones.
// swagger:model GCPZoneList
type GCPZoneList []GCPZone

// GCPNetworkList represents an array of GCP networks.
// swagger:model GCPNetworkList
type GCPNetworkList []GCPNetwork

// GCPNetwork represents a object of GCP networks.
// swagger:model GCPNetwork
type GCPNetwork struct {
	ID                    uint64   `json:"id"`
	Name                  string   `json:"name"`
	AutoCreateSubnetworks bool     `json:"autoCreateSubnetworks"`
	Subnetworks           []string `json:"subnetworks"`
	Kind                  string   `json:"kind"`
	Path                  string   `json:"path"`
}

// GCPSubnetworkList represents an array of GCP subnetworks.
// swagger:model GCPSubnetworkList
type GCPSubnetworkList []GCPSubnetwork

// GCPSubnetwork represents a object of GCP subnetworks.
// swagger:model GCPSubnetwork
type GCPSubnetwork struct {
	ID                    uint64 `json:"id"`
	Name                  string `json:"name"`
	Network               string `json:"network"`
	IPCidrRange           string `json:"ipCidrRange"`
	GatewayAddress        string `json:"gatewayAddress"`
	Region                string `json:"region"`
	SelfLink              string `json:"selfLink"`
	PrivateIPGoogleAccess bool   `json:"privateIpGoogleAccess"`
	Kind                  string `json:"kind"`
	Path                  string `json:"path"`
}

// DigitaloceanSizeList represents a object of digitalocean sizes.
// swagger:model DigitaloceanSizeList
type DigitaloceanSizeList struct {
	Standard  []DigitaloceanSize `json:"standard"`
	Optimized []DigitaloceanSize `json:"optimized"`
}

// CredentialList represents a object for provider credential names.
// swagger:model CredentialList
type CredentialList struct {
	Names []string `json:"names,omitempty"`
}

// DigitaloceanSize is the object representing digitalocean sizes.
// swagger:model DigitaloceanSize
type DigitaloceanSize struct {
	Slug         string   `json:"slug"`
	Available    bool     `json:"available"`
	Transfer     float64  `json:"transfer"`
	PriceMonthly float64  `json:"price_monthly"`
	PriceHourly  float64  `json:"price_hourly"`
	Memory       int      `json:"memory"`
	VCPUs        int      `json:"vcpus"`
	Disk         int      `json:"disk"`
	Regions      []string `json:"regions"`
}

// AzureSubnetsList is the object representing the subnets for vms in azure cloud provider
// swagger:model AzureSubnetsList
type AzureSubnetsList struct {
	Subnets []string `json:"subnets"`
}

// AzureVirtualNetworksList is the object representing the virtual network for vms in azure cloud provider
// swagger:model AzureVirtualNetworksList
type AzureVirtualNetworksList struct {
	VirtualNetworks []string `json:"virtualNetworks"`
}

// AzureRouteTablesList is the object representing the route tables for vms in azure cloud provider
// swagger:model AzureRouteTablesList
type AzureRouteTablesList struct {
	RouteTables []string `json:"routeTables"`
}

// AzureSecurityGroupsList is the object representing the security groups for vms in azure cloud provider
// swagger:model AzureSecurityGroupsList
type AzureSecurityGroupsList struct {
	SecurityGroups []string `json:"securityGroups"`
}

// AzureResourceGroupsList is the object representing the resource groups for vms in azure cloud provider
// swagger:model AzureResourceGroupsList
type AzureResourceGroupsList struct {
	ResourceGroups []string `json:"resourceGroups"`
}

// AzureAvailabilityZonesList is the object representing the availability zones for vms in azure cloud provider
// swagger:model AzureAvailabilityZonesList
type AzureAvailabilityZonesList struct {
	Zones []string `json:"zones"`
}

// AzureSizeList represents an array of Azure VM sizes.
// swagger:model AzureSizeList
type AzureSizeList []AzureSize

// AzureSize is the object representing Azure VM sizes.
// swagger:model AzureSize
type AzureSize struct {
	Name                 string `json:"name"`
	NumberOfCores        int32  `json:"numberOfCores"`
	OsDiskSizeInMB       int32  `json:"osDiskSizeInMB"`
	ResourceDiskSizeInMB int32  `json:"resourceDiskSizeInMB"`
	MemoryInMB           int32  `json:"memoryInMB"`
	MaxDataDiskCount     int32  `json:"maxDataDiskCount"`
}

// HetznerSizeList represents an array of Hetzner sizes.
// swagger:model HetznerSizeList
type HetznerSizeList struct {
	Standard  []HetznerSize `json:"standard"`
	Dedicated []HetznerSize `json:"dedicated"`
}

// HetznerSize is the object representing Hetzner sizes.
// swagger:model HetznerSize
type HetznerSize struct {
	ID          int     `json:"id"`
	Name        string  `json:"name"`
	Description string  `json:"description"`
	Cores       int     `json:"cores"`
	Memory      float32 `json:"memory"`
	Disk        int     `json:"disk"`
}

// PacketSizeList represents an array of Packet VM sizes.
// swagger:model PacketSizeList
type PacketSizeList []PacketSize

// PacketSize is the object representing Packet VM sizes.
// swagger:model PacketSize
type PacketSize struct {
	Name   string        `json:"name,omitempty"`
	CPUs   []PacketCPU   `json:"cpus,omitempty"`
	Memory string        `json:"memory,omitempty"`
	Drives []PacketDrive `json:"drives,omitempty"`
}

// PacketCPU represents an array of Packet CPUs. It is a part of PacketSize.
// swagger:model PacketCPU
type PacketCPU struct {
	Count int    `json:"count,omitempty"`
	Type  string `json:"type,omitempty"`
}

// PacketDrive represents an array of Packet drives. It is a part of PacketSize.
// swagger:model PacketDrive
type PacketDrive struct {
	Count int    `json:"count,omitempty"`
	Size  string `json:"size,omitempty"`
	Type  string `json:"type,omitempty"`
}

// SSHKey represents a ssh key
// swagger:model SSHKey
type SSHKey struct {
	ObjectMeta
	Spec SSHKeySpec `json:"spec"`
}

// SSHKeySpec represents the details of a ssh key
type SSHKeySpec struct {
	Fingerprint string `json:"fingerprint"`
	PublicKey   string `json:"publicKey"`
}

// User represent an API user
// swagger:model User
type User struct {
	ObjectMeta

	// Email an email address of the user
	Email string `json:"email"`
	// IsAdmin indicates admin role
	IsAdmin bool `json:"isAdmin,omitempty"`

	// Projects holds the list of project the user belongs to
	// along with the group names
	Projects []ProjectGroup `json:"projects,omitempty"`

	Settings *kubermaticv1.UserSettings `json:"userSettings,omitempty"`
}

func ConvertInternalUserToExternal(internalUser *kubermaticv1.User, includeSettings bool, bindings ...*kubermaticv1.UserProjectBinding) *User {
	apiUser := &User{
		ObjectMeta: ObjectMeta{
			ID:                internalUser.Name,
			Name:              internalUser.Spec.Name,
			CreationTimestamp: NewTime(internalUser.CreationTimestamp.Time),
		},
		Email:   internalUser.Spec.Email,
		IsAdmin: internalUser.Spec.IsAdmin,
	}

	if includeSettings {
		apiUser.Settings = internalUser.Spec.Settings
	}

	for _, binding := range bindings {
		bindingAlreadyExists := false
		for _, pg := range apiUser.Projects {
			if pg.ID == binding.Spec.ProjectID && pg.GroupPrefix == binding.Spec.Group {
				bindingAlreadyExists = true
				break
			}
		}
		if !bindingAlreadyExists {
			groupPrefix := rbac.ExtractGroupPrefix(binding.Spec.Group)
			apiUser.Projects = append(apiUser.Projects, ProjectGroup{ID: binding.Spec.ProjectID, GroupPrefix: groupPrefix})
		}
	}

	return apiUser
}

// Admin represents admin user
// swagger:model Admin
type Admin struct {
	// Email address of the admin user
	Email string `json:"email"`
	// Name of the admin user
	Name string `json:"name,omitempty"`
	// IsAdmin indicates admin role
	IsAdmin bool `json:"isAdmin"`
}

// ProjectGroup is a helper data structure that
// stores the information about a project and a group prefix that a user belongs to
type ProjectGroup struct {
	ID          string `json:"id"`
	GroupPrefix string `json:"group"`
}

// These are the valid statuses of a ServiceAccount.
const (
	// ServiceAccountActive means the ServiceAccount is available for use in the system
	ServiceAccountActive string = "Active"

	// ServiceAccountInactive means the ServiceAccount is inactive and requires further initialization
	ServiceAccountInactive string = "Inactive"

	// ServiceAccountTerminating means the ServiceAccount is undergoing graceful termination
	ServiceAccountTerminating string = "Terminating"
)

// ServiceAccount represent an API service account
// swagger:model ServiceAccount
type ServiceAccount struct {
	ObjectMeta
	// Status describes three stages of ServiceAccount life including Active, Inactive and Terminating
	Status string `json:"status"`
	// Group that a service account belongs to
	Group string `json:"group"`
}

// PublicServiceAccountToken represent an API service account token without secret fields
// swagger:model PublicServiceAccountToken
type PublicServiceAccountToken struct {
	ObjectMeta
	// Expiry is a timestamp representing the time when this token will expire.
	// swagger:strfmt date-time
	Expiry Time `json:"expiry,omitempty"`
}

// ServiceAccountToken represent an API service account token
// swagger:model ServiceAccountToken
type ServiceAccountToken struct {
	PublicServiceAccountToken
	// Token the JWT token
	Token string `json:"token,omitempty"`
}

// Project is a top-level container for a set of resources
// swagger:model Project
type Project struct {
	ObjectMeta
	Status string            `json:"status"`
	Labels map[string]string `json:"labels,omitempty"`
	// Owners an optional owners list for the given project
	Owners         []User `json:"owners,omitempty"`
	ClustersNumber int    `json:"clustersNumber,omitempty"`
}

// Kubeconfig is a clusters kubeconfig
// swagger:response Kubeconfig
type Kubeconfig struct {
	// in: body
	Config []byte
}

// OpenstackSize is the object representing openstack's sizes.
// swagger:model OpenstackSize
type OpenstackSize struct {
	// Slug holds  the name of the size
	Slug string `json:"slug"`
	// MemoryTotalBytes is the amount of memory, measured in MB
	Memory int `json:"memory"`
	// VCPUs indicates how many (virtual) CPUs are available for this flavor
	VCPUs int `json:"vcpus"`
	// Disk is the amount of root disk, measured in GB
	Disk int `json:"disk"`
	// Swap is the amount of swap space, measured in MB
	Swap int `json:"swap"`
	// Region specifies the geographic region in which the size resides
	Region string `json:"region"`
	// IsPublic indicates whether the size is public (available to all projects) or scoped to a set of projects
	IsPublic bool `json:"isPublic"`
}

// OpenstackSubnet is the object representing a openstack subnet.
// swagger:model OpenstackSubnet
type OpenstackSubnet struct {
	// Id uniquely identifies the subnet
	ID string `json:"id"`
	// Name is human-readable name for the subnet
	Name string `json:"name"`
}

// OpenstackTenant is the object representing a openstack tenant.
// swagger:model OpenstackTenant
type OpenstackTenant struct {
	// Id uniquely identifies the current tenant
	ID string `json:"id"`
	// Name is the name of the tenant
	Name string `json:"name"`
}

// OpenstackNetwork is the object representing a openstack network.
// swagger:model OpenstackNetwork
type OpenstackNetwork struct {
	// Id uniquely identifies the current network
	ID string `json:"id"`
	// Name is the name of the network
	Name string `json:"name"`
	// External set if network is the external network
	External bool `json:"external"`
}

// OpenstackSecurityGroup is the object representing a openstack security group.
// swagger:model OpenstackSecurityGroup
type OpenstackSecurityGroup struct {
	// Id uniquely identifies the current security group
	ID string `json:"id"`
	// Name is the name of the security group
	Name string `json:"name"`
}

// OpenstackAvailabilityZone is the object representing a openstack availability zone.
// swagger:model OpenstackAvailabilityZone
type OpenstackAvailabilityZone struct {
	// Name is the name of the availability zone
	Name string `json:"name"`
}

// VSphereNetwork is the object representing a vsphere network.
// swagger:model VSphereNetwork
type VSphereNetwork struct {
	// Name is the name of the network
	Name string `json:"name"`
	// AbsolutePath is the absolute path inside vCenter
	AbsolutePath string `json:"absolutePath"`
	// RelativePath is the relative path inside the datacenter
	RelativePath string `json:"relativePath"`
	// Type defines the type of network
	Type string `json:"type"`
}

// VSphereFolder is the object representing a vsphere folder.
// swagger:model VSphereFolder
type VSphereFolder struct {
	// Path is the path of the folder
	Path string `json:"path"`
}

// VSphereDatastoreList is the object representing a vsphere datastores.
// swagger:model VSphereDatastoreList
type VSphereDatastoreList struct {
	Datastores []string `json:"datastores"`
}

// AlibabaInstanceTypeList represents an array of Alibaba instance types.
// swagger:model AlibabaInstanceTypeList
type AlibabaInstanceTypeList []AlibabaInstanceType

// AlibabaInstanceType represents a object of Alibaba instance type.
// swagger:model AlibabaInstanceType
type AlibabaInstanceType struct {
	ID           string  `json:"id"`
	CPUCoreCount int     `json:"cpuCoreCount"`
	MemorySize   float64 `json:"memorySize"`
}

// AlibabaZoneList represents an array of Alibaba zones.
// swagger:model AlibabaZoneList
type AlibabaZoneList []AlibabaZone

// AlibabaZone represents a object of Alibaba zone.
// swagger:model AlibabaZone
type AlibabaZone struct {
	ID string `json:"id"`
}

// MasterVersion describes a version of the master components
// swagger:model MasterVersion
type MasterVersion struct {
	Version *semver.Version `json:"version"`
	Default bool            `json:"default,omitempty"`

	// If true, then given version control plane version is not compatible
	// with one of the kubelets inside cluster and shouldn't be used.
	RestrictedByKubeletVersion bool `json:"restrictedByKubeletVersion,omitempty"`
}

// CreateClusterSpec is the structure that is used to create cluster with its initial node deployment
// swagger:model CreateClusterSpec
type CreateClusterSpec struct {
	Cluster        Cluster         `json:"cluster"`
	NodeDeployment *NodeDeployment `json:"nodeDeployment,omitempty"`
}

const (
	// OpenShiftClusterType defines the OpenShift cluster type
	OpenShiftClusterType string = "openshift"
	// KubernetesClusterType defines the Kubernetes cluster type
	KubernetesClusterType string = "kubernetes"
)

// Cluster defines the cluster resource
//
// Note:
// Cluster has a custom MarshalJSON method defined
// and thus the output may vary
//
// swagger:model Cluster
type Cluster struct {
	ObjectMeta      `json:",inline"`
	Labels          map[string]string `json:"labels,omitempty"`
	InheritedLabels map[string]string `json:"inheritedLabels,omitempty"`
	Type            string            `json:"type"`
	Credential      string            `json:"credential,omitempty"`
	Spec            ClusterSpec       `json:"spec"`
	Status          ClusterStatus     `json:"status"`
}

// ClusterSpec defines the cluster specification
type ClusterSpec struct {
	// Cloud specifies the cloud providers configuration
	Cloud kubermaticv1.CloudSpec `json:"cloud"`

	// MachineNetworks optionally specifies the parameters for IPAM.
	MachineNetworks []kubermaticv1.MachineNetworkingConfig `json:"machineNetworks,omitempty"`

	// Version desired version of the kubernetes master components
	Version ksemver.Semver `json:"version"`

	// OIDC settings
	OIDC kubermaticv1.OIDCSettings `json:"oidc,omitempty"`

	// Configure cluster upgrade window, currently used for flatcar node reboots
	UpdateWindow *kubermaticv1.UpdateWindow `json:"updateWindow,omitempty"`

	// If active the PodSecurityPolicy admission plugin is configured at the apiserver
	UsePodSecurityPolicyAdmissionPlugin bool `json:"usePodSecurityPolicyAdmissionPlugin,omitempty"`

	// If active the PodNodeSelector admission plugin is configured at the apiserver
	UsePodNodeSelectorAdmissionPlugin bool `json:"usePodNodeSelectorAdmissionPlugin,omitempty"`

	// EnableUserSSHKeyAgent control whether the UserSSHKeyAgent will be deployed in the user cluster or not.
	// If it was enabled, the agent will be deployed and used to sync the user ssh keys, that the user attach
	// to the created cluster. If the agent was disabled, it won't be deployed in the user cluster, thus after
	// the cluster creation any attached ssh keys won't be synced to the worker nodes. Once the agent is enabled/disabled
	// it cannot be changed after the cluster is being created.
	EnableUserSSHKeyAgent *bool `json:"enableUserSSHKeyAgent,omitempty"`

	// PodNodeSelectorAdmissionPluginConfig provides the configuration for the PodNodeSelector.
	// It's used by the backend to create a configuration file for this plugin.
	// The key:value from the map is converted to the namespace:<node-selectors-labels> in the file.
	// The format in a file:
	// podNodeSelectorPluginConfig:
	//  clusterDefaultNodeSelector: <node-selectors-labels>
	//  namespace1: <node-selectors-labels>
	//  namespace2: <node-selectors-labels>
	PodNodeSelectorAdmissionPluginConfig map[string]string `json:"podNodeSelectorAdmissionPluginConfig,omitempty"`

	// Additional Admission Controller plugins
	AdmissionPlugins []string `json:"admissionPlugins,omitempty"`

	// AuditLogging
	AuditLogging *kubermaticv1.AuditLoggingSettings `json:"auditLogging,omitempty"`

	// ServiceAccount contains service account related settings for the kube-apiserver of user cluster.
	ServiceAccount *kubermaticv1.ServiceAccountSettings `json:"serviceAccount,omitempty"`

	// Openshift holds all openshift-specific settings
	Openshift *kubermaticv1.Openshift `json:"openshift,omitempty"`

	// OPAIntegration is a preview feature that enables OPA integration with Kubermatic for the cluster.
	// Enabling it causes gatekeeper and its resources to be deployed on the user cluster.
	// By default it is disabled.
	OPAIntegration *kubermaticv1.OPAIntegrationSettings `json:"opaIntegration,omitempty"`
}

// MarshalJSON marshals ClusterSpec object into JSON. It is overwritten to control data
// that will be returned in the API responses (see: PublicCloudSpec struct).
func (cs *ClusterSpec) MarshalJSON() ([]byte, error) {
	ret, err := json.Marshal(struct {
		Cloud                                PublicCloudSpec                        `json:"cloud"`
		MachineNetworks                      []kubermaticv1.MachineNetworkingConfig `json:"machineNetworks,omitempty"`
		Version                              ksemver.Semver                         `json:"version"`
		OIDC                                 kubermaticv1.OIDCSettings              `json:"oidc"`
		UpdateWindow                         *kubermaticv1.UpdateWindow             `json:"updateWindow,omitempty"`
		UsePodSecurityPolicyAdmissionPlugin  bool                                   `json:"usePodSecurityPolicyAdmissionPlugin,omitempty"`
		UsePodNodeSelectorAdmissionPlugin    bool                                   `json:"usePodNodeSelectorAdmissionPlugin,omitempty"`
		EnableUserSSHKeyAgent                *bool                                  `json:"enableUserSSHKeyAgent,omitempty"`
		AuditLogging                         *kubermaticv1.AuditLoggingSettings     `json:"auditLogging,omitempty"`
		AdmissionPlugins                     []string                               `json:"admissionPlugins,omitempty"`
		PodNodeSelectorAdmissionPluginConfig map[string]string                      `json:"podNodeSelectorAdmissionPluginConfig,omitempty"`
		ServiceAccount                       *kubermaticv1.ServiceAccountSettings   `json:"serviceAccount,omitempty"`
		OPAIntegration                       *kubermaticv1.OPAIntegrationSettings   `json:"opaIntegration,omitempty"`
	}{
		Cloud: PublicCloudSpec{
			DatacenterName: cs.Cloud.DatacenterName,
			Fake:           newPublicFakeCloudSpec(cs.Cloud.Fake),
			Digitalocean:   newPublicDigitaloceanCloudSpec(cs.Cloud.Digitalocean),
			BringYourOwn:   newPublicBringYourOwnCloudSpec(cs.Cloud.BringYourOwn),
			AWS:            newPublicAWSCloudSpec(cs.Cloud.AWS),
			Azure:          newPublicAzureCloudSpec(cs.Cloud.Azure),
			Openstack:      newPublicOpenstackCloudSpec(cs.Cloud.Openstack),
			Packet:         newPublicPacketCloudSpec(cs.Cloud.Packet),
			Hetzner:        newPublicHetznerCloudSpec(cs.Cloud.Hetzner),
			VSphere:        newPublicVSphereCloudSpec(cs.Cloud.VSphere),
			GCP:            newPublicGCPCloudSpec(cs.Cloud.GCP),
			Kubevirt:       newPublicKubevirtCloudSpec(cs.Cloud.Kubevirt),
			Alibaba:        newPublicAlibabaCloudSpec(cs.Cloud.Alibaba),
			Anexia:         newPublicAnexiaCloudSpec(cs.Cloud.Anexia),
		},
		Version:                              cs.Version,
		MachineNetworks:                      cs.MachineNetworks,
		OIDC:                                 cs.OIDC,
		UpdateWindow:                         cs.UpdateWindow,
		UsePodSecurityPolicyAdmissionPlugin:  cs.UsePodSecurityPolicyAdmissionPlugin,
		UsePodNodeSelectorAdmissionPlugin:    cs.UsePodNodeSelectorAdmissionPlugin,
		EnableUserSSHKeyAgent:                cs.EnableUserSSHKeyAgent,
		AuditLogging:                         cs.AuditLogging,
		AdmissionPlugins:                     cs.AdmissionPlugins,
		PodNodeSelectorAdmissionPluginConfig: cs.PodNodeSelectorAdmissionPluginConfig,
		ServiceAccount:                       cs.ServiceAccount,
		OPAIntegration:                       cs.OPAIntegration,
	})

	return ret, err
}

// PublicCloudSpec is a public counterpart of apiv1.CloudSpec.
// swagger:model PublicCloudSpec
type PublicCloudSpec struct {
	DatacenterName string                       `json:"dc"`
	Fake           *PublicFakeCloudSpec         `json:"fake,omitempty"`
	Digitalocean   *PublicDigitaloceanCloudSpec `json:"digitalocean,omitempty"`
	BringYourOwn   *PublicBringYourOwnCloudSpec `json:"bringyourown,omitempty"`
	AWS            *PublicAWSCloudSpec          `json:"aws,omitempty"`
	Azure          *PublicAzureCloudSpec        `json:"azure,omitempty"`
	Openstack      *PublicOpenstackCloudSpec    `json:"openstack,omitempty"`
	Packet         *PublicPacketCloudSpec       `json:"packet,omitempty"`
	Hetzner        *PublicHetznerCloudSpec      `json:"hetzner,omitempty"`
	VSphere        *PublicVSphereCloudSpec      `json:"vsphere,omitempty"`
	GCP            *PublicGCPCloudSpec          `json:"gcp,omitempty"`
	Kubevirt       *PublicKubevirtCloudSpec     `json:"kubevirt,omitempty"`
	Alibaba        *PublicAlibabaCloudSpec      `json:"alibaba,omitempty"`
	Anexia         *PublicAnexiaCloudSpec       `json:"anexia,omitempty"`
}

// PublicFakeCloudSpec is a public counterpart of apiv1.FakeCloudSpec.
type PublicFakeCloudSpec struct{}

func newPublicFakeCloudSpec(internal *kubermaticv1.FakeCloudSpec) (public *PublicFakeCloudSpec) {
	if internal == nil {
		return nil
	}

	return &PublicFakeCloudSpec{}
}

// PublicDigitaloceanCloudSpec is a public counterpart of apiv1.DigitaloceanCloudSpec.
type PublicDigitaloceanCloudSpec struct{}

func newPublicDigitaloceanCloudSpec(internal *kubermaticv1.DigitaloceanCloudSpec) (public *PublicDigitaloceanCloudSpec) {
	if internal == nil {
		return nil
	}

	return &PublicDigitaloceanCloudSpec{}
}

// PublicHetznerCloudSpec is a public counterpart of apiv1.HetznerCloudSpec.
type PublicHetznerCloudSpec struct{}

func newPublicHetznerCloudSpec(internal *kubermaticv1.HetznerCloudSpec) (public *PublicHetznerCloudSpec) {
	if internal == nil {
		return nil
	}

	return &PublicHetznerCloudSpec{}
}

// PublicAzureCloudSpec is a public counterpart of apiv1.AzureCloudSpec.
type PublicAzureCloudSpec struct{}

func newPublicAzureCloudSpec(internal *kubermaticv1.AzureCloudSpec) (public *PublicAzureCloudSpec) {
	if internal == nil {
		return nil
	}

	return &PublicAzureCloudSpec{}
}

// PublicVSphereCloudSpec is a public counterpart of apiv1.VSphereCloudSpec.
type PublicVSphereCloudSpec struct{}

func newPublicVSphereCloudSpec(internal *kubermaticv1.VSphereCloudSpec) (public *PublicVSphereCloudSpec) {
	if internal == nil {
		return nil
	}

	return &PublicVSphereCloudSpec{}
}

// PublicBringYourOwnCloudSpec is a public counterpart of apiv1.BringYourOwnCloudSpec.
type PublicBringYourOwnCloudSpec struct{}

func newPublicBringYourOwnCloudSpec(internal *kubermaticv1.BringYourOwnCloudSpec) (public *PublicBringYourOwnCloudSpec) {
	if internal == nil {
		return nil
	}

	return &PublicBringYourOwnCloudSpec{}
}

// PublicAWSCloudSpec is a public counterpart of apiv1.AWSCloudSpec.
type PublicAWSCloudSpec struct{}

func newPublicAWSCloudSpec(internal *kubermaticv1.AWSCloudSpec) (public *PublicAWSCloudSpec) {
	if internal == nil {
		return nil
	}

	return &PublicAWSCloudSpec{}
}

// PublicOpenstackCloudSpec is a public counterpart of apiv1.OpenstackCloudSpec.
type PublicOpenstackCloudSpec struct {
	FloatingIPPool string `json:"floatingIpPool"`
	Tenant         string `json:"tenant,omitempty"`
	TenantID       string `json:"tenantID,omitempty"`
	Domain         string `json:"domain,omitempty"`
	Network        string `json:"network"`
	SecurityGroups string `json:"securityGroups"`
	RouterID       string `json:"routerID"`
	SubnetID       string `json:"subnetID"`
}

func newPublicOpenstackCloudSpec(internal *kubermaticv1.OpenstackCloudSpec) (public *PublicOpenstackCloudSpec) {
	if internal == nil {
		return nil
	}

	return &PublicOpenstackCloudSpec{
		FloatingIPPool: internal.FloatingIPPool,
		Tenant:         internal.Tenant,
		TenantID:       internal.TenantID,
		Domain:         internal.Domain,
		Network:        internal.Network,
		SecurityGroups: internal.SecurityGroups,
		RouterID:       internal.RouterID,
		SubnetID:       internal.SubnetID,
	}
}

// PublicPacketCloudSpec is a public counterpart of apiv1.PacketCloudSpec.
type PublicPacketCloudSpec struct{}

func newPublicPacketCloudSpec(internal *kubermaticv1.PacketCloudSpec) (public *PublicPacketCloudSpec) {
	if internal == nil {
		return nil
	}

	return &PublicPacketCloudSpec{}
}

// PublicGCPCloudSpec is a public counterpart of apiv1.GCPCloudSpec.
type PublicGCPCloudSpec struct{}

func newPublicGCPCloudSpec(internal *kubermaticv1.GCPCloudSpec) (public *PublicGCPCloudSpec) {
	if internal == nil {
		return nil
	}

	return &PublicGCPCloudSpec{}
}

// PublicKubevirtCloudSpec is a public counterpart of apiv1.KubevirtCloudSpec.
type PublicKubevirtCloudSpec struct{}

func newPublicKubevirtCloudSpec(internal *kubermaticv1.KubevirtCloudSpec) (public *PublicKubevirtCloudSpec) {
	if internal == nil {
		return nil
	}

	return &PublicKubevirtCloudSpec{}
}

// PublicAlibabaCloudSpec is a public counterpart of apiv1.AlibabaCloudSpec.
type PublicAlibabaCloudSpec struct{}

func newPublicAlibabaCloudSpec(internal *kubermaticv1.AlibabaCloudSpec) (public *PublicAlibabaCloudSpec) {
	if internal == nil {
		return nil
	}

	return &PublicAlibabaCloudSpec{}
}

// PublicAnexiaCloudSpec is a public counterpart of apiv1.AnexiaCloudSpec.
type PublicAnexiaCloudSpec struct{}

func newPublicAnexiaCloudSpec(internal *kubermaticv1.AnexiaCloudSpec) (public *PublicAnexiaCloudSpec) {
	if internal == nil {
		return nil
	}

	return &PublicAnexiaCloudSpec{}
}

// ClusterStatus defines the cluster status
type ClusterStatus struct {
	// Version actual version of the kubernetes master components
	Version ksemver.Semver `json:"version"`

	// URL specifies the address at which the cluster is available
	URL string `json:"url"`
}

// ClusterHealth stores health information about the cluster's components.
// swagger:model ClusterHealth
type ClusterHealth struct {
	Apiserver                    kubermaticv1.HealthStatus `json:"apiserver"`
	Scheduler                    kubermaticv1.HealthStatus `json:"scheduler"`
	Controller                   kubermaticv1.HealthStatus `json:"controller"`
	MachineController            kubermaticv1.HealthStatus `json:"machineController"`
	Etcd                         kubermaticv1.HealthStatus `json:"etcd"`
	CloudProviderInfrastructure  kubermaticv1.HealthStatus `json:"cloudProviderInfrastructure"`
	UserClusterControllerManager kubermaticv1.HealthStatus `json:"userClusterControllerManager"`
	GatekeeperController         kubermaticv1.HealthStatus `json:"gatekeeperController,omitempty"`
	GatekeeperAudit              kubermaticv1.HealthStatus `json:"gatekeeperAudit,omitempty"`
}

// AccessibleAddons represents an array of addons that can be configured in the user clusters.
// swagger:model AccessibleAddons
type AccessibleAddons []string

// Addon represents a predefined addon that users may install into their cluster
// swagger:model Addon
type Addon struct {
	ObjectMeta `json:",inline"`

	Spec AddonSpec `json:"spec"`
}

// AddonSpec addon specification
// swagger:model AddonSpec
type AddonSpec struct {
	// Variables is free form data to use for parsing the manifest templates
	Variables map[string]interface{} `json:"variables,omitempty"`
	// IsDefault indicates whether the addon is default
	IsDefault bool `json:"isDefault,omitempty"`
	// ContinuouslyReconcile indicates that the addon cannot be deleted or modified outside of the UI after installation
	ContinuouslyReconcile bool `json:"continuouslyReconcile,omitempty"`
}

// AddonConfig represents a addon configuration
// swagger:model AddonConfig
type AddonConfig struct {
	ObjectMeta `json:",inline"`

	Spec kubermaticv1.AddonConfigSpec `json:"spec"`
}

// ClusterList represents a list of clusters
// swagger:model ClusterList
type ClusterList []Cluster

// Node represents a worker node that is part of a cluster
// swagger:model Node
type Node struct {
	ObjectMeta `json:",inline"`
	Spec       NodeSpec   `json:"spec"`
	Status     NodeStatus `json:"status"`
}

// NodeCloudSpec represents the collection of cloud provider specific settings. Only one must be set at a time.
// swagger:model NodeCloudSpec
type NodeCloudSpec struct {
	Digitalocean *DigitaloceanNodeSpec `json:"digitalocean,omitempty"`
	AWS          *AWSNodeSpec          `json:"aws,omitempty"`
	Azure        *AzureNodeSpec        `json:"azure,omitempty"`
	Openstack    *OpenstackNodeSpec    `json:"openstack,omitempty"`
	Packet       *PacketNodeSpec       `json:"packet,omitempty"`
	Hetzner      *HetznerNodeSpec      `json:"hetzner,omitempty"`
	VSphere      *VSphereNodeSpec      `json:"vsphere,omitempty"`
	GCP          *GCPNodeSpec          `json:"gcp,omitempty"`
	Kubevirt     *KubevirtNodeSpec     `json:"kubevirt,omitempty"`
	Alibaba      *AlibabaNodeSpec      `json:"alibaba,omitempty"`
	Anexia       *AnexiaNodeSpec       `json:"anexia,omitempty"`
}

// UbuntuSpec ubuntu specific settings
// swagger:model UbuntuSpec
type UbuntuSpec struct {
	// do a dist-upgrade on boot and reboot it required afterwards
	DistUpgradeOnBoot bool `json:"distUpgradeOnBoot"`
}

// CentOSSpec contains CentOS specific settings
type CentOSSpec struct {
	// do a dist-upgrade on boot and reboot it required afterwards
	DistUpgradeOnBoot bool `json:"distUpgradeOnBoot"`
}

// FlatcarSpec contains Flatcar Linux specific settings
// swagger:model FlatcarSpec
type FlatcarSpec struct {
	// disable flatcar linux auto-update feature
	DisableAutoUpdate bool `json:"disableAutoUpdate"`

	// ProvisioningUtility specifies the type of provisioning utility, allowed values are cloud-init and ignition.
	// Defaults to ignition.
	flatcar.ProvisioningUtility `json:"provisioningUtility,omitempty"`
}

// SLESSpec contains SLES specific settings
// swagger:model SLESSpec
type SLESSpec struct {
	// do a dist-upgrade on boot and reboot it required afterwards
	DistUpgradeOnBoot bool `json:"distUpgradeOnBoot"`
}

// RHELSpec contains rhel specific settings
// swagger:model RHELSpec
type RHELSpec struct {
	// do a dist-upgrade on boot and reboot it required afterwards
	DistUpgradeOnBoot               bool   `json:"distUpgradeOnBoot"`
	RHELSubscriptionManagerUser     string `json:"rhelSubscriptionManagerUser,omitempty"`
	RHELSubscriptionManagerPassword string `json:"rhelSubscriptionManagerPassword,omitempty"`
	RHSMOfflineToken                string `json:"rhsmOfflineToken,omitempty"`
}

// OperatingSystemSpec represents the collection of os specific settings. Only one must be set at a time.
// swagger:model OperatingSystemSpec
type OperatingSystemSpec struct {
	Ubuntu  *UbuntuSpec  `json:"ubuntu,omitempty"`
	CentOS  *CentOSSpec  `json:"centos,omitempty"`
	SLES    *SLESSpec    `json:"sles,omitempty"`
	RHEL    *RHELSpec    `json:"rhel,omitempty"`
	Flatcar *FlatcarSpec `json:"flatcar,omitempty"`
}

// NodeVersionInfo node version information
// swagger:model NodeVersionInfo
type NodeVersionInfo struct {
	Kubelet string `json:"kubelet"`
}

// TaintSpec defines a node taint
type TaintSpec struct {
	Key    string `json:"key"`
	Value  string `json:"value"`
	Effect string `json:"effect"`
}

// NodeSpec node specification
// swagger:model NodeSpec
type NodeSpec struct {
	// required: true
	Cloud NodeCloudSpec `json:"cloud"`
	// required: true
	OperatingSystem OperatingSystemSpec `json:"operatingSystem"`
	// required: false
	SSHUserName string `json:"sshUserName,omitempty"`
	// required: true
	Versions NodeVersionInfo `json:"versions,omitempty"`
	// Map of string keys and values that can be used to organize and categorize (scope and select) objects.
	// It will be applied to Nodes allowing users run their apps on specific Node using labelSelector.
	// required: false
	Labels map[string]string `json:"labels,omitempty"`
	// List of taints to set on new nodes
	Taints []TaintSpec `json:"taints,omitempty"`
}

// DigitaloceanNodeSpec digitalocean node settings
// swagger:model DigitaloceanNodeSpec
type DigitaloceanNodeSpec struct {
	// droplet size slug
	// required: true
	Size string `json:"size"`
	// enable backups for the droplet
	Backups bool `json:"backups"`
	// enable ipv6 for the droplet
	IPv6 bool `json:"ipv6"`
	// enable monitoring for the droplet
	Monitoring bool `json:"monitoring"`
	// additional droplet tags
	Tags []string `json:"tags"`
}

func (spec *DigitaloceanNodeSpec) MarshalJSON() ([]byte, error) {
	missing := make([]string, 0)

	if len(spec.Size) == 0 {
		missing = append(missing, "size")
	}

	if len(missing) > 0 {
		return []byte{}, fmt.Errorf("missing or invalid required parameter(s): %s", strings.Join(missing, ", "))
	}

	// Inlined anonymous mirror structure to allow usage of real marshal after validation
	res := struct {
		Size       string   `json:"size"`
		Backups    bool     `json:"backups"`
		IPv6       bool     `json:"ipv6"`
		Monitoring bool     `json:"monitoring"`
		Tags       []string `json:"tags"`
	}{
		Size:       spec.Size,
		Backups:    spec.Backups,
		IPv6:       spec.IPv6,
		Monitoring: spec.Monitoring,
		Tags:       spec.Tags,
	}

	return json.Marshal(&res)
}

// HetznerNodeSpec Hetzner node settings
// swagger:model HetznerNodeSpec
type HetznerNodeSpec struct {
	// server type
	// required: true
	Type string `json:"type"`
}

func (spec *HetznerNodeSpec) MarshalJSON() ([]byte, error) {
	missing := make([]string, 0)

	if len(spec.Type) == 0 {
		missing = append(missing, "type")
	}

	if len(missing) > 0 {
		return []byte{}, fmt.Errorf("missing or invalid required parameter(s): %s", strings.Join(missing, ", "))
	}

	res := struct {
		Type string `json:"type"`
	}{
		Type: spec.Type,
	}

	return json.Marshal(&res)
}

// AzureNodeSpec describes settings for an Azure node
// swagger:model AzureNodeSpec
type AzureNodeSpec struct {
	// VM size
	// required: true
	Size string `json:"size"`
	// should the machine have a publicly accessible IP address
	// required: false
	AssignPublicIP bool `json:"assignPublicIP"`
	// Additional metadata to set
	// required: false
	Tags map[string]string `json:"tags,omitempty"`
	// OS disk size in GB
	// required: false
	OSDiskSize int32 `json:"osDiskSize"`
	// Data disk size in GB
	// required: false
	DataDiskSize int32 `json:"dataDiskSize"`
	// Zones represents the availability zones for azure vms
	// required: false
	Zones []string `json:"zones"`
	// ImageID represents the ID of the image that should be used to run the node
	// required: false
	ImageID string `json:"imageID"`
}

func (spec *AzureNodeSpec) MarshalJSON() ([]byte, error) {
	missing := make([]string, 0)

	if len(spec.Size) == 0 {
		missing = append(missing, "size")
	}

	if len(missing) > 0 {
		return []byte{}, fmt.Errorf("missing or invalid required parameter(s): %s", strings.Join(missing, ", "))
	}

	res := struct {
		Size           string            `json:"size"`
		AssignPublicIP bool              `json:"assignPublicIP"`
		Tags           map[string]string `json:"tags,omitempty"`
		OSDiskSize     int32             `json:"osDiskSize"`
		DataDiskSize   int32             `json:"dataDiskSize"`
		Zones          []string          `json:"zones"`
		ImageID        string            `json:"imageID"`
	}{
		Size:           spec.Size,
		AssignPublicIP: spec.AssignPublicIP,
		Tags:           spec.Tags,
		OSDiskSize:     spec.OSDiskSize,
		DataDiskSize:   spec.DataDiskSize,
		Zones:          spec.Zones,
		ImageID:        spec.ImageID,
	}

	return json.Marshal(&res)
}

// VSphereNodeSpec VSphere node settings
// swagger:model VSphereNodeSpec
type VSphereNodeSpec struct {
	CPUs       int    `json:"cpus"`
	Memory     int    `json:"memory"`
	DiskSizeGB *int64 `json:"diskSizeGB,omitempty"`
	Template   string `json:"template"`
}

func (spec *VSphereNodeSpec) MarshalJSON() ([]byte, error) {
	missing := make([]string, 0)

	if spec.CPUs < 1 {
		missing = append(missing, "cpus")
	}

	if spec.Memory < 1 {
		missing = append(missing, "memory")
	}

	if spec.DiskSizeGB == nil || spec.DiskSizeGB != nil && *spec.DiskSizeGB < 1 {
		missing = append(missing, "diskSizeGB")
	}

	if len(spec.Template) == 0 {
		missing = append(missing, "template")
	}

	if len(missing) > 0 {
		return []byte{}, fmt.Errorf("missing or invalid required parameter(s): %s", strings.Join(missing, ", "))
	}

	res := struct {
		CPUs       int    `json:"cpus"`
		Memory     int    `json:"memory"`
		DiskSizeGB *int64 `json:"diskSizeGB,omitempty"`
		Template   string `json:"template"`
	}{
		CPUs:       spec.CPUs,
		Memory:     spec.Memory,
		DiskSizeGB: spec.DiskSizeGB,
		Template:   spec.Template,
	}

	return json.Marshal(&res)
}

// OpenstackNodeSpec openstack node settings
// swagger:model OpenstackNodeSpec
type OpenstackNodeSpec struct {
	// instance flavor
	// required: true
	Flavor string `json:"flavor"`
	// image to use
	// required: true
	Image string `json:"image"`
	// Additional metadata to set
	// required: false
	Tags map[string]string `json:"tags,omitempty"`
	// Defines whether floating ip should be used
	// required: false
	UseFloatingIP bool `json:"useFloatingIP,omitempty"`
	// if set, the rootDisk will be a volume. If not, the rootDisk will be on ephemeral storage and its size will be derived from the flavor
	// required: false
	RootDiskSizeGB *int `json:"diskSize"`
	// if not set, the default AZ from the Datacenter spec will be used
	// required: false
	AvailabilityZone string `json:"availabilityZone"`
	// Period of time to check for instance ready status
	// required: false
	InstanceReadyCheckPeriod string `json:"instanceReadyCheckPeriod"`
	// Max time to wait for the instance to be ready
	// required: false
	InstanceReadyCheckTimeout string `json:"instanceReadyCheckTimeout"`
}

func (spec *OpenstackNodeSpec) MarshalJSON() ([]byte, error) {
	missing := make([]string, 0)

	if len(spec.Flavor) == 0 {
		missing = append(missing, "flavor")
	}

	if len(spec.Image) == 0 {
		missing = append(missing, "image")
	}

	if len(missing) > 0 {
		return []byte{}, fmt.Errorf("missing or invalid required parameter(s): %s", strings.Join(missing, ", "))
	}

	res := struct {
		Flavor                    string            `json:"flavor"`
		Image                     string            `json:"image"`
		Tags                      map[string]string `json:"tags,omitempty"`
		UseFloatingIP             bool              `json:"useFloatingIP,omitempty"`
		RootDiskSizeGB            *int              `json:"diskSize"`
		AvailabilityZone          string            `json:"availabilityZone"`
		InstanceReadyCheckPeriod  string            `json:"instanceReadyCheckPeriod"`
		InstanceReadyCheckTimeout string            `json:"instanceReadyCheckTimeout"`
	}{
		Flavor:                    spec.Flavor,
		Image:                     spec.Image,
		Tags:                      spec.Tags,
		UseFloatingIP:             spec.UseFloatingIP,
		RootDiskSizeGB:            spec.RootDiskSizeGB,
		AvailabilityZone:          spec.AvailabilityZone,
		InstanceReadyCheckPeriod:  spec.InstanceReadyCheckPeriod,
		InstanceReadyCheckTimeout: spec.InstanceReadyCheckTimeout,
	}

	return json.Marshal(&res)
}

// AWSNodeSpec aws specific node settings
// swagger:model AWSNodeSpec
type AWSNodeSpec struct {
	// instance type. for example: t2.micro
	// required: true
	InstanceType string `json:"instanceType"`
	// size of the volume in gb. Only one volume will be created
	// required: true
	VolumeSize int64 `json:"diskSize"`
	// type of the volume. for example: gp2, io1, st1, sc1, standard
	// required: true
	VolumeType string `json:"volumeType"`
	// ami to use. Will be defaulted to a ami for your selected operating system and region. Only set this when you know what you do.
	AMI string `json:"ami"`
	// additional instance tags
	Tags map[string]string `json:"tags"`
	// Availability zone in which to place the node. It is coupled with the subnet to which the node will belong.
	AvailabilityZone string `json:"availabilityZone"`
	// The VPC subnet to which the node shall be connected.
	SubnetID string `json:"subnetID"`
	// This flag controls a property of the AWS instance. When set the AWS instance will get a public IP address
	// assigned during launch overriding a possible setting in the used AWS subnet.
	// required: false
	AssignPublicIP *bool `json:"assignPublicIP"`
}

func (spec *AWSNodeSpec) MarshalJSON() ([]byte, error) {
	missing := make([]string, 0)

	if len(spec.InstanceType) == 0 {
		missing = append(missing, "instanceType")
	}

	if spec.VolumeSize < 1 {
		missing = append(missing, "diskSize")
	}

	if len(spec.VolumeType) == 0 {
		missing = append(missing, "volumeType")
	}

	if len(missing) > 0 {
		return []byte{}, fmt.Errorf("missing or invalid required parameter(s): %s", strings.Join(missing, ", "))
	}

	res := struct {
		InstanceType     string            `json:"instanceType"`
		VolumeSize       int64             `json:"diskSize"`
		VolumeType       string            `json:"volumeType"`
		AMI              string            `json:"ami"`
		Tags             map[string]string `json:"tags"`
		AvailabilityZone string            `json:"availabilityZone"`
		SubnetID         string            `json:"subnetID"`
		AssignPublicIP   *bool             `json:"assignPublicIP"`
	}{
		InstanceType:     spec.InstanceType,
		VolumeSize:       spec.VolumeSize,
		VolumeType:       spec.VolumeType,
		AMI:              spec.AMI,
		Tags:             spec.Tags,
		AvailabilityZone: spec.AvailabilityZone,
		SubnetID:         spec.SubnetID,
		AssignPublicIP:   spec.AssignPublicIP,
	}

	return json.Marshal(&res)
}

// PacketNodeSpec specifies packet specific node settings
// swagger:model PacketNodeSpec
type PacketNodeSpec struct {
	// InstanceType denotes the plan to which the device will be provisioned.
	// required: true
	InstanceType string `json:"instanceType"`
	// additional instance tags
	// required: false
	Tags []string `json:"tags"`
}

func (spec *PacketNodeSpec) MarshalJSON() ([]byte, error) {
	missing := make([]string, 0)

	if len(spec.InstanceType) == 0 {
		missing = append(missing, "instanceType")
	}

	if len(missing) > 0 {
		return []byte{}, fmt.Errorf("missing or invalid required parameter(s): %s", strings.Join(missing, ", "))
	}

	res := struct {
		InstanceType string   `json:"instanceType"`
		Tags         []string `json:"tags"`
	}{
		InstanceType: spec.InstanceType,
		Tags:         spec.Tags,
	}

	return json.Marshal(&res)
}

// GCPNodeSpec gcp specific node settings
// swagger:model GCPNodeSpec
type GCPNodeSpec struct {
	Zone        string            `json:"zone"`
	MachineType string            `json:"machineType"`
	DiskSize    int64             `json:"diskSize"`
	DiskType    string            `json:"diskType"`
	Preemptible bool              `json:"preemptible"`
	Labels      map[string]string `json:"labels"`
	Tags        []string          `json:"tags"`
	CustomImage string            `json:"customImage"`
}

func (spec *GCPNodeSpec) MarshalJSON() ([]byte, error) {
	missing := make([]string, 0)

	if len(spec.Zone) == 0 {
		missing = append(missing, "zone")
	}

	if spec.DiskSize < 1 {
		missing = append(missing, "diskSize")
	}

	if len(spec.MachineType) == 0 {
		missing = append(missing, "machineType")
	}

	if len(spec.DiskType) == 0 {
		missing = append(missing, "diskType")
	}

	if len(missing) > 0 {
		return []byte{}, fmt.Errorf("missing or invalid required parameter(s): %s", strings.Join(missing, ", "))
	}

	res := struct {
		Zone        string            `json:"zone"`
		MachineType string            `json:"machineType"`
		DiskSize    int64             `json:"diskSize"`
		DiskType    string            `json:"diskType"`
		Preemptible bool              `json:"preemptible"`
		Labels      map[string]string `json:"labels"`
		Tags        []string          `json:"tags"`
		CustomImage string            `json:"customImage"`
	}{
		Zone:        spec.Zone,
		MachineType: spec.MachineType,
		DiskSize:    spec.DiskSize,
		DiskType:    spec.DiskType,
		Preemptible: spec.Preemptible,
		Labels:      spec.Labels,
		Tags:        spec.Tags,
		CustomImage: spec.CustomImage,
	}

	return json.Marshal(&res)
}

// KubevirtNodeSpec kubevirt specific node settings
// swagger:model KubevirtNodeSpec
type KubevirtNodeSpec struct {
	// CPUs states how many cpus the kubevirt node will have.
	// required: true
	CPUs string `json:"cpus"`
	// Memory states the memory that kubevirt node will have.
	// required: true
	Memory string `json:"memory"`
	// Namespace states in which namespace kubevirt node will be provisioned.
	// required: true
	Namespace string `json:"namespace"`
	// SourceURL states the url from which the imported image will be downloaded.
	// required: true
	SourceURL string `json:"sourceURL"`
	// StorageClassName states the storage class name for the provisioned PVCs.
	// required: true
	StorageClassName string `json:"storageClassName"`
	// PVCSize states the size of the provisioned pvc per node.
	// required: true
	PVCSize string `json:"pvcSize"`
}

func (spec *KubevirtNodeSpec) MarshalJSON() ([]byte, error) {
	missing := make([]string, 0)

	if len(spec.CPUs) == 0 {
		missing = append(missing, "cpus")
	}

	if len(spec.Memory) == 0 {
		missing = append(missing, "memory")
	}

	if len(spec.Namespace) == 0 {
		missing = append(missing, "namespace")
	}

	if len(spec.SourceURL) == 0 {
		missing = append(missing, "sourceURL")
	}

	if len(spec.StorageClassName) == 0 {
		missing = append(missing, "storageClassName")
	}

	if len(spec.PVCSize) == 0 {
		missing = append(missing, "pvcSize")
	}

	if len(missing) > 0 {
		return []byte{}, fmt.Errorf("missing or invalid required parameter(s): %s", strings.Join(missing, ", "))
	}

	res := struct {
		CPUs             string `json:"cpus"`
		Memory           string `json:"memory"`
		Namespace        string `json:"namespace"`
		SourceURL        string `json:"sourceURL"`
		StorageClassName string `json:"storageClassName"`
		PVCSize          string `json:"pvcSize"`
	}{
		CPUs:             spec.CPUs,
		Memory:           spec.Memory,
		Namespace:        spec.Namespace,
		SourceURL:        spec.SourceURL,
		StorageClassName: spec.StorageClassName,
		PVCSize:          spec.PVCSize,
	}

	return json.Marshal(&res)
}

// AlibabaNodeSpec alibaba specific node settings
// swagger:model AlibabaNodeSpec
type AlibabaNodeSpec struct {
	InstanceType            string            `json:"instanceType"`
	DiskSize                string            `json:"diskSize"`
	DiskType                string            `json:"diskType"`
	VSwitchID               string            `json:"vSwitchID"`
	InternetMaxBandwidthOut string            `json:"internetMaxBandwidthOut"`
	Labels                  map[string]string `json:"labels"`
	ZoneID                  string            `json:"zoneID"`
}

func (spec *AlibabaNodeSpec) MarshalJSON() ([]byte, error) {
	missing := make([]string, 0)

	if len(spec.InstanceType) == 0 {
		missing = append(missing, "instanceType")
	}

	if len(spec.DiskSize) == 0 {
		missing = append(missing, "diskSize")
	}

	if len(spec.DiskType) == 0 {
		missing = append(missing, "diskType")
	}

	if len(spec.VSwitchID) == 0 {
		missing = append(missing, "vSwitchID")
	}

	if len(spec.InternetMaxBandwidthOut) == 0 {
		missing = append(missing, "internetMaxBandwidthOut")
	}

	if len(spec.ZoneID) == 0 {
		missing = append(missing, "zoneID")
	}

	if len(missing) > 0 {
		return []byte{}, fmt.Errorf("missing or invalid required parameter(s): %s", strings.Join(missing, ", "))
	}

	res := struct {
		InstanceType            string            `json:"instanceType"`
		DiskSize                string            `json:"diskSize"`
		DiskType                string            `json:"diskType"`
		VSwitchID               string            `json:"vSwitchID"`
		InternetMaxBandwidthOut string            `json:"internetMaxBandwidthOut"`
		Labels                  map[string]string `json:"labels"`
		ZoneID                  string            `json:"zoneID"`
	}{
		InstanceType:            spec.InstanceType,
		VSwitchID:               spec.VSwitchID,
		DiskSize:                spec.DiskSize,
		DiskType:                spec.DiskType,
		InternetMaxBandwidthOut: spec.InternetMaxBandwidthOut,
		Labels:                  spec.Labels,
		ZoneID:                  spec.ZoneID,
	}

	return json.Marshal(&res)
}

// AnexiaNodeSpec anexia specific node settings
// swagger:model AnexiaNodeSpec
type AnexiaNodeSpec struct {
	// VlanID Instance vlanID
	// required: true
	VlanID string `json:"vlanID"`
	// TemplateID instance template
	// required: true
	TemplateID string `json:"templateID"`
	// CPUs states how many cpus the node will have.
	// required: true
	CPUs int `json:"cpus"`
	// Memory states the memory that node will have.
	// required: true
	Memory int64 `json:"memory"`
	// DiskSize states the disk size that node will have.
	// required: true
	DiskSize int64 `json:"diskSize"`
}

func (spec *AnexiaNodeSpec) MarshalJSON() ([]byte, error) {
	missing := make([]string, 0)

	if len(spec.VlanID) == 0 {
		missing = append(missing, "vlanID")
	}

	if spec.CPUs < 1 {
		missing = append(missing, "cpus")
	}

	if spec.Memory < 1 {
		missing = append(missing, "memory")
	}

	if spec.DiskSize < 1 {
		missing = append(missing, "diskSize")
	}

	if len(spec.TemplateID) == 0 {
		missing = append(missing, "templateID")
	}

	if len(missing) > 0 {
		return []byte{}, fmt.Errorf("missing or invalid required parameter(s): %s", strings.Join(missing, ", "))
	}

	res := struct {
		VlanID     string `json:"vlanID"`
		TemplateID string `json:"templateID"`
		CPUs       int    `json:"cpus"`
		Memory     int64  `json:"memory"`
		DiskSize   int64  `json:"diskSize"`
	}{
		VlanID:     spec.VlanID,
		TemplateID: spec.TemplateID,
		DiskSize:   spec.DiskSize,
		CPUs:       spec.CPUs,
		Memory:     spec.Memory,
	}

	return json.Marshal(&res)
}

// NodeResources cpu and memory of a node
// swagger:model NodeResources
type NodeResources struct {
	CPU    string `json:"cpu"`
	Memory string `json:"memory"`
}

// NodeStatus is information about the current status of a node.
// swagger:model NodeStatus
type NodeStatus struct {
	// name of the actual Machine object
	MachineName string `json:"machineName"`
	// resources in total
	Capacity NodeResources `json:"capacity,omitempty"`
	// allocatable resources
	Allocatable NodeResources `json:"allocatable,omitempty"`
	// different addresses of a node
	Addresses []NodeAddress `json:"addresses,omitempty"`
	// node versions and systems info
	NodeInfo NodeSystemInfo `json:"nodeInfo,omitempty"`

	// in case of a error this will contain a short error message
	ErrorReason string `json:"errorReason,omitempty"`
	// in case of a error this will contain a detailed error explanation
	ErrorMessage string `json:"errorMessage,omitempty"`
}

// NodeAddress contains information for the node's address.
// swagger:model NodeAddress
type NodeAddress struct {
	// address type. for example: ExternalIP, InternalIP, InternalDNS, ExternalDNS
	Type string `json:"type"`
	// the actual address. for example: 192.168.1.1, node1.my.dns
	Address string `json:"address"`
}

// NodeSystemInfo is a set of versions/ids/uuids to uniquely identify the node.
// swagger:model NodeSystemInfo
type NodeSystemInfo struct {
	KernelVersion           string `json:"kernelVersion"`
	ContainerRuntime        string `json:"containerRuntime"`
	ContainerRuntimeVersion string `json:"containerRuntimeVersion"`
	KubeletVersion          string `json:"kubeletVersion"`
	OperatingSystem         string `json:"operatingSystem"`
	Architecture            string `json:"architecture"`
}

// ClusterMetrics defines a metric for the given cluster
// swagger:model ClusterMetrics
type ClusterMetrics struct {
	Name                string              `json:"name"`
	ControlPlaneMetrics ControlPlaneMetrics `json:"controlPlane"`
	NodesMetrics        NodesMetric         `json:"nodes"`
}

// ControlPlaneMetrics defines a metric for the user cluster control plane resources
// swagger:model ControlPlaneMetrics
type ControlPlaneMetrics struct {
	// MemoryTotalBytes in bytes
	MemoryTotalBytes int64 `json:"memoryTotalBytes,omitempty"`
	// CPUTotalMillicores in m cores
	CPUTotalMillicores int64 `json:"cpuTotalMillicores,omitempty"`
}

// NodesMetric defines a metric for a group of nodes
// swagger:model NodesMetric
type NodesMetric struct {
	// MemoryTotalBytes current memory usage in bytes
	MemoryTotalBytes int64 `json:"memoryTotalBytes,omitempty"`
	// MemoryAvailableBytes available memory for node
	MemoryAvailableBytes int64 `json:"memoryAvailableBytes,omitempty"`
	// MemoryUsedPercentage in percentage
	MemoryUsedPercentage int64 `json:"memoryUsedPercentage,omitempty"`
	// CPUTotalMillicores in m cores
	CPUTotalMillicores     int64 `json:"cpuTotalMillicores,omitempty"`
	CPUAvailableMillicores int64 `json:"cpuAvailableMillicores,omitempty"`
	// CPUUsedPercentage in percentage
	CPUUsedPercentage int64 `json:"cpuUsedPercentage,omitempty"`
}

// NodeMetric defines a metric for the given node
// swagger:model NodeMetric
type NodeMetric struct {
	Name string `json:"name"`
	// MemoryTotalBytes current memory usage in bytes
	MemoryTotalBytes int64 `json:"memoryTotalBytes,omitempty"`
	// MemoryAvailableBytes available memory for node
	MemoryAvailableBytes int64 `json:"memoryAvailableBytes,omitempty"`
	// MemoryUsedPercentage in percentage
	MemoryUsedPercentage int64 `json:"memoryUsedPercentage,omitempty"`
	// CPUTotalMillicores in m cores
	CPUTotalMillicores     int64 `json:"cpuTotalMillicores,omitempty"`
	CPUAvailableMillicores int64 `json:"cpuAvailableMillicores,omitempty"`
	// CPUUsedPercentage in percentage
	CPUUsedPercentage int64 `json:"cpuUsedPercentage,omitempty"`
}

// NodeDeployment represents a set of worker nodes that is part of a cluster
// swagger:model NodeDeployment
type NodeDeployment struct {
	ObjectMeta `json:",inline"`

	Spec   NodeDeploymentSpec               `json:"spec"`
	Status v1alpha1.MachineDeploymentStatus `json:"status"`
}

// NodeDeploymentSpec node deployment specification
// swagger:model NodeDeploymentSpec
type NodeDeploymentSpec struct {
	// required: true
	Replicas int32 `json:"replicas,omitempty"`
	// required: true
	Template NodeSpec `json:"template"`
	// required: false
	Paused *bool `json:"paused,omitempty"`
	// required: false
	DynamicConfig *bool `json:"dynamicConfig,omitempty"`
}

// Event is a report of an event somewhere in the cluster.
// swagger:model Event
type Event struct {
	ObjectMeta `json:",inline"`

	// A human-readable description of the status of this operation.
	Message string `json:"message,omitempty"`

	// Type of this event (i.e. normal or warning). New types could be added in the future.
	Type string `json:"type,omitempty"`

	// The object reference that those events are about.
	InvolvedObject ObjectReferenceResource `json:"involvedObject"`

	// The time at which the most recent occurrence of this event was recorded.
	// swagger:strfmt date-time
	LastTimestamp Time `json:"lastTimestamp,omitempty"`

	// The number of times this event has occurred.
	Count int32 `json:"count,omitempty"`
}

// ObjectReferenceResource contains basic information about referred object.
type ObjectReferenceResource struct {
	// Type of the referent.
	Type string `json:"type,omitempty"`
	// Namespace of the referent.
	// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
	// +optional
	Namespace string `json:"namespace,omitempty"`
	// Name of the referent.
	// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
	// +optional
	Name string `json:"name,omitempty"`
}

// KubermaticVersions describes the versions of running Kubermatic components.
// swagger:model KubermaticVersions
type KubermaticVersions struct {
	// Version of the Kubermatic API server.
	API string `json:"api"`
}

// ClusterRole defines cluster RBAC role for the user cluster
// swagger:model ClusterRole
type ClusterRole struct {
	ObjectMeta `json:",inline"`
	// Rules holds all the PolicyRules for this ClusterRole
	Rules []rbacv1.PolicyRule `json:"rules"`
}

// RoleName defines RBAC role name object for the user cluster
// swagger:model RoleName
type RoleName struct {
	// Name of the role.
	Name string `json:"name"`
	// Indicates the scopes of this role.
	Namespace []string `json:"namespace"`
}

// ClusterRoleName defines RBAC cluster role name object for the user cluster
// swagger:model ClusterRoleName
type ClusterRoleName struct {
	// Name of the cluster role.
	Name string `json:"name"`
}

// RoleUser defines associated user with role
// swagger:model RoleUser
type RoleUser struct {
	UserEmail string `json:"userEmail"`
	Group     string `json:"group"`
}

// ClusterRoleUser defines associated user with cluster role
// swagger:model ClusterRoleUser
type ClusterRoleUser struct {
	UserEmail string `json:"userEmail"`
	Group     string `json:"group"`
}

// Role defines RBAC role for the user cluster
// swagger:model Role
type Role struct {
	ObjectMeta `json:",inline"`
	// Indicates the scope of this role.
	Namespace string `json:"namespace,omitempty"`
	// Rules holds all the PolicyRules for this Role
	Rules []rbacv1.PolicyRule `json:"rules"`
}

// RoleBinding references a role, but does not contain it.
// swagger:model RoleBinding
type RoleBinding struct {
	// Indicates the scope of this binding.
	Namespace string `json:"namespace,omitempty"`
	// Subjects holds references to the objects the role applies to.
	Subjects []rbacv1.Subject `json:"subjects,omitempty"`

	RoleRefName string `json:"roleRefName"`
}

// ClusterRoleBinding references a cluster role, but does not contain it.
// swagger:model ClusterRoleBinding
type ClusterRoleBinding struct {
	// Subjects holds references to the objects the role applies to.
	Subjects []rbacv1.Subject `json:"subjects,omitempty"`

	RoleRefName string `json:"roleRefName"`
}

// Subject contains a reference to the object or user identities a role binding applies to.
// Right now we support "User" as a API group.
type Subject struct {
	// Kind of object being referenced. Values defined by this API group are "User" and "Group".
	// If the Authorizer does not recognized the kind value, the Authorizer should report an error.
	Kind string `json:"kind"`
	// APIGroup holds the API group of the referenced subject.
	// Defaults to "rbac.authorization.k8s.io" for User and Group subjects.
	APIGroup string `json:"apiGroup,omitempty"`
	// Name of the object being referenced.
	Name string `json:"name"`
}

// Namespace defines namespace
// swagger:model Namespace
type Namespace struct {
	Name string `json:"name"`
}

// swagger:model ResourceType
type ResourceType string

// swagger:model LabelKeyList
type LabelKeyList []string

// ResourceLabelMap defines list of labels grouped by specific resource types.
//
// swagger:model ResourceLabelMap
type ResourceLabelMap map[ResourceType]LabelKeyList

// GlobalSettings defines global settings
// swagger:model GlobalSettings
type GlobalSettings kubermaticv1.SettingSpec

// GlobalCustomLinks defines custom links for global settings
// swagger:model GlobalCustomLinks
type GlobalCustomLinks []kubermaticv1.CustomLink

// AdmissionPluginList represents a list of admission plugins
// swagger:model AdmissionPluginList
type AdmissionPluginList []string

// AdmissionPlugin represents an admission plugin
// swagger:model AdmissionPlugin
type AdmissionPlugin struct {
	Name   string `json:"name"`
	Plugin string `json:"plugin"`
	// FromVersion flag can be empty. It means the plugin fit to all k8s versions
	FromVersion *ksemver.Semver `json:"fromVersion,omitempty"`
}

// Seed represents a seed object
// swagger:model Seed
type Seed struct {
	// Name represents human readable name for the resource
	Name string `json:"name"`

	SeedSpec `json:"spec"`
}

// The spec for a seed data
type SeedSpec struct {
	// Optional: Country of the seed as ISO-3166 two-letter code, e.g. DE or UK.
	// For informational purposes in the Kubermatic dashboard only.
	Country string `json:"country,omitempty"`
	// Optional: Detailed location of the cluster, like "Hamburg" or "Datacenter 7".
	// For informational purposes in the Kubermatic dashboard only.
	Location string `json:"location,omitempty"`
	// A reference to the Kubeconfig of this cluster. The Kubeconfig must
	// have cluster-admin privileges. This field is mandatory for every
	// seed, even if there are no datacenters defined yet.
	Kubeconfig corev1.ObjectReference `json:"kubeconfig"`
	// Datacenters contains a map of the possible datacenters (DCs) in this seed.
	// Each DC must have a globally unique identifier (i.e. names must be unique
	// across all seeds).
	SeedDatacenters map[string]Datacenter `json:"datacenters,omitempty"`
	// Optional: This can be used to override the DNS name used for this seed.
	// By default the seed name is used.
	SeedDNSOverwrite string `json:"seed_dns_overwrite,omitempty"`
	// Optional: ProxySettings can be used to configure HTTP proxy settings on the
	// worker nodes in user clusters. However, proxy settings on nodes take precedence.
	ProxySettings *kubermaticv1.ProxySettings `json:"proxy_settings,omitempty"`
	// Optional: ExposeStrategy explicitly sets the expose strategy for this seed cluster, if not set, the default provided by the master is used.
	ExposeStrategy kubermaticv1.ExposeStrategy `json:"expose_strategy,omitempty"`
}

// swagger:model SeedNamesList
type SeedNamesList []string

// SeedCluster holds seed name for the cluster
type SeedCluster struct {
	SeedName  string
	ClusterID string
}

const (
	// NodeDeletionFinalizer indicates that the nodes still need cleanup
	NodeDeletionFinalizer = "kubermatic.io/delete-nodes"
	// InClusterPVCleanupFinalizer indicates that the PVs still need cleanup
	InClusterPVCleanupFinalizer = "kubermatic.io/cleanup-in-cluster-pv"
	// InClusterLBCleanupFinalizer indicates that the LBs still need cleanup
	InClusterLBCleanupFinalizer = "kubermatic.io/cleanup-in-cluster-lb"
	// InClusterCredentialsRequestsCleanupFinalizer indicates that CredentialsRequests still need cleanup. This
	// CRD only exists on Openshift and is a no-op for Kubernetes.
	InClusterCredentialsRequestsCleanupFinalizer = "kubermatic.io/cleanup-credentials-requests"
	// InClusterImageRegistryConfigCleanupFinalizer indicates that CredentialsRequests still need
	// cleanup. This CRD only exists on Openshift and is a no-op for Kubernetes.
	InClusterImageRegistryConfigCleanupFinalizer = "kubermatic.io/cleanup-image-registry-configs"
	// CredentialsSecretsCleanupFinalizer indicates that secrets for credentials still need cleanup
	CredentialsSecretsCleanupFinalizer = "kubermatic.io/cleanup-credentials-secrets"
	// UserClusterRoleCleanupFinalizer indicates that user cluster role still need cleanup
	UserClusterRoleCleanupFinalizer = "kubermatic.io/user-cluster-role"
	// ExternalClusterKubeconfigCleanupFinalizer indicates that secrets for kubeconfig still need cleanup
	ExternalClusterKubeconfigCleanupFinalizer = "kubermatic.io/cleanup-kubeconfig-secret"
	// GatekeeperConstraintTemplateCleanupFinalizer indicates that synced gatekeeper Constraint Templates on user cluster need cleanup
	GatekeeperConstraintTemplateCleanupFinalizer = "kubermatic.io/cleanup-gatekeeper-constraint-templates"
	// GatekeeperSeedConstraintTemplateCleanupFinalizer indicates that synced gatekeeper Constraint Templates on seed clusters need cleanup
	GatekeeperSeedConstraintTemplateCleanupFinalizer = "kubermatic.io/cleanup-gatekeeper-master-constraint-templates"
	// GatekeeperConstraintCleanupFinalizer indicates that gatkeeper constraints on the user cluster need cleanup
	GatekeeperConstraintCleanupFinalizer = "kubermatic.io/cleanup-gatekeeper-constraints"
	// KubermaticConstraintCleanupFinalizer indicates that Kubermatic constraints for the cluster need cleanup
	KubermaticConstraintCleanupFinalizer = "kubermatic.io/cleanup-kubermatic-constraints"
)

func ToInternalClusterType(externalClusterType string) kubermaticv1.ClusterType {
	if externalClusterType == KubernetesClusterType {
		return kubermaticv1.ClusterTypeKubernetes
	}
	if externalClusterType == OpenShiftClusterType {
		return kubermaticv1.ClusterTypeOpenShift
	}
	return kubermaticv1.ClusterTypeAll
}

const (
	InitialMachineDeploymentRequestAnnotation = "kubermatic.io/initial-machinedeployment-request"
)
