//go:build ee

/*
                  Kubermatic Enterprise Read-Only License
                         Version 1.0 ("KERO-1.0”)
                     Copyright © 2025 Kubermatic GmbH

   1.	You may only view, read and display for studying purposes the source
      code of the software licensed under this license, and, to the extent
      explicitly provided under this license, the binary code.
   2.	Any use of the software which exceeds the foregoing right, including,
      without limitation, its execution, compilation, copying, modification
      and distribution, is expressly prohibited.
   3.	THE SOFTWARE IS PROVIDED “AS IS”, WITHOUT WARRANTY OF ANY KIND,
      EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
      MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
      IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
      CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
      TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
      SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

   END OF TERMS AND CONDITIONS
*/

package policybindingcontroller

import (
	"context"
	"encoding/json"
	"fmt"

	kyvernov1 "github.com/kyverno/kyverno/api/kyverno/v1"
	"go.uber.org/zap"

	kubermaticv1 "k8c.io/kubermatic/sdk/v2/apis/kubermatic/v1"
	userclustercontrollermanager "k8c.io/kubermatic/v2/pkg/controller/user-cluster-controller-manager"
	kuberneteshelper "k8c.io/kubermatic/v2/pkg/kubernetes"
	"k8c.io/kubermatic/v2/pkg/resources/reconciling"

	corev1 "k8s.io/api/core/v1"
	apierrors "k8s.io/apimachinery/pkg/api/errors"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/client-go/tools/record"
	"sigs.k8s.io/controller-runtime/pkg/builder"
	ctrlruntimeclient "sigs.k8s.io/controller-runtime/pkg/client"
	"sigs.k8s.io/controller-runtime/pkg/controller"
	"sigs.k8s.io/controller-runtime/pkg/handler"
	"sigs.k8s.io/controller-runtime/pkg/manager"
	"sigs.k8s.io/controller-runtime/pkg/reconcile"
	"sigs.k8s.io/controller-runtime/pkg/source"
)

const (
	ControllerName   = "kkp-policy-binding-controller"
	cleanupFinalizer = "kubermatic.k8c.io/cleanup-policy-binding"

	// Labels for Kyverno resources generated by this controller.
	LabelPolicyBinding  = "kubermatic.k8c.io/policy-binding"
	LabelPolicyTemplate = "kubermatic.k8c.io/policy-template"

	// Annotations for Kyverno resources.
	AnnotationTitle       = "policies.kyverno.io/title"
	AnnotationDescription = "policies.kyverno.io/description"
	AnnotationCategory    = "policies.kyverno.io/category"
	AnnotationSeverity    = "policies.kyverno.io/severity"
)

type reconciler struct {
	seedClient ctrlruntimeclient.Client
	userClient ctrlruntimeclient.Client

	log             *zap.SugaredLogger
	recorder        record.EventRecorder
	namespace       string
	clusterName     string
	clusterIsPaused userclustercontrollermanager.IsPausedChecker
}

// Add creates the controller and registers watches.
func Add(seedMgr, userMgr manager.Manager, log *zap.SugaredLogger, namespace, clusterName string, clusterIsPaused userclustercontrollermanager.IsPausedChecker) error {
	r := &reconciler{
		seedClient:      seedMgr.GetClient(),
		userClient:      userMgr.GetClient(),
		log:             log.Named(ControllerName),
		recorder:        userMgr.GetEventRecorderFor(ControllerName),
		namespace:       namespace,
		clusterName:     clusterName,
		clusterIsPaused: clusterIsPaused,
	}

	builderCtrl := builder.ControllerManagedBy(userMgr).
		Named(ControllerName).
		WithOptions(controller.Options{MaxConcurrentReconciles: 1}).
		WatchesRawSource(source.Kind(seedMgr.GetCache(), &kubermaticv1.PolicyBinding{},
			handler.TypedEnqueueRequestsFromMapFunc(mapPolicyBindingToRequest(namespace)),
		)).
		WatchesRawSource(source.Kind(seedMgr.GetCache(), &kubermaticv1.PolicyTemplate{},
			handler.TypedEnqueueRequestsFromMapFunc(mapPolicyTemplateToRequest(r.seedClient, namespace, r.log)),
		)).
		WatchesRawSource(source.Kind(userMgr.GetCache(), &kyvernov1.ClusterPolicy{},
			handler.TypedEnqueueRequestsFromMapFunc(mapClusterPolicyToRequest(namespace)),
		))

	_, err := builderCtrl.Build(r)
	return err
}

// Reconcile reconciles a single PolicyBinding.
func (r *reconciler) Reconcile(ctx context.Context, req reconcile.Request) (reconcile.Result, error) {
	log := r.log.With("binding", req.NamespacedName)
	log.Debug("Reconciling")

	paused, err := r.clusterIsPaused(ctx)
	if err != nil {
		return reconcile.Result{}, fmt.Errorf("failed to check cluster pause status: %w", err)
	}
	if paused {
		return reconcile.Result{}, nil
	}

	binding := &kubermaticv1.PolicyBinding{}
	if err := r.seedClient.Get(ctx, req.NamespacedName, binding); err != nil {
		log.Debug("policy binding not found, namespace: %s, name: %s", req.Namespace, req.Name)
		return reconcile.Result{}, ctrlruntimeclient.IgnoreNotFound(err)
	}

	cluster := &kubermaticv1.Cluster{}
	if err := r.seedClient.Get(ctx, ctrlruntimeclient.ObjectKey{Name: r.clusterName}, cluster); err != nil {
		log.Debug("cluster not found, name: %s", r.clusterName)
		return reconcile.Result{}, err
	}

	// Handle Kyverno disabled
	if !cluster.Spec.IsKyvernoEnabled() {
		return reconcile.Result{}, r.handlePolicyBindingCleanup(ctx, binding)
	}

	// Normal reconciling
	if err := r.reconcile(ctx, binding); err != nil {
		r.recorder.Event(binding, corev1.EventTypeWarning, "ReconcilingError", err.Error())
		return reconcile.Result{}, err
	}

	return reconcile.Result{}, nil
}

func (r *reconciler) reconcile(ctx context.Context, binding *kubermaticv1.PolicyBinding) error {
	if !binding.DeletionTimestamp.IsZero() {
		return r.handlePolicyBindingCleanup(ctx, binding)
	}

	if err := kuberneteshelper.TryAddFinalizer(ctx, r.seedClient, binding, cleanupFinalizer); err != nil {
		return fmt.Errorf("failed to add finalizer: %w", err)
	}

	template := &kubermaticv1.PolicyTemplate{}
	if err := r.seedClient.Get(ctx, ctrlruntimeclient.ObjectKey{Name: binding.Spec.PolicyTemplateRef.Name}, template); err != nil {
		if apierrors.IsNotFound(err) {
			return r.handlePolicyBindingCleanup(ctx, binding)
		}
		return err
	}

	if template.DeletionTimestamp != nil {
		return r.handlePolicyBindingCleanup(ctx, binding)
	}

	factories := []reconciling.NamedKyvernoClusterPolicyReconcilerFactory{
		r.clusterPolicyFactory(template, binding),
	}

	if err := reconciling.ReconcileKyvernoClusterPolicys(ctx, factories, "", r.userClient); err != nil {
		return fmt.Errorf("failed to reconcile ClusterPolicy: %w", err)
	}

	return nil
}

func (r *reconciler) clusterPolicyFactory(template *kubermaticv1.PolicyTemplate, binding *kubermaticv1.PolicyBinding) reconciling.NamedKyvernoClusterPolicyReconcilerFactory {
	return func() (string, reconciling.KyvernoClusterPolicyReconciler) {
		return template.Name, func(existing *kyvernov1.ClusterPolicy) (*kyvernov1.ClusterPolicy, error) {
			kuberneteshelper.EnsureLabels(existing, map[string]string{
				LabelPolicyBinding:  binding.Name,
				LabelPolicyTemplate: template.Name,
			})

			annotations := map[string]string{
				AnnotationTitle:       template.Spec.Title,
				AnnotationDescription: template.Spec.Description,
			}
			if template.Spec.Category != "" {
				annotations[AnnotationCategory] = template.Spec.Category
			}
			if template.Spec.Severity != "" {
				annotations[AnnotationSeverity] = template.Spec.Severity
			}
			for k, v := range template.Annotations {
				annotations[k] = v
			}
			kuberneteshelper.EnsureAnnotations(existing, annotations)

			// Kyverno Spec
			var spec kyvernov1.Spec
			if err := json.Unmarshal(template.Spec.PolicySpec.Raw, &spec); err != nil {
				return nil, fmt.Errorf("failed to unmarshal policySpec: %w", err)
			}
			existing.Spec = spec
			return existing, nil
		}
	}
}

// mapPolicyBindingToRequest maps a PolicyBinding to a reconcile.Request.
func mapPolicyBindingToRequest(namespace string) func(ctx context.Context, b *kubermaticv1.PolicyBinding) []reconcile.Request {
	return func(ctx context.Context, b *kubermaticv1.PolicyBinding) []reconcile.Request {
		if b.Namespace != namespace {
			return nil
		}
		return []reconcile.Request{{NamespacedName: ctrlruntimeclient.ObjectKey{Namespace: namespace, Name: b.Name}}}
	}
}

// mapPolicyTemplateToRequest maps a PolicyTemplate to reconcile.Request for related PolicyBindings.
func mapPolicyTemplateToRequest(seedClient ctrlruntimeclient.Client, namespace string, log *zap.SugaredLogger) func(ctx context.Context, tpl *kubermaticv1.PolicyTemplate) []reconcile.Request {
	return func(ctx context.Context, tpl *kubermaticv1.PolicyTemplate) []reconcile.Request {
		var reqs []reconcile.Request
		bindings := &kubermaticv1.PolicyBindingList{}
		if err := seedClient.List(ctx, bindings, ctrlruntimeclient.InNamespace(namespace)); err != nil {
			log.Errorw("failed to list PolicyBindings", "err", err)
			return nil
		}
		for _, b := range bindings.Items {
			if b.Spec.PolicyTemplateRef.Name == tpl.Name {
				reqs = append(reqs, reconcile.Request{NamespacedName: ctrlruntimeclient.ObjectKey{Namespace: namespace, Name: b.Name}})
			}
		}
		return reqs
	}
}

// mapClusterPolicyToRequest maps a ClusterPolicy to a reconcile.Request based on label.
func mapClusterPolicyToRequest(namespace string) func(ctx context.Context, cp *kyvernov1.ClusterPolicy) []reconcile.Request {
	return func(ctx context.Context, cp *kyvernov1.ClusterPolicy) []reconcile.Request {
		name, ok := cp.Labels[LabelPolicyBinding]
		if !ok {
			return nil
		}
		return []reconcile.Request{{NamespacedName: ctrlruntimeclient.ObjectKey{Namespace: namespace, Name: name}}}
	}
}

// handlePolicyBindingCleanup handles the cleanup of a PolicyBinding and its resources.
func (r *reconciler) handlePolicyBindingCleanup(ctx context.Context, binding *kubermaticv1.PolicyBinding) error {
	if err := r.deleteClusterPolicy(ctx, binding.Spec.PolicyTemplateRef.Name); err != nil {
		return fmt.Errorf("failed to delete ClusterPolicy: %w", err)
	}

	if err := kuberneteshelper.TryRemoveFinalizer(ctx, r.seedClient, binding, cleanupFinalizer); err != nil {
		return fmt.Errorf("failed to remove finalizer: %w", err)
	}

	return ctrlruntimeclient.IgnoreNotFound(r.seedClient.Delete(ctx, binding))
}

// deleteClusterPolicy removes the ClusterPolicy with the given name, ignoring NotFound.
func (r *reconciler) deleteClusterPolicy(ctx context.Context, policyName string) error {
	cp := &kyvernov1.ClusterPolicy{
		ObjectMeta: metav1.ObjectMeta{
			Name: policyName,
		},
	}
	return ctrlruntimeclient.IgnoreNotFound(r.userClient.Delete(ctx, cp))
}
