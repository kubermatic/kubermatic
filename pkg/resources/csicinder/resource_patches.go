/*
Copyright 2021 The Kubermatic Kubernetes Platform contributors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package csicinder

import (
	"k8c.io/kubermatic/v2/pkg/resources"

	corev1 "k8s.io/api/core/v1"
	"k8s.io/apimachinery/pkg/api/resource"
)

// The generated function names are too verbose to prevent name clashes, this mapping
// exports them to be more readable and not so verbose
var (
	ServiceCreator                  = openstackCinderCsiControllerpluginServiceCreator
	ControllerServiceAccountCreator = csiCinderControllerSaServiceAccountCreator
	StatefulSetCreator              = openstackCinderCsiControllerpluginStatefulSetCreator
)

// Patch the upstream autogenerated resources to reflect kubermatic requirements
// - the cinder plugin controller runs in seed cluster but needs to talk to user cluster
// - the resource controller expects limits, requests and image pull secret to be set
func init() {
	patchStatefulSetContainers()
	patchStatefulSetVolumes()
	s := &openstackCinderCsiControllerpluginStatefulSet
	s.Spec.Template.Spec.ImagePullSecrets = []corev1.LocalObjectReference{{Name: resources.ImagePullSecretName}}
}

func needsKubeconfig(containerName string) bool {
	switch containerName {
	case "csi-attacher", "csi-provisioner", "csi-snapshotter", "csi-resizer":
		return true
	}
	return false
}

func patchStatefulSetContainers() {
	s := &openstackCinderCsiControllerpluginStatefulSet
	for i, c := range s.Spec.Template.Spec.Containers {
		if needsKubeconfig(c.Name) {
			// Add kubeconfig to CSI sidecar containers
			s.Spec.Template.Spec.Containers[i].Args = append(c.Args, "--kubeconfig=/etc/kube/kubeconfig")
			s.Spec.Template.Spec.Containers[i].VolumeMounts = append(c.VolumeMounts, corev1.VolumeMount{
				Name: "kubeconfig", MountPath: "/etc/kube",
			})
		}
		// Add resource limits and requests
		s.Spec.Template.Spec.Containers[i].Resources = corev1.ResourceRequirements{
			Limits: corev1.ResourceList{
				corev1.ResourceCPU:    resource.MustParse("100m"),
				corev1.ResourceMemory: resource.MustParse("64Mi"),
			},
			Requests: corev1.ResourceList{
				corev1.ResourceCPU:    resource.MustParse("5m"),
				corev1.ResourceMemory: resource.MustParse("4Mi"),
			},
		}
	}
}

func patchStatefulSetVolumes() {
	s := &openstackCinderCsiControllerpluginStatefulSet
	// We store cloud-config in secret, upstream mounts from hostpath
	for i, v := range s.Spec.Template.Spec.Volumes {
		if v.Name == "cloud-config" {
			s.Spec.Template.Spec.Volumes[i] = corev1.Volume{
				Name: v.Name,
				VolumeSource: corev1.VolumeSource{
					Secret: &corev1.SecretVolumeSource{
						SecretName: "cloud-config",
					},
				},
			}
		}
	}
	// Mount secret with user cluster admin kubeconfig
	s.Spec.Template.Spec.Volumes = append(s.Spec.Template.Spec.Volumes, corev1.Volume{
		Name: "kubeconfig",
		VolumeSource: corev1.VolumeSource{
			Secret: &corev1.SecretVolumeSource{
				SecretName: "internal-admin-kubeconfig",
			},
		},
	})
}
