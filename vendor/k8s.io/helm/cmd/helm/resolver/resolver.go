/*
Copyright 2016 The Kubernetes Authors All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package resolver

import (
	"bytes"
	"encoding/json"
	"fmt"
	"time"

	"github.com/Masterminds/semver"

	"k8s.io/helm/cmd/helm/helmpath"
	"k8s.io/helm/pkg/chartutil"
	"k8s.io/helm/pkg/provenance"
)

// Resolver resolves dependencies from semantic version ranges to a particular version.
type Resolver struct {
	chartpath string
	helmhome  helmpath.Home
}

// New creates a new resolver for a given chart and a given helm home.
func New(chartpath string, helmhome helmpath.Home) *Resolver {
	return &Resolver{
		chartpath: chartpath,
		helmhome:  helmhome,
	}
}

// Resolve resolves dependencies and returns a lock file with the resolution.
func (r *Resolver) Resolve(reqs *chartutil.Requirements) (*chartutil.RequirementsLock, error) {
	d, err := HashReq(reqs)
	if err != nil {
		return nil, err
	}

	// Now we clone the dependencies, locking as we go.
	locked := make([]*chartutil.Dependency, len(reqs.Dependencies))
	for i, d := range reqs.Dependencies {
		// Right now, we're just copying one entry to another. What we need to
		// do here is parse the requirement as a SemVer range, and then look up
		// whether a version in index.yaml satisfies this constraint. If so,
		// we need to clone the dep, setting Version appropriately.
		// If not, we need to error out.
		if _, err := semver.NewVersion(d.Version); err != nil {
			return nil, fmt.Errorf("dependency %q has an invalid version: %s", d.Name, err)
		}
		locked[i] = &chartutil.Dependency{
			Name:       d.Name,
			Repository: d.Repository,
			Version:    d.Version,
		}
	}

	return &chartutil.RequirementsLock{
		Generated:    time.Now(),
		Digest:       d,
		Dependencies: locked,
	}, nil
}

// HashReq generates a hash of the requirements.
//
// This should be used only to compare against another hash generated by this
// function.
func HashReq(req *chartutil.Requirements) (string, error) {
	data, err := json.Marshal(req)
	if err != nil {
		return "", err
	}
	s, err := provenance.Digest(bytes.NewBuffer(data))
	return "sha256:" + s, err
}
